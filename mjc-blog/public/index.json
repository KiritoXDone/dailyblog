[{"content":"AtCoder ABC371C Make Isomorphic 给你简单的无向图 $G$ 和 $H$ ，每个图都有 $N$ 个顶点：顶点 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。图 $G$ 有 $M_G$ 条边，其第 $i$ 条边 $(1\\leq i\\leq M_G)$ 连接顶点 $u_i$ 和 $v_i$ 。图 $H$ 有 $M_H$ 条边，它的第 $i$ 条边 $(1\\leq i\\leq M_H)$ 连接顶点 $a_i$ 和 $b_i$ 。\n您可以在图 $H$ 上执行以下操作，次数不限，可能为零。\n选择一对满足 $1\\le i\u0026lt;j\\leq N$ 的整数 $(i,j)$ 。支付 $A_{i,j}$ 点成本，如果 $H$ 中的顶点 $i$ 和 $j$ 之间没有边，则添加一条；如果有，则删除。\n求使 $G$ 和 $H$ 同构所需的最小总成本。\n因为 $n\u0026lt;=8$ 所以可以直接暴力，遍历 $h$ 图的每一种与 $g$ 图的对应方式\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 1e3 + 7, mod = 1e9 + 7; void solve() { int n; cin \u0026gt;\u0026gt; n; bool g[N][N], h[N][N]; memset(g, false, sizeof(g)); memset(h, false, sizeof(h)); int mg, mh; cin \u0026gt;\u0026gt; mg; for (int i = 0; i \u0026lt; mg; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u][v] = g[v][u] = true; } cin \u0026gt;\u0026gt; mh; for (int i = 0; i \u0026lt; mh; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; h[u][v] = h[v][u] = true; } int cost[N][N]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; cost[i][j]; cost[j][i] = cost[i][j]; } } int p[n + 1]; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; int ans = 1e9; do { int tmp = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (g[i][j] ^ h[p[i]][p[j]]) tmp += cost[p[i]][p[j]]; } } ans = min(ans, tmp); } while (next_permutation(p + 1, p + 1 + n)); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC371E I Hate Sigma Problems 记录每一个数相同的数上次出现的位置，即可得到其对答案作出的贡献\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; vector\u0026lt;int\u0026gt;a(N),nxt(N),last(N); void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; ll sum=0,cnt=0; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=n;i++){ if(!vis[a[i]]){ vis[a[i]]=1; cnt++; } sum+=cnt; nxt[last[a[i]]]=i; last[a[i]]=i; } ll ans=sum; for(int i=1;i\u0026lt;=n;i++){ int t=nxt[i]; if(!t)t=n+1; sum-=t-i; ans+=sum; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373D Hidden Weights You are given a directed graph with $N$ vertices and $M$ edges. The $j$-th directed edge goes from vertex $u_j$ to vertex $v_j$ and has a weight of $w_j$.\nFind one way to write an integer between $-10^{18}$ and $10^{18}$, inclusive, to each vertex such that the following condition is satisfied.\nLet $x_i$ be the value written on vertex $i$. For all edges $j=1,2,\\dots,M$, it holds that $x_{v_j} - x_{u_j} = w_j$. It is guaranteed that at least one such assignment exists for the given input.\n加边时，加双向边，权值相反，接着直接对某个点开始跑 $bfs$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,m; struct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; ll ans[N],vis[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v,w; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w; edge[u].push_back({v,w}); edge[v].push_back({u,-w}); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; queue\u0026lt;int\u0026gt;q; q.push(i); vis[i]=1; while(!q.empty()){ int u=q.front(); for(auto i:edge[u]){ if(!vis[i.v]){ vis[i.v]=1; ans[i.v]=ans[u]+i.w; q.push(i.v); } } q.pop(); } } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373EHow to Win the Election 啥吊题，一眼看出来排序完二分答案，调一年没调出来\n二分检测时，看当前位加上 $mid$ 票后，是否还有 $\u0026gt;=m$ 个人的票可能比他多\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; ll n, m, k; ll a[N], b[N]; ll s[N]; bool check(ll f, int pos) { ll lft = k - f; int x = upper_bound(b + 1, b + 1 + n, a[pos] + f) - b - 1; int y = n - m + 1; if (n - x \u0026gt;= m) return false; if (b[y] \u0026gt; a[pos]) return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 1]) \u0026gt; lft; return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 2] - a[pos]) \u0026gt; lft; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; if (n == m) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; \u0026#34;0 \u0026#34;; return; } memcpy(b, a, (n + 1) * sizeof(ll)); sort(b + 1, b + 1 + n); for (int i = 1; i \u0026lt;= n; i++) s[i] = s[i - 1] + b[i]; k -= s[n]; for (int i = 1; i \u0026lt;= n; i++) { ll l = 0, r = k, ans = 1e18; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid, i)) ans = mid, r = mid - 1; else l = mid + 1; } cout \u0026lt;\u0026lt; (ans \u0026lt; 1e18 ? ans : -1) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } NowCoder K-th Number 二分答案检测过程中，记录从头到尾每个子区间的比 $mid$ 大的数的个数，然后再遍历数组，看每个位置的数能否作为第 $k$ 大的数进入数组 $b$ ,最后看找的数是否大于 $m$ 个\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; ll m; int a[N],s[N]; bool check(int f){ ll sum=0; int l=0; for(int i=1;i\u0026lt;=n;i++)s[i]=s[i-1]+(a[i]\u0026gt;=f); for(int i=1;i\u0026lt;=n;i++){ while(s[i]-s[l]\u0026gt;=k)l++; sum+=l; } return sum\u0026gt;=m; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int l=1,r=1e9,ans=1; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [SCOI2010]传送带 三分两条传送带上的点，这两点间走直线，其余部分走传送带\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; const double eps=1e-4; double ax,ay,bx,by,cx,cy,dx,dy; double p,q,r; double fx,fy,ex,ey; double dis(double x,double y,double a,double b){ return sqrt(eps+(x-a)*(x-a)+(y-b)*(y-b)); } double chec(double x){ fx=cx+(x/dis(cx,cy,dx,dy)*(dx-cx)),fy=cy+(x/dis(cx,cy,dx,dy)*(dy-cy)); return dis(fx,fy,ex,ey)/r+(dis(cx,cy,dx,dy)-x)/q; } double check(double x){ ex=ax+(x/dis(ax,ay,bx,by)*(bx-ax)),ey=ay+(x/dis(ax,ay,bx,by)*(by-ay)); double l=0,r=dis(cx,cy,dx,dy); for(int i=1;i\u0026lt;=1000;i++){ double lm=l+(r-l)/3,rm=r-(r-l)/3; if(chec(lm)\u0026gt;=chec(rm))l=lm; else r=rm; } return chec(l)+x/p; } void solve(){ cin\u0026gt;\u0026gt;ax\u0026gt;\u0026gt;ay\u0026gt;\u0026gt;bx\u0026gt;\u0026gt;by\u0026gt;\u0026gt;cx\u0026gt;\u0026gt;cy\u0026gt;\u0026gt;dx\u0026gt;\u0026gt;dy\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q\u0026gt;\u0026gt;r; double l=0,r=dis(ax,ay,bx,by); for(int i=1;i\u0026lt;=1000;i++){ double ml=l+(r-l)/3,mr=r-(r-l)/3; if(check(ml)\u0026gt;=check(mr)){ l=ml; } else r=mr; } printf(\u0026#34;%.2lf\u0026#34;,check(l)); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小咪买东西 01 分数规划\n对 $double$ 类二分，限制二分循环次数来控制二分结束即可\n我们二分的是单位价格（即总价值/总花费）\n判断条件即为在这个单位条件下，买 $k$ 个商品能否仍然保持当前单位价格为正\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; int c[N],v[N]; double w[N]; bool check(double x){ for(int i=1;i\u0026lt;=n;i++)w[i]=v[i]-x*c[i]; sort(w+1,w+1+n,greater\u0026lt;double\u0026gt;()); double s=0; for(int i=1;i\u0026lt;=k;i++){ s+=w[i]; } return s\u0026gt;0; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;v[i]; double l=0,r=1e9; for(int i=1;i\u0026lt;=100;i++){ double mid=(l+r)/2; if(check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r)\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 栈和排序 知道入栈顺序，求字典序最大的出栈序列\n我们可以按倒序统计从后到当前位的最大值，在模拟出栈过程中，如果后面有比当前位大的数，那这一位就先不出栈\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; int a[N],mx[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=n;i\u0026gt;0;i--)mx[i]=max(mx[i+1],a[i]); for(int i=1;i\u0026lt;=n;i++){ while(!s.empty()\u0026amp;\u0026amp;s.top()\u0026gt;mx[i]){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } s.push(a[i]); } while(!s.empty()){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [NOIP2016]蚯蚓 如果全部在同一个队列或堆中进行存取，会超时。\n可以考虑分三个队列来储存，一个存的是原数据，切割后的两部分分开存在另外两个队列中。\n同时要考虑随时间变长这个过程，所以只存储原长，在取出时，加上当前时间增长的长度，存进去时，减掉增长的长度。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N = 1e5 + 7, mod = 1e9 + 7; int n, m, q, u, v, t; double p; queue\u0026lt;int\u0026gt; qu[3]; int a[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; t; p = static_cast\u0026lt;double\u0026gt;(u) / v; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + n, greater\u0026lt;int\u0026gt;()); for (int i = 1; i \u0026lt;= n; i++) qu[0].push(a[i]); for (int i = 1; i \u0026lt;= m; i++) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } int len = qu[pos].front() + (i - 1) * q; qu[pos].pop(); if (i % t == 0) cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#34; \u0026#34;; int l = len * p; int r = len - l; qu[1].push(l - q * i); qu[2].push(r - q * i); } cout \u0026lt;\u0026lt; endl; int cnt = 1; while (!qu[1].empty() || !qu[0].empty() || !qu[2].empty()) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } if (cnt % t == 0) cout \u0026lt;\u0026lt; qu[pos].front()+m*q \u0026lt;\u0026lt; \u0026#34; \u0026#34;; qu[pos].pop(); cnt++; } } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } Running Median 对顶堆\n开两个堆，按小到大各存一半，多出来的那个即为中位值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int p, n, a[N]; multiset\u0026lt;int\u0026gt; s1, s2; void balance() { while (s1.size() \u0026gt; s2.size() + 1) { s2.insert(*s1.rbegin()); s1.erase(prev(s1.end())); } while (s2.size() \u0026gt; s1.size()) { s1.insert(*s2.begin()); s2.erase(s2.begin()); } } void solve() { cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; s1.clear(); s2.clear(); int cnt=0,ans[N]; for (int i = 1; i \u0026lt;= n; i++) { if (s1.empty() || a[i] \u0026lt;= *s1.rbegin()) { s1.insert(a[i]); } else { s2.insert(a[i]); } balance(); if (i % 2 == 1) { ans[++cnt]=*s1.rbegin(); } } cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(int i=1;i\u0026lt;=cnt;i++){ cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(i%10==0\u0026amp;\u0026amp;i!=cnt)cout\u0026lt;\u0026lt;endl; } cout \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 任务 可以看到 $x$ 的系数远大于 $y$, 那么在对原数据排序时，优先 $x$.\n遍历每一个任务，将能完成当前任务的所有机器都插入堆中，用二分在堆中找到 $y$ 最小的机器，再继续向下遍历\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; struct Node{ int x,y; bool operator \u0026lt; (const Node\u0026amp; a){ if(x==a.x)return y\u0026gt;a.y; return x\u0026gt;a.x; } }; ll n,m,cnt,ans; Node ma[N],as[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;ma[i].x\u0026gt;\u0026gt;ma[i].y; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;as[i].x\u0026gt;\u0026gt;as[i].y; sort(as+1,as+1+m); sort(ma+1,ma+1+n); multiset\u0026lt;int\u0026gt;s; for(int i=1,j=1;i\u0026lt;=m;i++){ while(j\u0026lt;=n\u0026amp;\u0026amp;as[i].x\u0026lt;=ma[j].x)s.insert(ma[j++].y); auto it=s.lower_bound(as[i].y); if(it!=s.end())cnt++,ans+=500*as[i].x+2*as[i].y,s.erase(it); } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 叠积木 维护附加信息的并查集\n开 $fa[N]$ 并查集 $d[i]$ $i$ 下方的积木数 $cnt[i]$ $i$ 所在的联通块的数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int q, x, y; int fa[N], cnt[N], d[N]; int find(int x) { if (fa[x] == x) return x; int t = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = t; } void unite(int a, int b) { int fx = find(a), fy = find(b); if (fx != fy) { fa[fx] = fy; d[fx] = cnt[fy]; cnt[fy] += cnt[fx]; } } void solve() { cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; N; i++) { fa[i] = i; d[i] = 0; cnt[i] = 1; } while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;M\u0026#39;) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unite(x, y); } else { cin \u0026gt;\u0026gt; x; find(x); cout \u0026lt;\u0026lt; d[x] \u0026lt;\u0026lt; endl; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/202409/","summary":"AtCoder ABC371C Make Isomorphic 给你简单的无向图 $G$ 和 $H$ ，每个图都有 $N$ 个顶点：顶点 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。图 $G$ 有 $M_G$ 条边，其第 $i$ 条边 $(1\\leq i\\leq M_G)$ 连接顶点 $u_i$ 和 $v_i$ 。图 $H$ 有 $M_H$ 条边，它的第 $i$ 条边 $(1\\leq i\\leq M_H)$ 连接顶点 $a_i$ 和 $b_i$ 。 您可以在图 $H$ 上执行以下操作，次数不限，可能为零。 选择一对满足 $1\\le i\u0026lt;j\\leq N$ 的整数 $(i,j)$ 。支付 $A_{i,j}$ 点成本，如果 $H$ 中的顶点 $i$ 和 $j$ 之间","title":"今日刷题记录"},{"content":"前言 好久没写题了，被暴打。\n参赛过程也是抽象，开局就罚站 30 min\n补题 L 网络预选赛 好不容易卡出来题面，看到 L 已经过了不少了，卡了半天才提交过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e3+7, mod=1e9+7; void solve(){ int n, m, ans = 0; char mp[N][N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; mp[i][j]; for(int i = 1; i \u0026lt; n; i++){ for(int j = 1; j \u0026lt; m; j++){ if(mp[i][j] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j] == \u0026#39;p\u0026#39; \u0026amp;\u0026amp; mp[i][j+1] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j+1] == \u0026#39;c\u0026#39;) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } K 取沙子游戏 奇数时，一直取 1 即可。\n为偶数时，如果 $lowbit(n)\u0026lt;=k$，先手取 $lowbit(n)\u0026lt;=k$，再不断模仿后者即可。\n反之，随意取后的 $lowbit$ 一定 $\u0026lt;=k$，后手一定获胜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(lowbit(n)\u0026lt;=k)cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B 军训 II 显然是排序后的不整齐度最小，那么方案数就是数组中的重复数的排列组合之和，要注意有升序降序两种，但只有一种数时不考虑\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=998244353; ll n,a[N],ans=0,vis[N],cnt=0,answ=1,com[N]; void solve(){ cin\u0026gt;\u0026gt;n; com[0]=1; for(int i=1;i\u0026lt;=n;i++){ com[i]=(com[i-1]*i)%mod; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(!vis[a[i]])cnt++; vis[a[i]]++; } sort(a+1,a+1+n); for(int i=1;i\u0026lt;=n;i++){ ll mx=a[i],mn=a[i]; for(int j=i+1;j\u0026lt;=n;j++){ mx=max(mx,a[j]),mn=min(mn,a[i]); ans+=(mx-mn); } } for(int i=1;i\u0026lt;=n;i++){ if(vis[a[i]]==1)continue; answ=(answ*com[vis[a[i]]])%mod; vis[a[i]]=1; } if (cnt \u0026gt; 1) answ = (answ * 2) % mod; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;answ\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D 编码器-解码器 观察题目\n$S_i\u0026rsquo;=\\begin{cases}S_{i-1}\u0026rsquo;+a_i+S_{i-1}\u0026rsquo;\u0026amp;\\text{if}i\u0026gt;1\\a_1\u0026amp;\\text{if}i=1\\end{cases}$ 可以发现 $S_{i}\u0026rsquo;$ 是由 $S_{i-1}\u0026rsquo;$ 变换而来的，所以可以递推每一位 $i$ 上的答案\n可以开一个三维数组 $f[i][l][r]$ : $i$ 指第几位 $l$ 指从 $t$ 的第几位开始 $r$ 指到 $t$ 的第几位结束\n通过这种方法，我们可以记录 $t$ 的所有子串在当前 $i$ 位出现的次数，只需要将我们需要的子串拼接起来即可得到能找到的 $t$ 串数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=998244353; string s,t; int n,m; ll f[N][N][N]; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; n=s.length(),m=t.length(); for(int i=0;i\u0026lt;m;i++) if(s[0]==t[i])f[0][i][i]=1; for(int i=1;i\u0026lt;n;i++){ for(int l=0;l\u0026lt;m;l++){ for(int r=l;r\u0026lt;m;r++){ f[i][l][r]=(f[i-1][l][r]*2) % mod; if(l==r){ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+1) % mod; } else{ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+f[i-1][l+1][r]) % mod; if(s[i]==t[r])f[i][l][r]=(f[i][l][r]+f[i-1][l][r-1]) % mod; for(int k=l;k\u0026lt;r;k++) f[i][l][r]=(f[i][l][r]+f[i-1][l][k]*f[i-1][k+1][r]) % mod; for(int k=l+1;k\u0026lt;r;k++) if(s[i]==t[k])f[i][l][r]=(f[i][l][r]+f[i-1][l][k-1]*f[i-1][k+1][r]) % mod; } } } } cout\u0026lt;\u0026lt;f[n-1][0][m-1]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024ccpconline/","summary":"前言 好久没写题了，被暴打。 参赛过程也是抽象，开局就罚站 30 min 补题 L 网络预选赛 好不容易卡出来题面，看到 L 已经过了不少了，卡了半天才提交过 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e3+7, mod=1e9+7; void solve(){ int n, m, ans = 0; char mp[N][N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; mp[i][j]; for(int i = 1; i \u0026lt; n; i++){ for(int j = 1; j \u0026lt; m; j++){ if(mp[i][j] ==","title":"2024CCPC网络赛"},{"content":"2024 河南萌新联赛 6 装备二选一（一） 直接比较结果即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int t1 = 100 * b * a + 100 * (100 - a); int t2 = 100 * d * c + 100 * (100 - c); cout \u0026lt;\u0026lt; (t2 \u0026gt; t1 ? \u0026#34;YES\\n\u0026#34; : \u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } 追寻光的方向 开一个 $suf$ 数组，用于记录 $i$ 位置后最大的数的位置，再用 $cnt$ 统计一共需要多少次转移即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) const int N = 1e5+7, mod = 1e9+7; int n, l[N], suf[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i]; suf[n]=suf[n-1]=n; suf[n] = n; for (int i = n-1; i \u0026gt; 0; i--) { if (l[i+1] \u0026gt; l[suf[i+1]]) suf[i] = i+1; else suf[i] = suf[i+1]; } // for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;suf[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; int cnt = 0, now = 1; while (now \u0026lt; n) { now = suf[now]; cnt++; } cout \u0026lt;\u0026lt; cnt - 1 \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 百变吗喽 本身想用 $kmp$ 找最长前缀最长后缀二者两加为 $n$ 时即符合条件，一直只对 $95%$，改不出来，换题解的思路了，标记前缀后缀相同的位置，如果二者能碰到，或超过，就有答案存在，方案数为 $l-r+1$ 个\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int n,i1,i2; string s1,s2; int main(){ cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; n=s2.length(); for(i1=0;i1\u0026lt;n-1 \u0026amp;\u0026amp; s1[i1]==s2[i1];i1++); for(i2=n-1;i2\u0026gt;=0 \u0026amp;\u0026amp; s1[i2-1]==s2[i2];i2--); if(i2\u0026lt;=i1){ cout\u0026lt;\u0026lt;i1-i2+1\u0026lt;\u0026lt;endl; for(int i=i2;i\u0026lt;=i1;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s2[i]\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B6/","summary":"2024 河南萌新联赛 6 装备二选一（一） 直接比较结果即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int t1 = 100 * b * a + 100 * (100 - a); int t2 = 100 * d * c + 100 * (100 - c); cout \u0026lt;\u0026lt; (t2 \u0026gt; t1 ? \u0026#34;YES\\n\u0026#34; : \u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } 追寻光的方向 开一个 $suf$ 数组，用于记录 $i$ 位置后","title":"2024萌新联赛6"},{"content":"2024 河南萌新联赛 5 平方根 直接 sqrt 向下取整即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ unsigned long long n; cin\u0026gt;\u0026gt;n; long long ans=floor(sqrt(n)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } 爬楼梯 递归\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int f[1000005],mod=1e9+7; f[0]=f[1]=1; int n; cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=3;j++){ if(i-j\u0026lt;0)break; f[i]=(f[i]+f[i-j])%mod; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } 区间问题 1 线段树板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) #define int long long int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } signed main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); cin\u0026gt;\u0026gt;m; while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op; if (op == 1) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cin\u0026gt;\u0026gt;x; cout \u0026lt;\u0026lt; query(1, x, x, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 哥德巴赫猜想 埃氏筛找 5e4 以内的质数，暴力枚举是否有符合的即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e7 + 7, mod = 1e9 + 7; bool isp[N]; vector\u0026lt;int\u0026gt; pri; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; pri.size(); i++) { for (int j = pri.size() - 1; j \u0026gt; i; j--) { int tmp = pri[i] + pri[j]; if(tmp\u0026gt;=n)continue; if (isp[n - tmp]) { cout \u0026lt;\u0026lt; pri[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - tmp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pri[j] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } } cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(isp, 1, sizeof(isp)); isp[0] = isp[1] = 0; for (int i = 2; i * i \u0026lt;= N; i++) { if (isp[i]) { for (int j = i * i; j \u0026lt;= N; j += i) isp[j] = 0; } } for (int i = 2; i \u0026lt;= N; i++) if (isp[i]) pri.push_back(i); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 学生分组 先找超出的 mx，缺少的 mn，如果二者相等，直接得到答案，如果有一者更大，就判断能否用其他的所有数据补全这部分，如果可以答案即为这部分\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; ll l,r; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; // sort(a+1,a+1+n); ll mn=0,mnn=0,mx=0,mxx=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i]\u0026lt;l)mn+=(l-a[i]),mnn+=(r-a[i]); else if(a[i]\u0026gt;r)mx+=(a[i]-r),mxx+=(a[i]-l); else mnn+=(r-a[i]),mxx+=(a[i]-l); } ll ans=0; if(mx==mn)ans=mx; else if(mx\u0026gt;mn){ if(mx\u0026gt;mnn){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mx; } else{ if(mn\u0026gt;mxx){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mn; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小美想游泳 dijkstra 但是找的不是最短路，而是路径中经过的 max 最小，改变 dist 数组中统计的数据即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5; #define int long long const int INF = LLONG_MAX; struct Node { int y, v; Node(int _y, int _v) { y = _y; v = _v; } }; int n, m, s, t, dist[N]; vector\u0026lt;Node\u0026gt; edge[N]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); fill(dist, dist + N, INF); dist[s] = 0; q.insert({0, s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto i : edge[x]) { int new_dist = max(dist[x], i.v); if (new_dist \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = new_dist; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } signed main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, a; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; a; edge[u].push_back({v, a}); edge[v].push_back({u, a}); } cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; dijkstra(s, t); return 0; } 小美想打音游 显然是将所有分数变为已有分数中的一个，将数组排序后，从小到大遍历，计算当前魔力值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; int sum = 0; vector\u0026lt;int\u0026gt; a(n + 1,0); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum += a[i]; } int ans = LLONG_MAX, pre = 0; sort(a.begin() + 1, a.end()); for (int i = 1; i \u0026lt;= n; i++) { pre += a[i]; ans = min(ans, a[i] * i - pre + sum - pre - a[i] * (n - i)); } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; return 0; } 区间问题 2 开始觉得是线段树，但是数据有 l = 0, 流汗黄豆了\n用 st 表可以过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e6+7; #define int long long int n, m; int a[N]; int st[N][21]; int l2[N]; void build() { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; (1 \u0026lt;\u0026lt; j) \u0026lt;= n; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j-1], st[i + (1 \u0026lt;\u0026lt; (j-1))][j-1]); } } } int query(int l, int r) { int j = l2[r - l + 1]; return max(st[l][j], st[r - (1 \u0026lt;\u0026lt; j) + 1][j]); } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; l2[1] = 0; for (int i = 2; i \u0026lt;= n; i++) { l2[i] = l2[i / 2] + 1; } build(); cin \u0026gt;\u0026gt; m; while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; query(l, r) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 小美想跑步 单向建图，建两个，反向找到的值即为跑回点 1 的值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e6 + 7, mod = 1e9 + 7; #define int long long struct Node { int y, v; Node(int _y, int _v) : y(_y), v(_v) {} }; int n, m; vector\u0026lt;Node\u0026gt; edge[N], edges[N]; vector\u0026lt;int\u0026gt; dist(N); void dijkstra(int s, vector\u0026lt;Node\u0026gt;edge[]) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; q; fill(dist.begin(), dist.end(), INT_MAX); dist[s] = 0; q.push({0, s}); while (!q.empty()) { int d = q.top().first; int x = q.top().second; q.pop(); if (d \u0026gt; dist[x]) continue; for (auto\u0026amp; i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { dist[i.y] = dist[x] + i.v; q.push({dist[i.y], i.y}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; edge[u].push_back({v, w}); edges[v].push_back({u, w}); } ll ans = 0; dijkstra(1, edge); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } dijkstra(1, edges); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 日历游戏 暴力 SG 函数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[30][20][40],day[20]={0,31,28,31,30,31,30,31,31,30,31,30,31}; void solve(){ int y,m,d; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; cout\u0026lt;\u0026lt;(sg[y%100][m][d]?\u0026#34;YES\\n\u0026#34;:\u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); for(int i=8;i\u0026lt;=12;i++) for(int j=1;j\u0026lt;=31;j++)sg[24][i][j]=1; sg[24][8][1]=0; for(int i=24;i\u0026gt;=0;i--){ for(int j=12;j\u0026gt;=1;j--){ if(i==24\u0026amp;\u0026amp;j\u0026gt;=8)continue; int d=day[j]; if(i%4==0\u0026amp;\u0026amp;j==2)d++; for(int k=d;k\u0026gt;0;k--){ int x=i,y=j,z=k+1; if(z\u0026gt;d)z=1,y++; if(y\u0026gt;12)y=1,x++; if(sg[x][y][z]==0){ sg[i][j][k]=1; continue; } x=i,y=j+1,z=k; bool flag=0; if(y\u0026gt;12)y=1,x++,flag=1; else if(y!=2){ if(z\u0026lt;=day[y])flag=1; } else{ int tmp=28; if(i%4==0)tmp=29; if(z\u0026lt;=tmp)flag=1; } if(flag\u0026amp;\u0026amp;sg[x][y][z]==0)sg[i][j][k]=1; } } } int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小美想收集 可以二分答案，判断是否符合二分图的性质\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; int n, m; int f[N]; struct Node { int x, y, z; }; vector\u0026lt;Node\u0026gt; a; int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } bool check(int mid) { iota(f, f + n + n + 1, 0); for (auto x : a) { if (x.z \u0026gt; mid) { int fx = find(x.x), fy = find(x.y); if (fx == fy) return false; f[find(x.x + n)] = find(x.y); f[find(x.y + n)] = find(x.x); } } return true; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; a.resize(m + 1); for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i].x \u0026gt;\u0026gt; a[i].y \u0026gt;\u0026gt; a[i].z; int l = 0, r = 1e6, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid - 1,ans=mid; else l = mid + 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B5/","summary":"2024 河南萌新联赛 5 平方根 直接 sqrt 向下取整即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ unsigned long long n; cin\u0026gt;\u0026gt;n; long long ans=floor(sqrt(n)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } 爬楼梯 递归 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int f[1000005],mod=1e9+7; f[0]=f[1]=1; int n; cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=3;j++){ if(i-j\u0026lt;0)break; f[i]=(f[i]+f[i-j])%mod; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } 区间问题 1 线段树板 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) #define int long long int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum","title":"2024萌新联赛5"},{"content":"AtCoder Beginner Contest 366 补题 A - Election 2 判断当前是否有值大于 $n/2$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,t,a; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t\u0026gt;\u0026gt;a; if(n==1\u0026amp;\u0026amp;t==0\u0026amp;\u0026amp;a==0){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else if(t\u0026gt;n/2||a\u0026gt;n/2){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B - Vertical Writing 翻转字符串，同时对翻转后的每行从末尾开始清 * 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,mx=0; cin\u0026gt;\u0026gt;n; string s[N]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; mx=max(mx,(int)s[i].length()); } string ans[mx+1]; for(int i=0;i\u0026lt;mx;i++){ for(int j=n;j\u0026gt;0;j--){ if(i\u0026gt;=s[j].length()) ans[i]+=\u0026#34;*\u0026#34;; else ans[i]+=s[j][i]; } } for(int i=0;i\u0026lt;mx;i++){ bool flag=0; for(int j=n-1;j\u0026gt;=0;j--){ if(ans[i][j]==\u0026#39;*\u0026#39;\u0026amp;\u0026amp;!flag){ ans[i][j]=\u0026#39; \u0026#39;; } if(ans[i][j]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;ans[i][j]\u0026lt;=\u0026#39;z\u0026#39;){ flag=1; } } cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - Balls and Bag Query 开一个 map 记录某一个值当前出现了几次，第一次出现就 cnt++, 出现次数变为 0 就 cnt\u0026ndash; 最后输出 cnt\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int q; cin\u0026gt;\u0026gt;q; unordered_map\u0026lt;int,int\u0026gt;vis; int cnt=0; while(q--){ int op,x; cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x; if(!vis[x])cnt++; vis[x]++; } else if(op==2){ cin\u0026gt;\u0026gt;x; vis[x]--; if(!vis[x])cnt--; } else cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D - Cuboid Sum Query 三维前缀和板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e2+10, mod = 1e9+7; #define int long long void solve(){ int n, a[N][N][N], q, lx, rx, ly, ry, lz, rz; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt;= n; j++){ for(int k = 1; k \u0026lt;= n; k++) cin \u0026gt;\u0026gt; a[i][j][k]; } } for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i - 1][j][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j - 1][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j][k - 1]; cin \u0026gt;\u0026gt; q; while(q--){ cin \u0026gt;\u0026gt; lx \u0026gt;\u0026gt; rx \u0026gt;\u0026gt; ly \u0026gt;\u0026gt; ry \u0026gt;\u0026gt; lz \u0026gt;\u0026gt; rz; ll sum = a[rx][ry][rz] - (lx \u0026gt; 1 ? a[lx-1][ry][rz] : 0) - (ly \u0026gt; 1 ? a[rx][ly-1][rz] : 0) - (lz \u0026gt; 1 ? a[rx][ry][lz-1] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 ? a[lx-1][ly-1][rz] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ry][lz-1] : 0) + (ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[rx][ly-1][lz-1] : 0) - (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ly-1][lz-1] : 0); cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } E - Manhattan Multifocal Ellipse 可以枚举 $x$ 从 $-2e6$ 到 $2e6$，去掉原式中的绝对值得到，$\\sum_{x_i \u0026lt; x} (x - x_i) + \\sum_{x_i \\geq x} (x_i - x)$，通过此公式可以得到每个 $x$ 的 $\\sum_{i=1}^{n} |x - x_i|$，同理求得 $\\sum_{i=1}^{n} |y - y_i|$，分别存入两个数组，将两个数组升序排序，此时只需要用双指针对每个 $x$ 找到其对应的最大的 $y$ 对应的位置，累加即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; auto fc(vector\u0026lt;int\u0026gt; \u0026amp;a){ sort(a.begin(), a.end()); vector\u0026lt;ll\u0026gt; dis; int r = 2e6+7; int id = 0; ll pre = 0, suf = accumulate(a.begin(), a.end(), 0LL); for(int i = -r; i \u0026lt;= r; i++){ ll sum = 0; while(id \u0026lt; a.size() \u0026amp;\u0026amp; a[id] \u0026lt; i){ pre += a[id]; suf -= a[id]; ++id; } sum = 1LL * id * i - pre + suf - 1LL * (a.size() - id) * i; dis.push_back(sum); } sort(dis.begin(), dis.end()); return dis; } void solve(){ int n, d; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; vector\u0026lt;int\u0026gt; x(n), y(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; auto dx = fc(x); auto dy = fc(y); ll ans = 0; int id = dx.size(); for(auto i : dx){ while(id \u0026gt; 0 \u0026amp;\u0026amp; dy[id-1] + i \u0026gt; d) --id; ans += id; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } F - Maximum Composition 函数之间，选择的偏序（顺序）问题。这个偏序怎么定义呢？函数 $f_i, f_j$，如果 $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$，则有 $a_i(a_jx + b_j) + b_i \\geq a_j(a_ix + b_i) + b_j$，我们把 $i, j$ 分离在一左一右，得到 $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$。\n如果 $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$，则 $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$，那么排序顺序已经清晰\n要使 $ans$ 最大，不光要找到偏序顺序，还要找到用哪 k 个函数，那就转化为了 01背包 问题\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; struct Node { int a, b; bool operator \u0026lt; (const Node \u0026amp;t) const { return (a - 1) * t.b \u0026lt; (t.a - 1) * b; } }; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;Node\u0026gt; l(n + 1); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i].a \u0026gt;\u0026gt; l[i].b; sort(l.begin()+1,l.end()); vector\u0026lt;ll\u0026gt; dp(k + 1, 0); dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = k; j \u0026gt;= 1; j--) { dp[j] = max(dp[j - 1] * l[i].a + l[i].b, dp[j]); } } cout \u0026lt;\u0026lt; dp[k] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/abc366/","summary":"AtCoder Beginner Contest 366 补题 A - Election 2 判断当前是否有值大于 $n/2$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,t,a; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t\u0026gt;\u0026gt;a; if(n==1\u0026amp;\u0026amp;t==0\u0026amp;\u0026amp;a==0){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else if(t\u0026gt;n/2||a\u0026gt;n/2){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B - Vertical Writing 翻转字符串，同时对翻转后的每行从末尾开始清 * 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,mx=0; cin\u0026gt;\u0026gt;n; string s[N]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; mx=max(mx,(int)s[i].length()); } string ans[mx+1]; for(int i=0;i\u0026lt;mx;i++){","title":"ABC366"},{"content":"2024 杭电多校 4 补题 多层血条 模拟, 只会最覆盖最上面的一层血量, 所以不用担心下层血量是什么, 只用找到最上面的那一层是什么即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string h=\u0026#34;ABCDE\u0026#34;; void solve(){ int n,m,hp,dmg; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;hp\u0026gt;\u0026gt;dmg; int lst=(hp/m)%5,x=m; string upp; upp.resize(m+1,\u0026#39; \u0026#39;); if(hp\u0026lt;=m){ for(int i=1;i\u0026lt;=hp;i++)upp[i]=h[0],x=i; } else{ int rest=hp%m; // cout\u0026lt;\u0026lt;rest\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;i++){ if(rest)upp[i]=h[lst],x=i,rest--; else upp[i]=h[(lst-1+5)%5]; } } while(dmg){ if(upp[x]==\u0026#39;.\u0026#39;)break; upp[x]=\u0026#39;.\u0026#39;; x--; dmg--; if(x==0)x=m; } for(int i=0;i\u0026lt;=n+1;i++){ for(int j=0;j\u0026lt;=m+1;j++){ if((i==0\u0026amp;\u0026amp;j==0)||(i==0\u0026amp;\u0026amp;j==m+1)||(i==n+1\u0026amp;\u0026amp;j==0)||(i==n+1\u0026amp;\u0026amp;j==m+1))cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; else if(i==0||i==n+1)cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; else if(j==0||j==m+1)cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;; else cout\u0026lt;\u0026lt;upp[j]; } cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 昵称检索 昵称分姓名和生日两部分, 而姓名需在生日前, 那么就要找尽量前的姓名, 尽量后的生日\n预处理 nxt[i][j] 表示 s[i][n] 中字符 j 最靠左的出现位置, 从左到右找到名字的最后一位在哪, 记为 a[i], 同理,倒着求生日的最后一位在哪, 记为 b[i]\n最后找有多少对 (i, j) 满足 i \u0026lt; j 即可.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e6+7, mod=1e9+7; int n,m,ans[N]; int day[15] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string s,a; int vis[26],mp[N][26]; int fd(int *u){ int x=m+1; for(int i=3;~i;i--){ x--; if(x\u0026lt;1)return 0; x=mp[x][u[i]]; } return x; } int fc(){ int x=0; for(int i=0;i\u0026lt;a.size();i++){ x++; if(x\u0026gt;m)return m+1; x=mp[x][a[i]-\u0026#39;a\u0026#39;]; } return x; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;10;i++)vis[i]=0; for(int i=1;i\u0026lt;=m;i++){ if(s[i-1]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;9\u0026#39;)vis[s[i-1]-\u0026#39;0\u0026#39;]=i; for(int j=0;j\u0026lt;=9;j++)mp[i][j]=vis[j]; } for(int i=0;i\u0026lt;=m+1;i++)ans[i]=0; for(int i=1;i\u0026lt;=12;i++){ for(int j=1;j\u0026lt;=day[i];j++){ int p[4]; p[0]=i/10,p[1]=i%10,p[2]=j/10,p[3]=j%10; int x=fd(p); if(x)ans[x]++; } } for(int i=m;i\u0026gt;1;i--)ans[i-1]+=ans[i]; for(int j=0;j\u0026lt;26;j++)vis[j]=m+1; for(int i=m;i;i--){ if(s[i-1]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;z\u0026#39;)vis[s[i-1]-\u0026#39;a\u0026#39;]=i; for(int j=0;j\u0026lt;26;j++)mp[i][j]=vis[j]; } int sum=0; while(n--){ cin\u0026gt;\u0026gt;a; int x=fc(); if(x\u0026lt;m)sum+=ans[x+1]; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 最优 k 子段 前缀和统计区间和, 用二分找答案\n开一个 set 存当前前缀和和位置, 判断合法区间条件为, 当前位置能否和 set 中所存的元素构成大于等于 lim 的一个片段, 同时片段长度要为质数, 如果能找到, 就将当前记录个数 + 1.\n二分条件即为 check 返回的值是否大于等于 k, 需要注意 k * 2 \u0026lt;= n, 因为最小的质数为 2, k * 2 是 n 的最小长度\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e8+7, mod=1e9+7; bool ip[N]; int n,k; ll a[N]; int check(int lim){ set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; s; s.insert({0,0}); int res=0; for(int i=1;i\u0026lt;=n;i++){ auto it = s.begin(); while(it != s.end()){ if(a[i] - it-\u0026gt;first \u0026lt; lim) it = s.end(); else if(ip[i - it-\u0026gt;second]) break; else it++; } if(it != s.end()) res++, s.clear(); s.insert({a[i], i}); } return res; } void solve(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i=1; i\u0026lt;=n; i++){ cin \u0026gt;\u0026gt; a[i]; a[i]+=a[i-1]; } if(2*k \u0026gt; n){ cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; return; } int l = -2000, r = N; while(l \u0026lt; r){ ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; if(check(mid) \u0026gt;= k) l = mid; else r = mid - 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(ip, 1, sizeof(ip)); ip[0] = ip[1] = 0; for(int i=2; i*i\u0026lt;=N; i++){ if(ip[i]){ for(int j=i*i; j\u0026lt;=N; j+=i) ip[j]=0; } } int t; cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024hdu4/","summary":"2024 杭电多校 4 补题 多层血条 模拟, 只会最覆盖最上面的一层血量, 所以不用担心下层血量是什么, 只用找到最上面的那一层是什么即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string h=\u0026#34;ABCDE\u0026#34;; void solve(){ int n,m,hp,dmg; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;hp\u0026gt;\u0026gt;dmg; int lst=(hp/m)%5,x=m; string upp; upp.resize(m+1,\u0026#39; \u0026#39;); if(hp\u0026lt;=m){ for(int i=1;i\u0026lt;=hp;i++)upp[i]=h[0],x=i; } else{ int rest=hp%m; // cout\u0026lt;\u0026lt;rest\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;i++){ if(rest)upp[i]=h[lst],x=i,rest--; else upp[i]=h[(lst-1+5)%5]; } } while(dmg){ if(upp[x]==\u0026#39;.\u0026#39;)break; upp[x]=\u0026#39;.\u0026#39;; x--; dmg--; if(x==0)x=m; } for(int i=0;i\u0026lt;=n+1;i++){ for(int j=0;j\u0026lt;=m+1;j++){ if((i==0\u0026amp;\u0026amp;j==0)||(i==0\u0026amp;\u0026amp;j==m+1)||(i==n+1\u0026amp;\u0026amp;j==0)||(i==n+1\u0026amp;\u0026amp;j==m+1))cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; else if(i==0||i==n+1)cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; else if(j==0||j==m+1)cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;; else cout\u0026lt;\u0026lt;upp[j]; } cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 昵称检索 昵称分姓名和生日两部分,","title":"2024HDU4"},{"content":"2024 萌新联赛 4 D 简单的素数 遍历 1 ~ $\\sqrt n$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8+10; void solve(){ int n,flag=0; cin\u0026gt;\u0026gt;n; for(int i=2;i*i\u0026lt;=n;i++){ if(n%i==0){ flag=1; break; } } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } F 小雷的算式 按题意模拟\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; #define int long long void solve(){ string s; cin\u0026gt;\u0026gt;s; int ans=0,tmp=0; vector\u0026lt;int\u0026gt;a; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;+\u0026#39;){ a.push_back(tmp); ans+=tmp,tmp=0; } else{ tmp*=10; tmp+=(s[i]-\u0026#39;0\u0026#39;); } } a.push_back(tmp); ans+=tmp; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;()); cout\u0026lt;\u0026lt;a[0]; for(int i=1;i\u0026lt;a.size();i++){ cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;a[i]; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H 聪明且狡猾的恶魔 1 号恶魔为了保证自己能获胜，会给（n / 2）个恶魔一人一个金币，保证自己能获胜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,x; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;n; int ans=x; if(n\u0026amp;1)ans-=n/2; else ans-=n/2-1; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B 小雷的神奇电脑 经验证，可得答案会在排序后相邻的两个元素中得出\n同或结果即为：所有位都为 1 的值减去二者的异或\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int a[n+100]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int u[32],cnt=1; u[0]=1; for(int i=1;i\u0026lt;32;i++){ cnt*=2; u[i]=u[i-1]+cnt; } sort(a+1,a+1+n); int ans=2e9; for(int i=1;i\u0026lt;n;i++){ ans=min(ans,a[i]^a[i+1]); } cout\u0026lt;\u0026lt;u[m-1]-ans\u0026lt;\u0026lt;endl; } C 岗位分配 志愿者无差别，意思是分配到岗位上的是谁不重要，重要的是人数\n先固定每个岗位该有的人，再对剩下的人分析\n剩下的人每个人都有 (n + 1) 种选择，那么我们的目标就是将他们分为 (n + 1) 组，即用 n 个隔板分开他们\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7, mod = 998244353; ll pre[N]; void init(){ pre[0] = 1; for(int i = 1; i \u0026lt; N; i++){ pre[i] = (pre[i-1] * i) % mod; } } ll rmod(ll a, ll m) { ll res = 1, y = m - 2; while (y \u0026gt; 0) { if (y % 2 == 1) res = (res * a) % m; a = (a * a) % m; y /= 2; } return res; } ll com(ll n, ll k) { if (k \u0026gt; n) return 0; return pre[n] * rmod(pre[k], mod) % mod * rmod(pre[n - k], mod) % mod; } ll mod_exp(ll base, ll exp, ll m) { ll res = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) res = (res * base) % m; base = (base * base) % m; exp /= 2; } return res; } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); ll ans = 1; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; m-=a[i]; } ans = (ans * com(m+n, m)) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; init(); // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } I 马拉松 x -\u0026gt; y 中间的点都忽略，找两侧各有几个点，相乘即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 3e5+7; int n,x,y; int s[N],vis[N]; vector\u0026lt;int\u0026gt;v[N]; bool onxy[N]; int dfs(int x){ vis[x]=1; s[x]=1; if(x==y)onxy[x]=1; for(auto i:v[x]){ if(!vis[i]){ s[x]+=dfs(i); onxy[x]|=onxy[i]; } } return s[x]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(x); int lx; for(auto i:v[x]){ if(onxy[i]==1){ lx=s[x]-s[i]; } } cout\u0026lt;\u0026lt;1LL*lx*s[y]\u0026lt;\u0026lt;endl; } J 尖塔第四强的高手 LCA 板，小于 1e5 的 fibonacci 数只有 24 个，提前找到，再根据题意，对所有的点依次跑 LCA 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; vector\u0026lt;int\u0026gt; v[N]; int d[N], f[N][32]; vector\u0026lt;int\u0026gt; a; void dfs(int x, int y) { d[x] = d[y] + 1; f[x][0] = y; for (int i = 1; i \u0026lt;= 31; i++) { f[x][i] = f[f[x][i-1]][i-1]; } for (int i = 0; i \u0026lt; v[x].size(); i++) { if (d[v[x][i]] == 0) dfs(v[x][i], x); } } int lca(int x, int y) { if (d[x] \u0026lt; d[y]) swap(x, y); for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; d[f[x][i]] \u0026gt;= d[y]) x = f[x][i]; } if (x == y) return x; for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; f[y][i] != 0 \u0026amp;\u0026amp; f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } return f[x][0]; } void solve() { int f1 = 1, f2 = 1; a.push_back(f1); a.push_back(f2); while (true) { int nxt = f1 + f2; if (nxt \u0026gt; N) break; a.push_back(nxt); f1 = f2; f2 = nxt; } int n, r, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; n; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; v[x].push_back(y); v[y].push_back(x); } dfs(r, 0); while (q--) { int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; tmp; for (int i = k; i \u0026lt; a.size(); i++) { if (x + a[i] \u0026gt; n) break; tmp.push_back(x + a[i]); } int ans=0; if(tmp.size()){ ans = tmp[0]; for (int i = 1; i \u0026lt; tmp.size(); i++) { ans = lca(ans, tmp[i]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E AND 质数只有一个偶数 2，如果没有 2，就不可能有符合的区间，因为最后一位一定为 1\n在有 2 的时候，因为必须选 2，同时 2 3 这个区间也不符合，符合条件的就有 r - l + 1 - 2 个，如果只有 2，要记得特判\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8 + 10; vector\u0026lt;int\u0026gt; prime; bool isnp[N]; void pre(int n) { fill(isnp, isnp + n + 1, false); for (int i = 2; i \u0026lt;= n; i++) { if (!isnp[i]) prime.push_back(i); for (auto j : prime) { if (j * i \u0026gt; n) break; isnp[j * i] = true; if (i % j == 0) break; } } } void solve() { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; auto l = lower_bound(prime.begin(), prime.end(), x)-prime.begin(); auto r = upper_bound(prime.begin(), prime.end(), y)-prime.begin(); cout \u0026lt;\u0026lt; (r - l) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (x == 2 \u0026amp;\u0026amp; x == y || x \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; else { cout \u0026lt;\u0026lt; (r - l - 2) \u0026lt;\u0026lt; endl; } } int main() { pre(N); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } K 比赛 用线段树，记录每个数字出现的次数，再从左到右，从右到左，各查询一遍，记录左右两次比 a[i] 大的小的相等的有几个，最后得到答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long lll; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) const int N = 1e5 + 7, mod = 1e9 + 7; int n, a[N], tr[N \u0026lt;\u0026lt; 2], ll[N], lu[N], rl[N], ru[N], le[N], re[N]; void update(int now, int l, int r, int pos, int val) { if (l == r) { tr[now] += val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(ls, l, mid, pos, val); else update(rs, mid + 1, r, pos, val); tr[now] = tr[ls] + tr[rs]; } int query(int now, int l, int r, int s, int t) { if (s \u0026gt; r || t \u0026lt; l) return 0; if (s \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) return tr[now]; int mid = (l + r) \u0026gt;\u0026gt; 1; return query(ls, l, mid, s, t) + query(rs, mid + 1, r, s, t); } void solve() { lll ans = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; memset(tr, 0, sizeof(tr)); for (int i = 1; i \u0026lt;= n; i++) { ll[i] = query(1, 1, N, 1, a[i]); lu[i] = query(1, 1, N, a[i], N); le[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); } memset(tr, 0, sizeof(tr)); for (int i = n; i \u0026gt; 0; i--) { rl[i] = query(1, 1, N, 1, a[i]); ru[i] = query(1, 1, N, a[i], N); re[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); ans += 1LL * rl[i] * lu[i]; ans += 1LL * ru[i] * ll[i]; ans -= 1LL * re[i] * le[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B4/","summary":"2024 萌新联赛 4 D 简单的素数 遍历 1 ~ $\\sqrt n$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8+10; void solve(){ int n,flag=0; cin\u0026gt;\u0026gt;n; for(int i=2;i*i\u0026lt;=n;i++){ if(n%i==0){ flag=1; break; } } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } F 小雷的算式 按题意模拟 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; #define int long long void solve(){ string s; cin\u0026gt;\u0026gt;s; int ans=0,tmp=0; vector\u0026lt;int\u0026gt;a; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;+\u0026#39;){ a.push_back(tmp); ans+=tmp,tmp=0; } else{ tmp*=10; tmp+=(s[i]-\u0026#39;0\u0026#39;); } } a.push_back(tmp); ans+=tmp; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;()); cout\u0026lt;\u0026lt;a[0]; for(int i=1;i\u0026lt;a.size();i++){ cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;a[i]; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H 聪明且狡猾的恶魔 1 号恶","title":"2024萌新联赛4"},{"content":"LCA(最近公共祖先) 简介 两个节点的最近公共祖先，就是两个点的公共祖先里，离根最远的那个\nLCA({u}) = u u 是 v 的祖先，当且仅当 LCA({u, v}) = u 如果 u, v 互不为祖先，那么二者存在 LCA({u, v}) 的两颗不同子树中 前序遍历中，$\\text{LCA}(S)$ 出现在所有 S 中元素之前，后序遍历中 $\\text{LCA}(S)$ 则出现在所有 S 中元素之后 两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\\text{LCA}(A\\cup B)=\\text{LCA}(\\text{LCA}(A), \\text{LCA}(B))$ 两点的最近公共祖先必定处在树上两点间的最短路上 $d(u,v)=h(u)+h(v)-2h(\\text{LCA}(u,v))$，其中 d 是树上两点间的距离，h 代表某点到树根的距离 求法 朴素算法 每次都找深度较大的点，令其向上搜索，显然两个点最后会相遇，相遇位置即为 LCA，或者先调整深度较大的点，使二者深度相同后，一起向上跳转，最后也会相遇\n需要先 dfs 预处理整棵树，此过程为 O(n), 查询过程也为 O(n)\n倍增算法 简介 是朴素算法的改进版本，预处理 fa[x][i] 数组，使游标可以快速移动，减少跳转次数。\nfa[x][i] 表示的是点 x 的第 $2^i$ 个祖先。可以通过 dfs 预处理得到\n优化跳转的过程：首先，我们要将 u, v 跳转到同一深度，计算得出二者深度之差为 y，将 y 用二进制拆分，将 y 次游标跳转优化为 y 的二进制中 1 的个数次跳转。接着从最大的 i 开始循环尝试，一直到 0，如果 fa[u][i] != fa[v][i]，那么最后的 LCA 为 fa[u][0]\n预处理的时间复杂度是 O(nlogn), 查询的时间复杂度是 O(logn)\n模板 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 6e5+7; int n,m,s; vector\u0026lt;int\u0026gt;v[N]; int d[N],f[N][32]; void dfs(int x,int y){ d[x]=d[y]+1; f[x][0]=y; for(int i=1;i\u0026lt;=31;i++){ f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i\u0026lt;v[x].size();i++){ if(d[v[x][i]]==0)dfs(v[x][i],x); } } int lca(int x,int y){ if(d[x]\u0026lt;d[y])swap(x,y); for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;d[f[x][i]]\u0026gt;=d[y]) x=f[x][i]; } if(x==y)return x; for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;f[y][i]!=0\u0026amp;\u0026amp;f[x][i]!=f[y][i]){ x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;lca(x,y)\u0026lt;\u0026lt;endl; } } 例题 HDU 2586 树上最短路查询\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 40005; vector\u0026lt;int\u0026gt;v[N],w[N]; int fa[N][31],cost[N][31],dep[N]; int n,m,a,b,c; void dfs(int now,int fno){ fa[now][0]=fno; dep[now]=dep[fa[now][0]]+1; for(int i=1;i\u0026lt;31;i++){ fa[now][i]=fa[fa[now][i-1]][i-1]; cost[now][i]=cost[fa[now][i-1]][i-1]+cost[now][i-1]; } int sz=v[now].size(); for(int i=0;i\u0026lt;sz;i++){ if(v[now][i]==fno)continue; cost[v[now][i]][0]=w[now][i]; dfs(v[now][i],now); } } int lca(int x,int y){ if(dep[x]\u0026gt;dep[y])swap(x,y); int tmp=dep[y]-dep[x],ans=0; for(int j=0;tmp;++j,tmp\u0026gt;\u0026gt;=1){ if(tmp\u0026amp;1)ans+=cost[y][j],y=fa[y][j]; } if(y==x)return ans; for(int j=30;j\u0026gt;=0\u0026amp;\u0026amp;y!=x;j--){ if(fa[x][j]!=fa[y][j]){ ans+=cost[x][j]+cost[y][j]; x=fa[x][j]; y=fa[y][j]; } } ans+=cost[x][0]+cost[y][0]; return ans; } void solve(){ memset(fa,0,sizeof(fa)); memset(cost,0,sizeof(cost)); memset(dep,0,sizeof(dep)); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ v[i].clear(); w[i].clear(); } for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; v[a].push_back(b); v[b].push_back(a); w[a].push_back(c); w[b].push_back(c); } dfs(1,0); for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;lca(a,b)\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } Tarjan 算法 简介 是离线算法，需要使用并查集记录某个结点的祖先结点\n首先接受输入边(领接链表)，查询边(另一个链表中)。查询边其实是虚拟加的边，每次输入查询边的时候，都将此边和其反向边加入到 queryedge 数组里 然后对其进行 DFS 遍历，同时使用 vis 数组记录结点是否被访问，parent 记录当前结点的父亲结点 每次遍历到某个结点的时候，认为这个结点的根节点就是他本身，。让以这个结点为根节点的 DFS 全遍历完以后，再将这个结点的根节点设置为这个结点的父一级结点 回溯的时候，如果以该节点为起点，queryedge 查询边的另一个结点也恰好访问过了，直接更新查询边的 LCA 结果 输出结果 Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$。\n朴素的 Tarjan 算法处理所有 m 次询问的时间复杂度为 $O(m \\alpha(m+n, n) + n)$\n模板 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Edge { public: int toVertex, fromVertex; int next; int LCA; Edge() : toVertex(-1), fromVertex(-1), next(-1), LCA(-1) {}; Edge(int u, int v, int n) : fromVertex(u), toVertex(v), next(n), LCA(-1) {}; }; const int MAX = 100; int head[MAX], queryHead[MAX]; Edge edge[MAX], queryEdge[MAX]; int parent[MAX], visited[MAX]; int vertexCount, queryCount; int find(int x) { if (parent[x] == x) { return x; } else { return parent[x] = find(parent[x]); } } void tarjan(int u) { parent[u] = u; visited[u] = 1; for (int i = head[u]; i != -1; i = edge[i].next) { Edge\u0026amp; e = edge[i]; if (!visited[e.toVertex]) { tarjan(e.toVertex); parent[e.toVertex] = u; } } for (int i = queryHead[u]; i != -1; i = queryEdge[i].next) { Edge\u0026amp; e = queryEdge[i]; if (visited[e.toVertex]) { queryEdge[i ^ 1].LCA = e.LCA = find(e.toVertex); } } } int main() { memset(head, 0xff, sizeof(head)); memset(queryHead, 0xff, sizeof(queryHead)); cin \u0026gt;\u0026gt; vertexCount \u0026gt;\u0026gt; queryCount; int count = 0; for (int i = 0; i \u0026lt; vertexCount - 1; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; edge[count] = Edge(start, end, head[start]); head[start] = count; count++; edge[count] = Edge(end, start, head[end]); head[end] = count; count++; } count = 0; for (int i = 0; i \u0026lt; queryCount; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; queryEdge[count] = Edge(start, end, queryHead[start]); queryHead[start] = count; count++; queryEdge[count] = Edge(end, start, queryHead[end]); queryHead[end] = count; count++; } tarjan(1); for (int i = 0; i \u0026lt; queryCount; i++) { Edge\u0026amp; e = queryEdge[i * 2]; cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; e.fromVertex \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; e.toVertex \u0026lt;\u0026lt; \u0026#34;) \u0026#34; \u0026lt;\u0026lt; e.LCA \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/lca/","summary":"LCA(最近公共祖先) 简介 两个节点的最近公共祖先，就是两个点的公共祖先里，离根最远的那个 LCA({u}) = u u 是 v 的祖先，当且仅当 LCA({u, v}) = u 如果 u, v 互不为祖先，那么二者存在 LCA({u, v}) 的两颗不同子树中 前序遍历中，$\\text{LCA}(S)$ 出现在所有 S 中元素之前，后序遍历中 $\\text{LCA}(S)$ 则出现在所有 S 中元素之后 两","title":"LCA"},{"content":"线段数学习 简介 常用的用来维护 区间信息 的数据结构。\n线段树可以在 $O(\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n实现过程即为将每个长度不为 1 的片段分成左右两个片段，不断递归下去，把区间分为树形结构，通过合并两端来求值\n模板 单点修改 操作 1 单点修改\n操作 2 查询区间最小值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv; }tr[N\u0026lt;\u0026lt;2]; void update(int now){ tr[now].minv=min(tr[ls].minv,tr[rs].minv); } void build(int now,int l,int r){ if(l==r){ tr[now].minv=a[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now].minv=val; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } int query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now].minv; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return min(query(ls,l,r,s,mid),query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n)\u0026lt;\u0026lt;endl; } return 0; } 区间合并 不光记录最小值，同时记录最小值出现次数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv,cnt; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.minv=min(l.minv,r.minv); if(l.minv==r.minv)a.cnt=l.cnt+r.cnt; else if(l.minv\u0026lt;r.minv)a.cnt=l.cnt; else a.cnt=r.cnt; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],1}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,1};; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).minv\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;query(1,x,y,1,n).cnt\u0026lt;\u0026lt;endl; } return 0; } 最大子段和 数组片段中有正有负，需要统计的数据变多，合并时可能涉及到左右片段相接部分\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int mss,mpre,msuf,s; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.mss=max({l.mss,r.mss,l.msuf+r.mpre}); a.mpre=max(l.mpre,l.s+r.mpre); a.msuf=max(r.msuf,r.s+l.msuf); a.s=l.s+r.s; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],a[l],a[l],a[l]}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,val,val,val}; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).mss\u0026lt;\u0026lt;endl; } return 0; } 懒惰标记 对片段修改，用懒惰标记标记当前段，之后再取到时，将标记传到子段\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { cin \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 懒惰标记 2 不光有区间加，还有区间乘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n, mod, q; int a[N]; struct Tag { int mul, add; }; struct Node { int len, sum; Tag tag; } tr[N\u0026lt;\u0026lt;2]; Tag operator + (const Tag \u0026amp;a, const Tag \u0026amp;b) { return {a.mul * b.mul % mod, (a.add * b.mul + b.add) % mod}; } Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = (l.sum + r.sum) % mod; a.tag = {1, 0}; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, Tag t) { tr[now].tag = tr[now].tag + t; tr[now].sum = (tr[now].sum * t.mul + tr[now].len * t.add) % mod; } void pushdown(int now) { if (tr[now].tag.mul != 1 || tr[now].tag.add) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = {1, 0}; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], {1, 0}}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, Tag val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans = (ans + query(ls, l, r, s, mid)) % mod; if (r \u0026gt; mid) ans = (ans + query(rs, l, r, mid + 1, t)) % mod; return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (q--) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; Tag z = {1, 0}; if (op == 1) { cin \u0026gt;\u0026gt; z.mul; modify(1, x, y, 1, n, z); } else if (op == 2) { cin \u0026gt;\u0026gt; z.add; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 线段树上二分 重点改的是查询部分\n找到区间中第一个大于等于 d 的位置\n但是 l == s, r == t 时不返回，继续递归\n时间复杂度仍然是 O(logn)\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 int n, m; int a[N]; struct Node { int mx; } tr[N \u0026lt;\u0026lt; 2]; Node operator+(const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.mx = max(l.mx, r.mx); return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void build(int now, int l, int r) { if (l == r) { tr[now] = {a[l]}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void change(int now, int s, int t, int pos, int val) { if (s == t) { tr[now] = {val}; return; } int mid = (s + t) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) change(ls, s, mid, pos, val); if (pos \u0026gt; mid) change(rs, mid + 1, t, pos, val); update(now); } int search(int now, int l, int r, int s, int t, int d) { if (l == s \u0026amp;\u0026amp; r == t) { if (tr[now].mx \u0026lt; d) return -1; if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; if (tr[ls].mx \u0026gt;= d) return search(ls, l, mid, s, mid, d); return search(rs, mid + 1, r, mid + 1, t, d); } int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) return search(ls, l, r, s, mid, d); if (r \u0026gt; mid) return search(rs, l, r, mid + 1, t, d); int pos = search(ls, l, mid, s, mid, d); if (pos != -1) return pos; return search(rs, mid + 1, r, mid + 1, t, d); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, d; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { change(1, 1, n, x, y); } else { cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; search(1, x, y, 1, n, d) \u0026lt;\u0026lt; endl; } } return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E7%BA%BF%E6%AE%B5%E6%A0%91/","summary":"线段数学习 简介 常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 实现过程即为将每个长度不为 1 的片段分成左右两个片段，不断递归下去，把区间分为树形结构，通过合并两端来求值 模板 单点修改 操作 1","title":"线段树"},{"content":"2024 河南萌新联赛 3 B 正则表达式 签到，四个数字都在 [1,255] 之间即为合法\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s) { int n = s.size(); int num = 0, dots = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;.\u0026#39;) { if (num \u0026lt; 0 || num \u0026gt; 255) return false; num = 0; } else if (isdigit(s[i])) { num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) return false; } else { return false; } } if (num \u0026lt; 0 || num \u0026gt; 255) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; int cnt = 0; for(int i=1;i\u0026lt;=n;i++) { string s; cin \u0026gt;\u0026gt; s; if (check(s)) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C Circle 找规律，手模两遍发现 n = 1，时为 2，其他情况都是每次增加 (2 * (n - 1)) 个圆，化简关系式得 S(n) = n ^ 2 - n + 2\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n==0) cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;; else cout\u0026lt;\u0026lt;1LL*n*n-n+2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } J keillempkill学姐の卷积 按题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define int long long int n,m; int a[25][25],b[25][25],c[25][25]; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++)cin\u0026gt;\u0026gt;a[i][j]; } for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;m;j++)cin\u0026gt;\u0026gt;b[i][j]; } for(int i=0;i\u0026lt;m-n+1;i++){ for(int j=0;j\u0026lt;m-n+1;j++){ int now=0; for(int x=i;x\u0026lt;n+i;x++){ for(int y=j;y\u0026lt;n+j;y++) now+=(a[x-i][y-j]*b[x][y]); } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } L SSH 大 STL\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int q, n, m; unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; ips, keys; unordered_map\u0026lt;string, string\u0026gt; p2p; int main() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= m; i++) { string pub, pri; cin \u0026gt;\u0026gt; pub \u0026gt;\u0026gt; pri; p2p[pri] = pub; } for (int i = 1; i \u0026lt;= n; i++) { string ip; int k; cin \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; k; for (int j = 1; j \u0026lt;= k; j++) { string user, pub; int t; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; t; ips[ip].push_back(user); for (int l = 1; l \u0026lt;= t; l++) { cin \u0026gt;\u0026gt; pub; keys[user].push_back(pub); } } } while (q--) { string user, ip, pri; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; pri; if (find(ips[ip].begin(), ips[ip].end(), user) != ips[ip].end() \u0026amp;\u0026amp; find(keys[user].begin(), keys[user].end(), p2p[pri]) != keys[user].end()) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } } } F 累加器 正解是暴力跑一遍，记录从 1 到 i 的改变次数，询问时用 pre[r] - pre[l] 即可\n赛时 eng 在找规律了，可以发现从第 0 位开始，每次改变次数都 /2，如果遇到前一位原来为 1 现在为 0 的，就将现在记录的 now + 1，最后也可得出答案\n赛时代码\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int x,y,xx[32],yy[32]; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int t=x+y; for(int i=31;i\u0026gt;=0;i--){ if((x\u0026gt;\u0026gt;i)\u0026amp;1)xx[i]=1; else xx[i]=0; if((t\u0026gt;\u0026gt;i)\u0026amp;1)yy[i]=1; else yy[i]=0; } int now=y,ans=y; for(int i=1;i\u0026lt;32;i++){ if(xx[i-1]==1\u0026amp;\u0026amp;yy[i-1]==0)now++; ans+=(now/2); // cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; now/=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } I 游戏 两次最短路，一次只可以走通路的，另一次先拿钥匙，再走到终点，比较两次哪个短哪个是答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; #define int long long struct Node { int y, w; }; vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; edge(N), edges(N); int n, m, k, dist[N]; int a, b, c, d; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int dijkstra(int s, int t, vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; \u0026amp;edge) { q.clear(); fill(dist, dist + N, LLONG_MAX); dist[s] = 0; q.insert({dist[s], s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto \u0026amp;i : edge[x]) { if (dist[x] + i.w \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.w; q.insert({dist[i.y], i.y}); } } } return dist[t]; } signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (d == 1) { edge[a].push_back({b, c}); edge[b].push_back({a, c}); } edges[a].push_back({b, c}); edges[b].push_back({a, c}); } int ans = LLONG_MAX, fk = -1; fk = dijkstra(1, k, edge); if (fk != LLONG_MAX) { ans = min(dijkstra(1, n, edge), dijkstra(k, n, edges) + fk); } else { ans = dijkstra(1, n, edge); } if (ans == LLONG_MAX) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } K 暴食之史莱姆 对于一个史莱姆，他在左侧能吃掉的数量，即为左侧第一个比他小的史莱姆能吃的数量，右侧同理。所以他能吃的数量即为左侧能吃的数量加上右侧能吃的数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; int n,a[N],f[N]; deque\u0026lt;int\u0026gt;q; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i]) q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } q.clear(); for(int i=n;i\u0026gt;0;i--){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i])q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;f[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E 区间 线段树\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5+10; int a[N]; struct Node{ int l,r,mx,len; }tr[N\u0026lt;\u0026lt;2]; void build(int now,int l,int r){ tr[now]=Node{r-l+1,r-l+1,r-l+1,r-l+1}; if(l==r)return; int mid=(l+r)\u0026gt;\u0026gt;1; build((now\u0026lt;\u0026lt;1),l,mid); build(((now\u0026lt;\u0026lt;1)|1),mid+1,r); } Node update(Node x,Node y){ if(x.len==0)return y; if(y.len==0)return x; Node ans; ans.len=x.len+y.len; int tmp=max(x.mx,y.mx); ans.mx=max(x.r+y.l,tmp); ans.l=x.l; ans.r=y.r; if(x.l==x.len)ans.l+=y.l; if(y.r==y.len)ans.r+=x.r; return ans; } void change(int now,int l,int r,int x){ if(l==r){ a[l]^=1; tr[now].l=tr[now].r=tr[now].mx=a[l]^1; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(x\u0026lt;=mid)change((now\u0026lt;\u0026lt;1),l,mid,x); else change(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x); tr[now]=update(tr[(now\u0026lt;\u0026lt;1)],tr[((now\u0026lt;\u0026lt;1)|1)]); } Node query(int now,int l,int r,int x,int y){ if(l\u0026gt;=x\u0026amp;\u0026amp;r\u0026lt;=y)return tr[now]; int mid=(l+r)\u0026gt;\u0026gt;1; Node ans={0,0,0,0}; if(x\u0026lt;=mid)ans=query((now\u0026lt;\u0026lt;1),l,mid,x,y); if(y\u0026gt;mid)ans=update(ans,query(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x,y)); return ans; } int main(){ int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; build(1,1,n); while(q--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x; if(op==1)change(1,1,n,x); else { cin\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;query(1,1,n,x,y).mx\u0026lt;\u0026lt;endl; } } } H 魔法 用 dp[x][y][k], 记录在 (x, y) 处使用 k 次魔法，最小的权值之和\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int n,m,h; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;h; vector a(n + 1, vector(m + 1, 0)); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++)cin\u0026gt;\u0026gt;a[i][j]; vector dp(n + 1, vector(m + 1, vector(n + m, 1e16))); dp[1][1][0]=a[1][1],dp[1][1][1]=0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (i == 1 \u0026amp;\u0026amp; j == 1) continue; for (int k = 0; k \u0026lt; n + m; k++) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + a[i][j]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k] + a[i][j]); if (k) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1]); } } } } for(int i=0;i\u0026lt;n+m;i++){ if(dp[n][m][i]\u0026lt;h){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } } } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); } G 求值 易想到将 w 和前面的关系式分开看，答案即为关系式和 w 最接近时的答案，可以想到 A B C 三者的顺序其实无所谓，只和他们的大小有关系，假设关系式结果为 S，A \u0026lt; B \u0026lt; C, 那么 S 最小就是 A * n，最大就是 C * n，所以我们先固定从选 n 个 A 开始，每次循环中增加 1 个 B - A 的值，这样就在 O(n) 的时间中解决了 A B 的数量，再在每次循环中针对 C 进行选取，如果当前 (W - S) / (C - B) 的值大于 i 那么我们就选 i 个 C，否则就选 (W - S) / (C - B - A) 个 C 和 (W - S) / (C - B) + 1 的值进行比较，选最优的\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int aa[3],a,b,c,n,w; cin\u0026gt;\u0026gt;aa[0]\u0026gt;\u0026gt;aa[1]\u0026gt;\u0026gt;aa[2]\u0026gt;\u0026gt;n\u0026gt;\u0026gt;w; sort(aa,aa+3); a=aa[0],b=aa[1]-aa[0],c=aa[2]-aa[1]; int ans,res=w-a*n; ans=res; if(ans\u0026lt;=0){ cout\u0026lt;\u0026lt;-ans\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=n;i++){ res-=b; ans=min(ans,abs(res)); if(res\u0026lt;=0)break; if(c==0)continue; int t=res/c; if(t\u0026gt;i)ans=min(ans,res-c*i); else ans=min(ans,res-c*t); if(i\u0026gt;t)ans=min(ans,abs(res-c*(t+1))); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } G 开心消消乐 一个数异或他本身为 0，如果相邻的数相同，他们只需要消耗一次，不同的就增加消耗，特例是为 0，的不需要消耗\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,last=-1,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x!=last){ last=x; if(x!=0) ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B3/","summary":"2024 河南萌新联赛 3 B 正则表达式 签到，四个数字都在 [1,255] 之间即为合法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s) { int n = s.size(); int num = 0, dots = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;.\u0026#39;) { if (num \u0026lt; 0 || num \u0026gt; 255) return false; num = 0; } else if (isdigit(s[i])) { num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) return false; } else { return false; } } if (num \u0026lt; 0 || num \u0026gt; 255) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; int cnt = 0; for(int i=1;i\u0026lt;=n;i++) { string s; cin \u0026gt;\u0026gt; s; if (check(s))","title":"2024萌新联赛3"},{"content":"最小生成树基础算法学习 定义 我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。\n注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。\nKruskal 算法 简介 基本思想是从小到大加入边，是个贪心算法。\n将所有边的边权排序，从小到大加入生成树中，如果某次加入会生成环就舍弃此边，直到加入了 n - 1 条边，形成树。时间复杂度为 O(mlogm)\n实现 struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int find(int i){ if(fa[i]==i)return i; return fa[i]=find(fa[i]); } int Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=find(a[i].x),y=find(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } return cnt; } 例题 洛谷P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int findset(int i){ if(fa[i]==i)return i; return fa[i]=findset(fa[i]); } void Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=findset(a[i].x),y=findset(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } if(cnt==1) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;a[i].x\u0026gt;\u0026gt;a[i].y\u0026gt;\u0026gt;a[i].v; Kruskal(); return 0; } Prim 算法 简介 基本思想是从一个点开始，不断加点，而不是 Kruskal 的加边\n具体做法就是在当前图可连点上选择距离最近的一个点，将这个点加入图，继续找最近的点，直到所有的点都找到\n时间复杂度一般为 O(n^2)\n实现 struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } 例题 洛谷P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; edge[x].push_back(Node(y,z)); edge[y].push_back(Node(x,z)); } Prim(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","summary":"最小生成树基础算法学习 定义 我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。 注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。 Kruskal 算法 简介 基本思想是从小到大加入边，是个贪心算法。 将所有边的边权排序，从小到大加入生成树中，如果某次加入会","title":"最小生成树"},{"content":"最短路基础算法学习 特点汇总 最短路算法 Floyd Bellman–Ford Dijkstra Johnson 最短路类型 每对结点之间的最短路 单源最短路 单源最短路 每对结点之间的最短路 作用于 任意图 任意图 非负权图 任意图 能否检测负环？ 能 能 不能 能 时间复杂度 O(N^3) O(NM) O(MlogM) O(NMlogM) Floyd 算法 简介 用来求任意两个结点之间的最短路\n复杂度较高 O(n^3) 容易实现\n使用与任何图，不管有向无向，边权正负，但是最短路必须存在，不能存在负环(即边权之和为负数的环，可以无限次通过减少所求答案)\n实现 定义一个数组 f[k][x][y]，表示只允许经过点 1 到 k (包含点 1 到点 k 的子图，x y 不一定在子图中)，点 x 到点 y 的最短路长度\nf[n][x][y] 即为 x 到 y 的最短路长度\nf[0][x][y]: x 和 y 之间有联通路时为二者的边权，若无则为 $+\\infty $ 如果 x == y 则为 0\nf[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])（f[k-1][x][y]，为不经过 k 点的最短路径，而 f[k-1][x][k]+f[k-1][k][y]，为经过了 k 点的最短路）。\n可以发现第一维是无影响的，因此空间复杂度可以优化到 O(n^2)\nvoid floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } 例题 洛谷 B3647\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int f[110][110]; int inf = 1e9; void floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,w; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; if(!f[x][y])f[x][y]=f[y][x]=w; else f[x][y]=f[y][x]=min(f[x][y],w); } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ if(f[i][j])continue; if(i==j)f[i][j]=0; else f[i][j]=inf; } } floyd(); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++)cout\u0026lt;\u0026lt;f[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } Bellman-Ford 算法 简介 基于松驰操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断\nSPFA 是 Bellman-Ford 的一种实现\n松驰操作指的是 dis[v] = min(dis[v], dis[u] + w[u][v])\nBellman-Ford 算法做的就是不断尝试对图上每一条边进行松驰，每一轮循环都尝试对图上所有的边进行一次松驰操作，当一次循环中没有成功的松驰操作时，算法停止\n整个算法最多进行 n - 1 轮松驰操作，所以时间复杂度为 O(nm)\n如果从 s 点出发，抵达一个负环，松驰会无休止的进行下去，如果 n - 1 轮后还有能松驰的边，说明从 s 点出发，能够抵达一个负环\n如果以 s 点跑，没有找到负环，只能说明从 s 点无法到达负环，如果要判断图上是否有负环，需要建立一个超级源点 o 对图上每个点连一条权值为 0 的边，再以 o 为起点跑一遍 Bellman-Ford\n实现 struct Node{ int u,v,w; }; vector\u0026lt;Node\u0026gt;edge; int dis[10100],u,v,w; int n,m; const int INF = 1e9; bool bellmanford(int n,int s){ memset(dis,INF,sizeof(dis)); dis[s]=0; bool flag=false; for(int i=1;i\u0026lt;=n;i++){ flag=false; for(int j=0;j\u0026lt;edge.size();j++){ u=edge[j].u,v=edge[j].v,w=edge[j].w; if(dis[u]==INF)continue; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; flag=true; } } if(!flag)break; } return flag; } 队列优化 SPFA\n很显然，只有上次被松驰的点所连接的边，才可能进行下一次的松驰操作\n可以用队列来维护可能引起松驰操作的点\nSPFA 也可以用于判断 s 是否能抵达负环，只需记录最短路经过了多少条边即可，若经过了至少 n 条边，说明 s 可以抵达一个负环\nstruct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int dis[N],cnt[N],vis[N]; queue\u0026lt;int\u0026gt;q; bool spfa(int n,int s){ memset(dis,63,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto x:edge[u]){ int v=x.v,w=x.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n)return false; if(!vis[v])q.push(v),vis[v]=1; } } } return true; } 例题 洛谷 P3385\nBellman-Ford\nSPFA\nDijkstra 算法 简介 求解 非负权图 上单源最短路径\n将点分为两个集合，一个为已确定最短路径的点集 s，另一个为未确定最短路长度的点集 t，初始状态所有点都在 t 中\n初始化 dis[s] = 0, 其他点的 dis 均为 $+\\infty $\n然后重复下列操作：\n(1) 从 t 中取一个最短路长度最小的点，移到 s 中\n(2) 对刚加入 s 中的点进行所有出边的松驰操作\n直到 t 为空，算法结束\n暴力实现 时间复杂度为 O(n^2)\n堆优化 时间复杂度 O(mlogn)\n实现 暴力\nstruct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; //开一个结构体用于储存边的信息，y 代表这条边通向哪，v 代表这条边的边权 int n,m,u,v,w,s,t,dist[N]; bool vis[N]; vector\u0026lt;Node\u0026gt;edge[N];//edge 数组的下标就是边的起始点，Node 中的 y 代表这条边通向哪个点 void dijkstra(int s,int t){//s 指代起点，t 指代终点 memset(vis,0,sizeof(vis)); memset(dist,127,sizeof(dist)); //初始将所有点的最短路都设置为无穷大 dist[s]=0;//起点到自己的距离为 0 for(;;){ int x=-1;//x 是这一轮循环中找到的最短路径 for(int i=1;i\u0026lt;=n;i++){ if(!vis[i]\u0026amp;\u0026amp;dist[i]\u0026lt;(1\u0026lt;\u0026lt;30))//如果当前这个点没被更新过，并且到达它的最短路不是初始化的无穷大，我们就考虑他是不是当前的最优选择 if(x==-1||dist[i]\u0026lt;dist[x])x=i;//如果 x 还未被更新，或者到这个点的最短路比之前选的更短，我们就更新 x } if(x==t||x==-1)break;//如果 x 为终点，或遍历所有点后 x 还没更新，就终止算法 vis[x]=1;//标记当前这个 x 避免之后重复使用 for(auto i:edge[x]){//遍历以 x 这个点为起点的所有边 dist[i.y]=min(dist[i.y],dist[x]+i.v);//更新能到达的点的最短路 } } } 堆优化\nstruct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } 例题 洛谷P1339\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; edge[u].push_back(Node(v, c)); edge[v].push_back(Node(u, c)); } dijkstra(s, t); return 0; } Johnson 全源最短路径算法 实现 为了实现有负权图上的 Dijkstra，我们可以新建一个虚拟节点 o，从这个点向其他所有点连一条边权为 0 的边\n接下来用 Bellman-Ford 求出节点 o 到其他所有点的最短路，记为 h[i]\n假如存在一条从 u 到 v，边权为 w 的边，则将其边权重设为 w + h[u] - h[v]\n接下来以每个点为起点，跑 n 轮 Dijkstra 即可求出任意两点间的最短路了\n该算法时间复杂度是 O(nmlogm)\n","permalink":"https://KiritoXDone.github.io/posts/study/%E6%9C%80%E7%9F%AD%E8%B7%AF/","summary":"最短路基础算法学习 特点汇总 最短路算法 Floyd Bellman–Ford Dijkstra Johnson 最短路类型 每对结点之间的最短路 单源最短路 单源最短路 每对结点之间的最短路 作用于 任意图 任意图 非负权图 任意图 能否检测负环？ 能 能 不能 能 时间复杂度 O(N^3) O(NM) O(MlogM) O(NMlogM) Floyd 算法 简介 用来求任意两个结点之间的最短路 复杂度较高 O(n^3) 容易实现 使用与任何","title":"最短路"},{"content":"2024 河南萌新联赛 1 A 造数 给定整数 n，操作 1：+1，操作 2：+2，操作 3：x2，多少次将 0 转化到 n\n逆向思维，把 n 化为 0 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 n 的数组 a，两种操作选一个进行一次或不操作。\n显然将数组最大值 * n 后答案最大\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end()); int sum=0; for(int i=0;i\u0026lt;n;i++){ sum+=a[i]; } sum=max(sum+n,sum+(n-1)*a[n-1]); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } K 图上计数 构造的两块联通块即为最接近 n/2 的两块\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int n,m; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } if(n\u0026lt;=1){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return 0; } cout\u0026lt;\u0026lt;(long long)n/2*(n-n/2)\u0026lt;\u0026lt;endl; } I 除法移位 a 中最大值位于第一位时即是答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t; vector\u0026lt;int\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int mx=0,ans=0; for(int i=1;i\u0026lt;=min(t,n);i++){ if(a[n-i+1]\u0026gt;mx){ mx=a[n-i+1]; ans=i%n; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } F 两难抉择新编 与 H 类似，但是操作范围随 i 改变而改变 O(n^3/2) 暴力过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); int sum = 0, ans = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) sum ^= a[i]; ans = sum; for (int i = 1; i \u0026lt;= n; i++) { for (int x = 1; x \u0026lt;= n / i; x++) { int t1 = sum ^ a[i] ^ (a[i] + x); int t2 = sum ^ a[i] ^ (a[i] * x); ans = max(ans, max(t1, t2)); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } G 旅途的终点 反悔贪心，前 k 个直接存入 set，后续的小于 set 内第一个元素就替换，否则就正常进行\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll __int128 int main(){ long long n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;long long\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; multiset\u0026lt;ll\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ s.insert(a[i]); if(s.size()\u0026gt;k){ m-=*s.begin(); if(m\u0026lt;=0){ cout\u0026lt;\u0026lt;i-1\u0026lt;\u0026lt;endl; return 0; } s.erase(s.begin()); } } cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; return 0; } B 爱探险的朵拉 图中可能有环，那么就是要找包含环的最长链，或是无环的最长链\n记录每个点的入度，如果某个点的入度为 0，他们不会构成环，即可作为链起点，再依次对入度为 0 的点操作，找出他们能构成最长的链有多长。\n之后再以每个点为起点找答案，如果前面的过程标记过则跳过，没标记过说明这是环上点，用 dfs 找这个环加上前链有多长，并更新答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+10; int a[N],dis[N],cnt[N]; bool vis[N]; deque\u0026lt;int\u0026gt;q; int dfs(int x){ int sum=0,mx=0; for(int i=x;;i=a[i]){ if(vis[i])break; vis[i]=1; ++sum; mx=max(mx,dis[i]); } return mx+sum; } int main(){ int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; cnt[a[i]]++; } for(int i=1;i\u0026lt;=n;i++) if(!cnt[i])q.push_back(i); while(!q.empty()){ int x=q.front(); q.pop_front(); vis[x]=1; dis[a[x]]=max(dis[a[x]],dis[x]+1); --cnt[a[x]]; if(!cnt[a[x]])q.push_back(a[x]); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; int tmp=dfs(i); ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } C 有大家喜欢的零食吗 二分图匹配板子，之后学了补\nD 小蓝的二进制询问 显然是前缀和，那么重点就是如何计算前 x 个数的 1 的个数\n从最低位看起，只有 0，1，二者循环，再往上 1 位，仍然为 0，1 循环，显然每一位上的循环都是一样的，我们对每一位能出现的 1 进行计算，当前位数为 k 时，这一位上就会有 2^k 个 1 和 2^k 个 0.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 998244353; ll sum(ll x,int y){ if(x==0) return 0; ll s=1LL\u0026lt;\u0026lt;y; ll cnt=x/s; ll ans=cnt*s/2; ll d=cnt*s+(1LL\u0026lt;\u0026lt;(y-1)); ll dd=x-d+1; if(dd\u0026gt;0) ans+=dd; return ans; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ ll ans=0,l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; for(int i=61;i\u0026gt;0;i--){ ll p=(sum(r,i)%MOD-sum(l-1,i)%MOD+MOD)%MOD; ans=(ans+p)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } J 最大矩阵匹配 将矩阵上下翻转后，变为固定左上一个点，向其他三个方向拓展的问题，用二维前缀和辅助判断三个点是否都为 1，来实现 DP 状态转移\n","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B1/","summary":"2024 河南萌新联赛 1 A 造数 给定整数 n，操作 1：+1，操作 2：+2，操作 3：x2，多少次将 0 转化到 n 逆向思维，把 n 化为 0 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 n 的数组 a，两种操作选一个进行一次或不操作。 显然将数组最大值 * n 后答案最大 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i];","title":"2024萌新联赛1"},{"content":"Codeforces Round 962 还得练\nA Legs 先除 4 再除 2\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间他们不同的数量，更改差异数量除 2 (向上取整)，即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; int n, q; string a, b; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = \u0026#34; \u0026#34; + a; b = \u0026#34; \u0026#34; + b; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; va(26, vector\u0026lt;int\u0026gt;(n + 1, 0)), vb(26, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { va[x - \u0026#39;a\u0026#39;][i] = va[x - \u0026#39;a\u0026#39;][i - 1]; vb[x - \u0026#39;a\u0026#39;][i] = vb[x - \u0026#39;a\u0026#39;][i - 1]; } va[a[i] - \u0026#39;a\u0026#39;][i]++; vb[b[i] - \u0026#39;a\u0026#39;][i]++; } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; long long ans = 0; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { ans += abs((va[x - \u0026#39;a\u0026#39;][r] - va[x - \u0026#39;a\u0026#39;][l - 1]) - (vb[x - \u0026#39;a\u0026#39;][r] - vb[x - \u0026#39;a\u0026#39;][l - 1])); } if(ans\u0026amp;1)ans++; ans/=2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D Fun 给定两个整数 n 和 x ，求 ab + ac + bc ≤ n 和 a + b + c ≤ x 的个正整数的三元组 (a, b, c) 的个数。 注意顺序问题(例如 (1, 1, 2) 和 (1, 2, 1) 被视为不同)， a ， b ， c 必须严格大于 0 。\n赛时只顾着研究这两个式子能否融合化简为一个式子，还是见题少了\n看第一个式子可知，a * b \u0026lt;= n, 所以 b 有 nlogn 个选择，可以循环 ab 求解\n再通过两个式子推得 c \u0026lt;= (n - ab) / (a + b)和 c \u0026lt;= x - a - b ,将范围小的加入答案即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ ll n,x,ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ ll mn=min((n-i*j)/(i+j),(x-i-j)); mn=max(mn,0); ans+=mn; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E Decode 赛时题都没弄太明白 每次找到符合区间会使答案加 l * (n - r + 1)\n用前缀和记录当前位置 1 0 出现次数，1 指代此处为 1，-1 指代此处为 0。然后逐位记录当前前缀和的大小，如果之前存过，那么就更新答案。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 1e9 + 7; void solve(){ string s; cin\u0026gt;\u0026gt;s; int n=s.size(); s=\u0026#34; \u0026#34;+s; vector\u0026lt;ll\u0026gt;pre(n+1,0); for(int i=1;i\u0026lt;=n;i++){ pre[i]=(s[i]==\u0026#39;1\u0026#39;?1:-1)+pre[i-1]; } map\u0026lt;int,ll\u0026gt;cnt; cnt[0]=1; ll ans=0; for(int i=1;i\u0026lt;=n;i++){ ans=(ans+cnt[pre[i]]*(n-i+1)*1LL%MOD)%MOD; cnt[pre[i]]=(cnt[pre[i]]+i+1)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/cf962/","summary":"Codeforces Round 962 还得练 A Legs 先除 4 再除 2 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间他们不同的数量，更改差异数量除 2 (向上取整)，即可 #include \u0026lt;bits/stdc++.h\u0026gt;","title":"CF962"},{"content":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确\n类似有向无环图，由一个状态转移到下一个状态\n对先手来说，存在两种状态，即必胜态和必败态\n必胜态 当前状态的后续为必败态，当前状态即为必胜态\n必败态 不存在后续，或是所有后续都必胜\nDP 解决博弈 利用状态转移的关系，来解决简单的博弈问题\n移棋子问题 n * m 的棋盘，(1,1) 在左上角，(n,m) 在右下角，每格标明黑白两色\n上面有一个棋子，Alice 和 Bob 轮流移动这个棋子，Alice 先手移动，每次可以向上或向左移动一格，一旦移动到第一行或第一列游戏结束，执行最后一步移动的人，如果将棋子移动到黑格，就获胜，反之，则失败。\n现在给这个棋子的起始位置，问最后获胜的玩家是谁，对于所有的 (i,j) 满足 2\u0026lt;=i,j\u0026lt;=n 输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN][MAXN],n,m; string a,b; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=0;i\u0026lt;=m-2;i++){ dp[1][i+2]=(a[i]==\u0026#39;W\u0026#39;); } for(int i=0;i\u0026lt;=n-2;i++){ dp[i+2][1]=(b[i]==\u0026#39;W\u0026#39;); } for(int i=2;i\u0026lt;=n;i++){ for(int j=2;j\u0026lt;=m;j++){ dp[i][j]=!(dp[i-1][j]\u0026amp;\u0026amp;dp[i][j-1]); if(dp[i][j])cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;B\u0026#34;; } puts(\u0026#34;\u0026#34;); } } 取石子游戏 有一堆石子，大小为 x，Alice 和 Bob 轮流操作，Alice 先手，Alice 每次可以取 a[i] 个石子，Bob 可以取 b[i] 个，谁不能操作就输。\n问谁能获胜，对 x = 1 ~ m 都输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n1, n2, m, a[N], b[N], A[N], B[N]; int main(){ cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n1; i++){ cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n2; i++){ cin \u0026gt;\u0026gt; b[i]; } for (int i = 1; i \u0026lt;= m; i++){ for (int j = 1; j \u0026lt;= n1; j++){ if(i \u0026gt;= a[j] \u0026amp;\u0026amp; B[i-a[j]] == 0){ A[i] = 1; break; } } for (int j = 1; j \u0026lt;= n2; j++){ if(i \u0026gt;= b[j] \u0026amp;\u0026amp; A[i-b[j]] == 0){ B[i] = 1; break; } } puts(A[i] ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); } return 0; } 带和局的情况 存在先手必败，胜\n存在和，和\n败\n经典模型 巴什博弈 有 n 个石子，每次取 1~m 个，Alice 先取，谁取最后一颗谁胜\nn % (m + 1) = 0, 先手必败\nn % (m + 1) != 0, 先手必胜\n威佐夫博弈 有两堆石子，分别有 a, b 颗，每次可以选一堆取 x 个，也可以选两堆都取 x 个\n所以 (a, b)有三种转移，(a-x, b), (a, b-x), (a-x, b-x);\n打表找规律\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 首先发现 (a, b) 和 (b, a), 状态相同，即同为必败态或必胜态\n再对 a \u0026lt; b 的情况分析，发现 a 是从 1 到 n 的，b - a 逐渐递增，依次为 1 2 3 4 5 \u0026hellip;\nNim 模型 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流取，Alice 先取，每次可以从选一堆任取 x 个石子， 可以拿光，但不能不拿，谁最后把所有的拿光谁获胜\n先打表\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; // for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) // if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 发现 i == j，经推广更多维，可以总结出必败态：A1^A2^A3^\u0026hellip;^An = 0\n要证明此结论，可从三个定理入手\n1：没有后续状态的状态是必败态\n2：对于 A1^A2^A3^\u0026hellip;^An != 0 的局面一定存在某种移动使 A1^A2^A3^\u0026hellip;^An = 0\n3：对于 A1^A2^A3^\u0026hellip;^An = 0，不存在一种移动使 A1^A2^A3^\u0026hellip;^An = 0\n例题练习 石子游戏 2 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，每次可以把一堆个数为奇数的石子分为两堆，两堆都不能为空，或把两堆为偶数的石子和为一堆\n可以注意到两种操作都是对堆数改变，那么堆数的奇偶性就是突破点，同时根据操作的实质，可以发现只有 1 个石子的堆是无法继续操作的，最后石堆将变成全是 1 或者 1 个偶数剩下的全是 1\n所以结论就是：如果石堆全是 1，则先手必败，如果不是全为 1 那么就检测结束时堆数的奇偶性是否改变\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, odd, one; int x; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1;i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; x; if (x % 2 == 1) odd++; if (x == 1) one++; } if (one != n) odd++; if ((odd + n) % 2 != 0)cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#34;; return 0; } 石子游戏 3 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，选择 n/2 堆非空石子，每堆移除掉正数个(可以不同)的石子，从 Alice 开始。\n倒推：\n必败：超过 n/2 个堆已经为 0 必胜：有 1 ~ n/2 个堆为 0\n必败：有 \u0026gt; n/2 个堆石子数量为 1\n必胜：有 1 ~ n/2 个堆的数量为 1\n必败：有 \u0026gt; n/2 个堆的数量为 2\n\u0026hellip;\u0026hellip;\n有大于 n/2 个堆的数量 = min，必败\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, mx = 1e9, cnt; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if (x \u0026lt; mx) mx = x, cnt = 0; if (x == mx) cnt++; } if (cnt \u0026gt; n/2) cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E5%8D%9A%E5%BC%88%E8%AE%BA/","summary":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确 类似有向无环图，由一个状态转移到下一个状态 对先手来说，存在两种状态，即必胜态和必败态 必胜态 当前状态的后续为必败态，当前状态即为必胜态 必败态 不存在后续，或是所有后续都必胜 DP 解决博弈 利用状态转移的关系，来解决简单的博弈问题 移棋子问题 n","title":"博弈论"},{"content":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把\nI 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;\u0026#34;DHY\\n\u0026#34;; } } A 国际旅行 I 认真读题可得知，恒为联通图，排序所有国家即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n,m,q,k; vector\u0026lt;int\u0026gt;a(N); map\u0026lt;int,int\u0026gt;vis; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } sort(a.begin()+1,a.begin()+1+n); while(q--){ cin\u0026gt;\u0026gt;k; cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; } } J 这是签到 矩阵计算板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int a[6][6]; int cal(int n, int a[6][6]) { if (n == 1) return a[0][0]; int res = 0; int sub[6][6]; for (int x = 0; x \u0026lt; n; x++) { int subi = 0; for (int i = 1; i \u0026lt; n; i++) { int subj = 0; for (int j = 0; j \u0026lt; n; j++) { if (j == x) continue; sub[subi][subj] = a[i][j]; subj++; } subi++; } res += (x % 2 == 0 ? 1 : -1) * a[0][x] * cal(n - 1, sub); } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; a[i][j]; int ans = INT_MAX; int u=min(n,m); for(int i=1;i\u0026lt;=u;i++){ ans=min(ans,cal(i,a)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H 狼狼的备忘录 STL 大法好\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, cnt, m; string s; map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; note; map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; vis; set\u0026lt;string\u0026gt; peo; void erase(string \u0026amp;a, string \u0026amp;b) { if (a == b) { b = \u0026#34;\u0026#34;; return; } if (a.size() \u0026gt; b.size() \u0026amp;\u0026amp; a.substr(a.size() - b.size()) == b) { b = \u0026#34;\u0026#34;; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; cnt; peo.insert(s); for (int j = 1; j \u0026lt;= cnt; j++) { string t; cin \u0026gt;\u0026gt; t; if (!vis[s][t]) note[s].push_back(t); vis[s][t]++; } } for (auto x : peo) { int m = note[x].size(); for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { erase(note[x][i], note[x][j]); erase(note[x][j], note[x][i]); } } sort(note[x].begin(), note[x].end()); note[x].erase(remove(note[x].begin(), note[x].end(), \u0026#34;\u0026#34;), note[x].end()); } cout \u0026lt;\u0026lt; peo.size() \u0026lt;\u0026lt; endl; for (auto x : peo) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; note[x].size(); for (auto s : note[x]) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s; } cout \u0026lt;\u0026lt; endl; } return 0; } D A*BBBB 高精度 根据题意可知 是同一个结果往前移 b.size() 次相加 赛时笨比没调出来 python 引入 demical 库过的\n赛时代码\nfrom decimal import * import sys t=int(input()) for i in range(t): setcontext(Context(prec=2000000, Emax=2000000, Emin=0)) print((Decimal(sys.stdin.readline())*Decimal(sys.stdin.readline()))) 正解\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e7+10; typedef long long ll; int a[N],sum[N],ans[N\u0026lt;\u0026lt;1]; string A,B; void solve(){ cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B; int la=A.length(),lb=B.length(),b=B[0]-\u0026#39;0\u0026#39;; ll last=0; a[la+1]=0; for(int i=1;i\u0026lt;=la;i++){ a[i]=(A[la-i]-\u0026#39;0\u0026#39;)*b+last; last=a[i]/10; a[i]*=10; sum[i]=sum[i-1]+a[i]; } sum[la+1]=sum[la]+last; last=0; for(int i=1;i\u0026lt;=la+lb;i++){ int l=min(i,la+1),r=max(0,i-lb); ans[i]=sum[l]-sum[r]+last; last=ans[i]/10; ans[i]%=10; } bool flag=0; for(int i=la+lb;i\u0026gt;=1;--i) { if(!ans[i]) { if(flag) printf(\u0026#34;%d\u0026#34;,ans[i]); } else { flag=1; printf(\u0026#34;%d\u0026#34;,ans[i]); } } if(!flag) printf(\u0026#34;0\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E \u0026ldquo;好\u0026quot;字符 观察得到 a，b 同一字符所处位置相邻差值构成的一个循环同构如果相同，就符合题意\n那么就对 26 个字符各跑一次 找到位置 存入字符串 找到该串的最小表示 比较即可\n需要注意将原 a，b 再复制本身一遍 因为这样才能保证找的最小表示没有缺少\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp(int nxt[], string a) { int n = a.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; a[i] != a[j]) j = nxt[j - 1]; if (a[i] == a[j]) j++; nxt[i] = j; } return n - nxt[n - 1]; } string getmin(string s, int n) { s = s + s; int i = 0, j = 1; while (j \u0026lt; n) { int k = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) ++k; if (s[i + k] \u0026gt; s[j + k]) i += k + 1; else j += k + 1; if (i == j) j++; if (i \u0026gt; j) swap(i, j); } string t = s.substr(i, n); return t; } int main() { int n; string a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = a + a; b = b + b; map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; va, vb; map\u0026lt;char, string\u0026gt; sa, sb; for (int i = 0; i \u0026lt; n * 2; i++) { va[a[i]].push_back(i); vb[b[i]].push_back(i); } int cnt = 0, nxt[2000010]; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { if (va[x].size() != vb[x].size() || va[x].size() == 0 || vb[x].size() == 0) continue; for (int i = 1; i \u0026lt; va[x].size(); i++) { sa[x] += to_string(va[x][i] - va[x][i - 1]); } for (int i = 1; i \u0026lt; vb[x].size(); i++) { sb[x] += to_string(vb[x][i] - vb[x][i - 1]); } if (getmin(sa[x], kmp(nxt, sa[x])) == getmin(sb[x], kmp(nxt, sb[x]))) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C 小 w 和大 W 的对决 sg 暴力打表 发现 8 个为一个循环 最后两个交换位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int calc(int x){ if(x%8==0)return x-1; if(x%8==7)return x+1; else return x; } int ans; int main(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=calc(x); } if(ans==0)cout\u0026lt;\u0026lt;\u0026#34;W win\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;w win\\n\u0026#34;; } G lxy 的通风报信 因为数据不大，直接 bfs 跑每个点对其他点的距离，再求最小生成树即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; struct Node{ int x,y,id; }b[N]; int n,m,ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},tot,dis[N][N],a[N][N]; bool vis[N]; deque\u0026lt;Node\u0026gt;q; void bfs(int id){ q.clear(); q.push_back(Node{b[id].x,b[id].y,0}); dis[b[id].x][b[id].y]=0; while(!q.empty()){ Node now=q.front(); q.pop_front(); for(int i=0;i\u0026lt;4;i++){ int x=now.x+dx[i],y=now.y+dy[i]; if(x\u0026lt;1||y\u0026lt;1||x\u0026gt;n||y\u0026gt;m||a[x][y]==-1)continue; if(dis[x][y]\u0026gt;now.id+1){ dis[x][y]=now.id+1; q.push_back(Node{x,y,dis[x][y]}); } } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ dis[i][j]=1e9; char x; cin\u0026gt;\u0026gt;x; if(x==\u0026#39;.\u0026#39;)a[i][j]=0; else if(x==\u0026#39;#\u0026#39;)a[i][j]=-1; else { a[i][j]=++tot; b[tot]=Node{i,j,tot}; } } } dis[b[1].x][b[1].y]=0; for(int i=1;i\u0026lt;=tot;i++){ int mi=1e9,id=0; for(int j=1;j\u0026lt;=tot;++j){ if(vis[j])continue; if(mi\u0026gt;dis[b[j].x][b[j].y])mi=dis[b[j].x][b[j].y],id=j; } if(!id){ puts(\u0026#34;No\u0026#34;); return; } vis[id]=1; ans+=mi; if(i!=tot)bfs(id); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B2/","summary":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把 I 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using","title":"2024萌新联赛2"},{"content":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n)\n用两个指针 i,j, 分别指想目前两个可能是答案的起始位置\n初始 i = 1, j = 2, 随着算法进行增大\n假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同\n如果 s[i+k]!=s[j+k]\n谁大谁往后移动 k+1 个位置\n如果 s[i+k]==s[j+k]\n随便移动一个\n最后小于 n 的那个指针就是所求答案\nvoid getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } 例题 循环同构判断 给定两个字符串 a, b,判断两个字符串是否循环同构\n只需判断两个字符串最小表示是否一样即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a,b; int getmin(string s){ int n=s.size(); int i=0,j=1; s=s+s; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)++j; if(i\u0026gt;j)swap(i,j); } return i; } int main(){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=getmin(a),j=getmin(b),k=0;k\u0026lt;n;k++){ if(a[(i+k)%n]!=b[(j+k)%n]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return 0; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } 最小循环覆盖 给出字符串 a，求出这个字符串的字典序最小的最小循环覆盖\n先用 kmp 求出最小循环片段长度，再求这个长度的子串的最小表示\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a; int nxt[100005]; int kmp(){ int n=a.size(); nxt[0]=0; int j=0; for(int i=1;i\u0026lt;n;i++){ while(j\u0026amp;\u0026amp;a[i]!=a[j]) j=nxt[j-1]; if(a[i]==a[j]) j++; nxt[i]=j; } return n-nxt[n-1]; } void getmin(string s,int n){ s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int l=i;l\u0026lt;i+n;l++)cout\u0026lt;\u0026lt;s[l]; } int main(){ cin\u0026gt;\u0026gt;a; getmin(a,kmp()); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n) 用两个指针 i,j, 分别指想目前两个可能是答案的起始位置 初始 i = 1, j = 2, 随着算法进行增大 假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同 如果 s[i+k]!=s[j+k] 谁大谁往后移动 k+1 个位置 如果 s[i+k]==s[j+k] 随","title":"最小表示法"},{"content":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。\n签到，直接暴力\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分 输入: 1 s3://hdu-oj-bucket/problem=1/type=data/ 输出： s3 hdu-oj-bucket problem=1 type=data\n签到，按题意拆分字符串即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string s; cin\u0026gt;\u0026gt;s; int pos = s.find(\u0026#34;://\u0026#34;); cout\u0026lt;\u0026lt;s.substr(0,pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; pos+=3; int now = s.find(\u0026#34;/\u0026#34;,pos); cout\u0026lt;\u0026lt;s.substr(pos,now-pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; while(1){ pos=now+1; if(pos\u0026gt;=s.size())break; now = s.find(\u0026#34;/\u0026#34;,pos); string t = s.substr(pos,now-pos); int flag = t.find(\u0026#34;=\u0026#34;); if(flag!=-1)cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1001 鸡爪 给 n 条边，任意顶点，构造数量最多的鸡爪，同时保证输出每条边的两个顶点时，保证行优先遍历，字典序最小。\n鸡爪的定义：1 个顶点，和它所连的 3 条边，不包括其他顶点，不可重复利用。\n构造，易想出 n 条边，最多构造出 n/3 个鸡爪，多出的 1 或 2 个边，补到顶点1上即可。\n因为字典序最小，所以顶点 1 上连的边肯定最多，我们就让 1 连到所有的顶点上，这样其他所有构造鸡爪的顶点 n 都能用上 1-n 这条边。因此 1 自己用的边肯定是入度最小的几个顶点，即编号最大的顶点，类推到之后的顶点，都是先采用与其之前的顶点的边，再从最后面选。到顶点 4 开始，不再需要往后采用，因为前面有 3 个顶点提供边，不再需要额外的顶点来提供边。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n\u0026gt;=3){ int now=0,cnt=n/3+3; for(int i=1;i\u0026lt;=min(n/3,3);i++){ for(int j=i+1;j\u0026lt;=cnt-i+1;j++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(i==1\u0026amp;\u0026amp;j==cnt-i+1){ int now=j; while(n%3!=0){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;++now\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; n--; } } } } } else{ for(int i=2;i\u0026lt;=n+1;i++)cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1006 传奇勇士小凯 有⼀个 n 个结点的有根树，你需要从 1 号结点走到任意⼀个叶子节点，每天你有 p[i]/15 的可能性可以向任意⼀个儿子节点走⼀步（ i 为你当前所在的节点编号），询问你期望最多可以在这颗树上走多久\n期望计算，在某一节点停留的步数应该为 15/p[i] 。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; ll ans=0, LCM=360360; vector\u0026lt;int\u0026gt; nxt[N]; vector\u0026lt;int\u0026gt; p(N); ll gcd(int x,int y){ if(!x||!y)return x+y; return gcd(y,x%y); } void dfs(int u,int fa, ll sum) { sum += (LCM / p[u]); if(sum\u0026gt;ans)ans=sum; for (auto x : nxt[u]) { if(x==fa)continue; dfs(x, u, sum); } } void solve() { int n; cin \u0026gt;\u0026gt; n; ans=0; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; nxt[u].push_back(v); nxt[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; dfs(1, 0, 0); ll d=gcd(15*ans,LCM); printf(\u0026#34;%lld/%lld\\n\u0026#34;,15*ans/d,LCM/d); for (int i = 1; i \u0026lt;= n; i++) nxt[i].clear(); } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1003 绝对不模拟的简单魔方 1)暴力，从初始状态开始模拟，每次对比当前状态和给出状态，若相同或不同点仅两个，即得到答案\n2)将魔方视为 2 阶的，预处理得到 24 种可能状态，与给出状态对比，至多有一个角不同，即为答案。\n之后补... 1011 在 A 里面找有 C 的 B AC自动机（还不会，之后补\u0026hellip;.\n","permalink":"https://KiritoXDone.github.io/posts/study/2024hdu2/","summary":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。 签到，直接暴力 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分 输入","title":"2024HDU2"},{"content":"Manacher 理念学习 解决最长回文子串问题\n给出一个任意字符串，求出这个字符串中最长的回文子串\n正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可\n对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文子串的长度，记做 p[i] (包括 i 本身，所以最小为 1)\n维护 p[i] 的值：\n维护一个到目前位置的R最大的区间 [L, R]，其中 L = M - p[M] + 1 (M \u0026lt; i) R = M + p[M] - 1\n[L, R] 是一个回文串 如果i \u0026lt;= R:\n找到 i 对于 M 的对称点 k，此时 i - M = M - k,k = 2 * M - i; 此时有两种情况：\n(1)如果 p[k] 对应的回文区间 [k - p[k] + 1, k + p[k] - 1]，不含左端点 L，说明这个回文区间在 [L, R] 之中，此时我们可以得到 p[i] = p[k]\n(2)如果包含了左端点L，此时 [L, 2k-L] 这一端为回文串。由于 [L, R] 是回文串，可得出 [2i-R, R] 也是回文串。往两端暴力拓展即可。 如果 i \u0026gt; R：\n暴力两端拓展即可 都要记得更新 M, L, R 的值。\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } 洛谷例题 P3805\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; int n,p[2*N]; string s,t; void manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s; manacher(); return 0; } 坑点：字符串 t 要 resize，不然 re\n","permalink":"https://KiritoXDone.github.io/posts/study/manacher/","summary":"Manacher 理念学习 解决最长回文子串问题 给出一个任意字符串，求出这个字符串中最长的回文子串 正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可 对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文","title":"Manacher"},{"content":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点\nkmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1\n简化版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){ while(j==m||(j\u0026amp;\u0026amp;s[i]!=p[j])) j=nxt[j-1]; if(s[i]==p[j]) j++; f[i]=j; } for(int i=0;i\u0026lt;n;i++){ if(f[i]==m)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 寻找最小循环子串 字符串 s 是由某个子串重复连接而成的，寻找构成 s 的最小子串的长度\n答案其实就是 n - nxt[n]\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],n,m; void kmp(){y m=p.size(); int j=0; nxt[0]=0; p=p; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } cout\u0026lt;\u0026lt;m-nxt[m-1]\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;p; kmp(); return 0; } Secret word 给出字符串 s，寻找最长字符串 p，p 满足（是 s 的子串，翻转后是 s 的前缀）\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int nxt[200001],n; void kmp(){ n=s.size(); int j=0; nxt[0]=0; string t=s; reverse(t.begin(),t.end()); s=s+\u0026#34;#\u0026#34;+t; for(int i=1;i\u0026lt;n*2+1;i++){ while(j\u0026amp;\u0026amp;s[i]!=s[j]) j=nxt[j-1]; if(s[i]==s[j]) j++; nxt[i]=j; } int ans=-1; for(int i=n;i\u0026lt;2*n+1;i++){ ans=max(ans,nxt[i]); } for(int i=ans-1;i\u0026gt;=0;i--)cout\u0026lt;\u0026lt;s[i]; } int main(){ cin\u0026gt;\u0026gt;s; kmp(); return 0; } exkmp 洛谷 P5410\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; typedef long long ll; string s,p; ll z[N*2],n,m; void exkmp(string s,string p){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; ll L=0,R=-1; z[0]=m; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ ll k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } ll ans=0; for(int i=0;i\u0026lt;m;i++)ans^=(1LL*(i+1)*(z[i]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ans=0; for(int i=0;i\u0026lt;n;i++)ans^=(1LL*(i+1)*(z[i+m+1]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(s,p); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/0721/","summary":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点 kmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1 简化版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){","title":"0721"},{"content":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现\n暴力匹配 O(nm)\n哈希优化 O(n+m)\nKMP 线性复杂度解决 O(n+m)\nKMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同\nf[i] 对应j的位置，j对应p中的位置\n如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位\n否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k 最大的位\n如果 s[i + 1] 仍不等于 p[j + 1]，不停向前回退，直到相等或 j = 0\n快速求出 k\n易得到求 k 与 s 无关\n最大的 k 满足 k \u0026lt; j,使得 p[1]..p[k] 和 p[j - k + 1]\u0026hellip;p[j] 完全相同\n可以用 next 维护每个 j 对应的 k\nvoid kmp(){ n=s.size()+1,m=p.size()+1;//字符串下标从 1 开始 int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } 洛谷例题 P3375\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n, m; string s, p; int nxt[N], f[N]; void kmp() { n = s.size(); m = p.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j]) j = nxt[j - 1]; if (p[i] == p[j]) j++; nxt[i] = j; } j = 0; for (int i = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j]) j = nxt[j - 1]; if (s[i] == p[j]) j++; f[i] = j; if (j == m) { cout \u0026lt;\u0026lt; i - m + 2 \u0026lt;\u0026lt; endl; j = nxt[j - 1]; } } for (int i = 0; i \u0026lt; m; i++) { cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; kmp(); return 0; } EXKMP(Z-algorithm) 理论学习 线性时间复杂度求出字符串s和他的任意后缀 s[i]\u0026hellip;s[n] 的最长公共前缀的长度 O(n)\n与 kmp 的区别：一个是到 s[i] 结束，一个是从 s[i] 开始\n定义 z[1] = 0，从 2 到 n 枚举 i，依次计算 z[i] 的值\n计算 z[i] 时，前面的 z 都已经计算好了\n对于 j，有 s[j]\u0026hellip;s[j + z[j] - 1] 和 s[1]\u0026hellip;s[z[j]] 完全相等\n为了计算 z[i]，在枚举i的过程中，需要维护R的最大区间 [L, R],其中 L = j，R =j + z[i] - 1\n初始时 L = 1,R = 0\n如果 i \u0026lt;= R:\n易知 s[L]\u0026hellip;s[R] = s[1]\u0026hellip;s[R - L + 1]\n令 k = i - L + 1,i 与 k 的位置对应，此时s[i]..s[R] = s[k]..s[R - L + 1]\n如果 z[k] \u0026lt; R - i + 1，说明从 k 开始匹配不到那么远，也就是从 i 开始匹配不到 R，此时 z[i] = z[k]\n反之，说明可以匹配到 R 那么远，从 R+1 开始往后暴力\n如果 i \u0026gt; R:\n暴力枚举匹配，记得更新 L 和 R\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } 例题 给出字符串 s, p,求 s 中 p 出现的次数和位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int z[200001],n,m; void exkmp(){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; int L=0,R=-1; z[0]=0; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } int ans=0; for(int i=m+1;i\u0026lt;m+n+1;i++) if(z[i]==m)ans++; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=m+1;i\u0026lt;n+m+1;i++) if(z[i]==m)cout\u0026lt;\u0026lt;i-m\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/kmp/","summary":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现 暴力匹配 O(nm) 哈希优化 O(n+m) KMP 线性复杂度解决 O(n+m) KMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同 f[i] 对应j的位置，j对应p中的位置 如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位 否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k","title":"KMP"},{"content":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取\n排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素\n将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放\n确定 x 的位置后，对两侧继续递归\nvoid quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand() % (r - l + 1)]); // 保证 x 随机取 int x = a[l]; int i = l, j = r; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt; x) // 不能写成 a[j] \u0026gt;= x j--; if (i \u0026lt; j) a[i++] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt; x) // 不能写成 a[i] \u0026lt;= x i++; if (i \u0026lt; j) a[j--] = a[i]; } a[i] = x; quicksort(l, i - 1); // 不能递归 i quicksort(i + 1, r); } //另一种写法\nvoid Quicksort(int l, int r){ if(l\u0026gt;=r)return; int b[100001],c[100001]; int x=a[l+rand()\u0026amp;(r-l+1)]; int l1=0,l2=0,y=0; for(int i=l;i\u0026lt;=r;i++){ if(a[i]\u0026lt;x) b[++l1]=a[i]; else if(a[i]\u0026gt;x) c[++l2]=a[i]; else ++y; } for(int i=1;i\u0026lt;=l1;i++) a[l+i-1]=b[i]; for(int i=1;i\u0026lt;=y;i++) a[l+l1+i-1]=x; for(int i=1;i\u0026lt;=l2;i++) a[l+l1+y+i-1]=c[i]; Quicksort(l,l+l1-1); Quicksort(l+l1+y,r); } 归并排序 归并排序 分治 复杂度 nlogn 且稳定 要排序 [l, r]，长度为1直接退出，否则分为 [l, m],[m+1, r]; 递归两个子区间进行归并排序 将排序好的子区间合并\nvoid mergesort(int l,int r){ if(l==r)return; int m=(l+r)/2; mergesort(l,m); mergesort(m+1,r); int p1=l,p2=m+1,tot=0; while(p1\u0026lt;=m\u0026amp;\u0026amp;p2\u0026lt;=r){ if(a[p1]\u0026lt;=a[p2]) c[++tot]==a[p1++]; else c[++tot]=a[p2++]; } while(p1\u0026lt;=m) c[++tot]=a[p1++]; while(p2\u0026lt;=m) c[++tot]=a[p2++]; for(int i=1;i\u0026lt;=tot;i++) a[i+l-1]=c[i]; } 计数排序 计数排序 适合值域范围较小 复杂度 n+k 稳定 统计每个数字出现了几次 统计完出现次数，求前缀和，可知道每个数字在拍完序的位置的范围 保证稳定性，倒着确定原本每个位置上的数字最后排在低级位\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[a[i]]; for(int i=1;i\u0026lt;=m;i++) for(int j=1;j\u0026lt;=c[i];j++) printf(\u0026#34;%d\u0026#34;,i); printf(\u0026#34;\\n\u0026#34;); for(int i=2;i\u0026lt;=m;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[i]=c[a[i]]--; for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d\u0026#34;,r[i]); printf(\u0026#34;\\n\u0026#34;); } 基数排序 基数排序 复杂度 nk 拆分成 m 个关键字 从后往前 依次对 m 个关键字进行排序 每次排序会使用上一次排序的结果 一般使用计数排序来完成每次的排序 例如对三位数排序 先排个位 再排十位 再排百位 经常被用于字符串的排序 后缀数组的核心就是基数排序\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[v[i]]; for(int i=1;i\u0026lt;=9;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[sa[i]]=c[v[sa[i]]]--; for(int i=1;i\u0026lt;=n;i++) sa[r[i]]=i; } void radixsort(){ for(int i=1;i\u0026lt;=n;i++) sa[i]=i; int x=1; for(int i=1;i\u0026lt;=m;i++,x*=10){ for(int j=1;j\u0026lt;=n;j++){ v[j]=a[j]/x%10; } countingsort(); } } ","permalink":"https://KiritoXDone.github.io/posts/study/easy-sort/","summary":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取 排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素 将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放 确定 x 的位置后，对两侧继续递归 void quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand() % (r - l +","title":"简单的排序"}]