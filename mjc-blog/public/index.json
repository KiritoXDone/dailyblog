[{"content":"杂项 加速 sync_with_stdio(0);cin.tie(0);cout.tie(0)\n随机数 : random_device 或 chrono::system_clock::now().time_since_epoch().count()\n最短路 dijkstra $O(mlogn)$\nstruct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } SPFA $O(km)$ k 为常数，最差为 $O(nm)$\nstruct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int dis[N],cnt[N],vis[N]; queue\u0026lt;int\u0026gt;q; bool spfa(int n,int s){ memset(dis,63,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto x:edge[u]){ int v=x.v,w=x.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n)return false; if(!vis[v])q.push(v),vis[v]=1; } } } return true; } 最小生成树 Kruskal $O(mlogm)$ 加边\nstruct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int find(int i){ if(fa[i]==i)return i; return fa[i]=find(fa[i]); } int Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=find(a[i].x),y=find(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } return cnt; } Prim $O(n^2)$ 加点\nstruct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } LCA 最近公共祖先\n倍增预处理 $O(nlogn)$ 查询 $O(logn)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 6e5+7; int n,m,s; vector\u0026lt;int\u0026gt;v[N]; int d[N],f[N][32]; void dfs(int x,int y){ d[x]=d[y]+1; f[x][0]=y; for(int i=1;i\u0026lt;=31;i++){ f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i\u0026lt;v[x].size();i++){ if(d[v[x][i]]==0)dfs(v[x][i],x); } } int lca(int x,int y){ if(d[x]\u0026lt;d[y])swap(x,y); for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;d[f[x][i]]\u0026gt;=d[y]) x=f[x][i]; } if(x==y)return x; for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;f[y][i]!=0\u0026amp;\u0026amp;f[x][i]!=f[y][i]){ x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;lca(x,y)\u0026lt;\u0026lt;endl; } } SG 板 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[1010]; int main() { int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; i++) { set\u0026lt;int\u0026gt; s; for (int j = 1; j \u0026lt;= i; j *= p) { s.insert(sg[i - j]); } while (s.count(sg[i])) sg[i]++; printf(\u0026#34;%d %d\\n\u0026#34;, i, sg[i]); } return 0; } 字符串 KMP void kmp(){ n=s.size()+1,m=p.size()+1;//字符串下标从 1 开始 int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } EXKMP(z-algorithm) 求 s 和他的后缀的最长公共前缀\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } Manacher 求出字符串中最长回文片段\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } 最小表示法 void getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } 数论 快速幂 long long qpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = res * a; a = a * a; b \u0026gt;\u0026gt;= 1; } return res; } exgcd i64 exgcd(i64 a, i64 b, i64 \u0026amp;x, i64 \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; } // ax + b = 0 (mod m) std::pair\u0026lt;i64, i64\u0026gt; sol(i64 a, i64 b, i64 m) { assert(m \u0026gt; 0); b *= -1; i64 x, y; i64 g = exgcd(a, m, x, y); if (g \u0026lt; 0) { g *= -1; x *= -1; y *= -1; } if (b % g != 0) { return {-1, -1}; } x = x * (b / g) % (m / g); if (x \u0026lt; 0) { x += m / g; } return {x, m / g}; } 欧拉筛 std::vector\u0026lt;int\u0026gt; minp, primes; void sieve(int n) { minp.assign(n + 1, 0); primes.clear(); for (int i = 2; i \u0026lt;= n; i++) { if (minp[i] == 0) { minp[i] = i; primes.push_back(i); } for (auto p : primes) { if (i * p \u0026gt; n) { break; } minp[i * p] = p; if (p == minp[i]) { break; } } } } bool isprime(int n) { return minp[n] == n; } 高精度 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; constexpr int N = 1000; struct BigInt { int a[N]; BigInt(int x = 0) : a{} { for (int i = 0; x; i++) { a[i] = x % 10; x /= 10; } } BigInt \u0026amp;operator*=(int x) { for (int i = 0; i \u0026lt; N; i++) { a[i] *= x; } for (int i = 0; i \u0026lt; N - 1; i++) { a[i + 1] += a[i] / 10; a[i] %= 10; } return *this; } BigInt \u0026amp;operator/=(int x) { for (int i = N - 1; i \u0026gt;= 0; i--) { if (i) { a[i - 1] += a[i] % x * 10; } a[i] /= x; } return *this; } BigInt \u0026amp;operator+=(const BigInt \u0026amp;x) { for (int i = 0; i \u0026lt; N; i++) { a[i] += x.a[i]; if (a[i] \u0026gt;= 10) { a[i + 1] += 1; a[i] -= 10; } } return *this; } }; std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;o, const BigInt \u0026amp;a) { int t = N - 1; while (a.a[t] == 0 \u0026amp;\u0026amp; t \u0026gt; 0) { t--; } for (int i = t; i \u0026gt;= 0; i--) { o \u0026lt;\u0026lt; a.a[i]; } return o; } 线段树 struct Tag { int mul, add; }; struct Node { int len, sum; Tag tag; } tr[N\u0026lt;\u0026lt;2]; Tag operator + (const Tag \u0026amp;a, const Tag \u0026amp;b) { return {a.mul * b.mul % mod, (a.add * b.mul + b.add) % mod}; } Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = (l.sum + r.sum) % mod; a.tag = {1, 0}; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, Tag t) { tr[now].tag = tr[now].tag + t; tr[now].sum = (tr[now].sum * t.mul + tr[now].len * t.add) % mod; } void pushdown(int now) { if (tr[now].tag.mul != 1 || tr[now].tag.add) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = {1, 0}; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], {1, 0}}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, Tag val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans = (ans + query(ls, l, r, s, mid)) % mod; if (r \u0026gt; mid) ans = (ans + query(rs, l, r, mid + 1, t)) % mod; return ans; } ","permalink":"https://blog.050623.xyz/posts/study/template/","summary":"杂项 加速 sync_with_stdio(0);cin.tie(0);cout.tie(0) 随机数 : random_device 或 chrono::system_clock::now().time_since_epoch().count() 最短路 dijkstra $O(mlogn)$ struct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } SPFA $O(km)$ k 为常数，最差为 $O(nm)$ struct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int","title":"Template"},{"content":"基本都是搭在 Serv00 上的\nAlist 链接\nPrivateBin 链接\nWebSSH 已废弃 暂用 Linux-do 佬友的服务 链接\nCron-Serv00 链接\nUptime-KUMA 链接\nProxy hy2:\nhysteria2://2bfbab50-9fd3-11ef-a739-3cecef0f513e@31.186.87.211:20000/?sni=www.bing.com\u0026amp;alpn=h3\u0026amp;insecure=1#PL-Atman_Sp._z_o.o. ","permalink":"https://blog.050623.xyz/posts/tech/tools/","summary":"基本都是搭在 Serv00 上的 Alist 链接 PrivateBin 链接 WebSSH 已废弃 暂用 Linux-do 佬友的服务 链接 Cron-Serv00 链接 Uptime-KUMA 链接 Proxy hy2: hysteria2://2bfbab50-9fd3-11ef-a739-3cecef0f513e@31.186.87.211:20000/?sni=www.bing.com\u0026amp;alpn=h3\u0026amp;insecure=1#PL-Atman_Sp._z_o.o.","title":"自建小玩具"},{"content":"前言 铁了，唉，赛时发挥一坨屎\nI. In Search of the Ultimate Artifact 赛时一眼盯真，鉴定为纯纯的暴力，自己写了会发现老是不对，让队长上机调了几分钟过了\n题意即每次选当前最大的 $k$ 个数相乘，求最后能得到的最大的数是多少，对这个最大的数取模\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=998244353; int n,k; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n,greater\u0026lt;ll\u0026gt;()); ll ans=a[1]%mod; deque\u0026lt;int\u0026gt;q; ll tmp=1; for(int i=2;i\u0026lt;=n;i++){ if(a[i]==0)break; q.push_back(a[i]); tmp=(tmp*a[i])%mod; if((int)q.size()%(k-1)==0){ ans=(ans*tmp)%mod; tmp=1; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Conquer the Multiples 赛时居然卡了 1 个多小时\n简单的博弈论\n易发现，偶数乘于任何数都还是偶数，即从偶数开始的人，是无法阻碍另一个人的，但是奇数的人可以去拿偶数位上的，即奇数开始的人处于优势地位\n基础情况为每个人只拿当前位置\n最优情况，偶数仍然只能拿当前位置，拿后面的只会妨碍自己，奇数能拿偶数时优先拿偶数\n可以发现，基础步数是区间内奇偶的个数，考虑到最优情况，奇数会拿走偶数的，我们只需要看奇数按最优的操作后，谁的步数多即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=998244353; ll l,r; void solve(){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if(l\u0026amp;1){ if(l*2\u0026lt;=r){cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;;return;} } else { if((l+1)*2\u0026lt;=r){cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;;return;} } cout\u0026lt;\u0026lt;(((r-l+1)\u0026amp;1) ? \u0026#34;Alice\\n\u0026#34; : \u0026#34;Bob\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G. Geometry Task 赛场上太急了，思路只对了一部分，还有部分没想到就上机开始硬调了\n显然易想到二分答案，重点就是 $check$ 的过程\n开始想法是对于每个 $红线$，用二分找他的最优的 $蓝线$ 与其匹配，但是忽视了 $a\u0026lt;0$ $a\u0026gt;0$ 对于最优的要求的不同 例如 $2$ 者的最优都是 $1$ 时，$蓝线$ 数据为 ${1,2,3}$，如果先判断了正的那个，它就会取走 $1$，那么 负的就取不了了\n所以，将问题转化为区间取数问题，对于负数，是在 $[1,x]$，上取数，对于正数，是在 $[x,n]$ 上取数\n将正负分开处理，分别考虑能取走几个即可，最后返回 $cnt\u0026gt;=(mid+1)/2$ 即可\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=2e5+7; struct Node{ ll a,b; bool operator\u0026lt;(const Node \u0026amp;tmp){ if(a==tmp.a)return b\u0026lt;tmp.b; return a\u0026lt;tmp.a; } }; Node a[N]; ll c[N]; int cnt[N]; int n,fu,zheng; bool check(ll x){ int res=0; for(int i=1;i\u0026lt;=n;i++)cnt[i]=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i].a\u0026lt;0){ ll l=1,r=fu,ans=0; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if(a[i].a*c[mid]+a[i].b\u0026gt;=x)l=mid+1,ans=mid; else r=mid-1; } cnt[ans]++; } else if(a[i].a==0){ if(a[i].b\u0026gt;=x)res++; } else{ ll l=zheng,r=n,ans=0; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if(a[i].a*c[mid]+a[i].b\u0026gt;=x)r=mid-1,ans=mid; else l=mid+1; } cnt[ans]++; } } int sum=0; for(int i=1;i\u0026lt;=fu;i++){ sum++; if(cnt[i]){ if(sum\u0026gt;=cnt[i])res=res+cnt[i],sum=sum-cnt[i]; else res=res+sum,sum=0; } } sum=0; for(int i=n;i\u0026gt;=zheng;i--){ sum++; if(cnt[i]){ if(sum\u0026gt;=cnt[i])res+=cnt[i],sum-=cnt[i]; else res+=sum,sum=0; } } return res\u0026gt;=(n+1)/2; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].a; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].b; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;c[i]; sort(a+1,a+1+n); sort(c+1,c+1+n); ll l=-2e18,r=2e18,ans=0; fu=0,zheng=n+1; for(int i=n;i\u0026gt;0;i--){ if(a[i].a\u0026lt;0){ fu=i; break; } } for(int i=1;i\u0026lt;=n;i++){ if(a[i].a\u0026gt;0){ zheng=i; break; } } while(l\u0026lt;=r){ ll mid=ll(l+r)\u0026gt;\u0026gt;1; if(check(mid))l=mid+1,ans=mid; else r=mid-1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Basic Graph Algorithm md 三个人硬是没开出来\n显然最优是连不到下个点时加边，前面能回溯时则不加，选择回溯来实现这个点\n加边一定是加到靠前的点更优\n代码实现:\n首先开一个超级源点 $0$ 可连到所有的节点，同时所有的节点也能回到这个超级源点\n然后记录条边连接的点\n用 $dfs$ 实现，我们从 $0$ 端点开始，将能到达的点中回来的路全部删掉，接着判断是否子节点中是否能够通往下一个节点，如果没有对应的路，就加点，接着以下一个点进行 $dfs$\n实现回溯的关键在于 $dfs$ 中的判断采用的是 $while$，如果当前这个节点他没有边，那我们应该回去，此时之前的节点仍然能进行判断，是否需要加边\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int n,m,k; int p[N]; int vis[N]; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;ans; vector\u0026lt;int\u0026gt;edges[N]; set\u0026lt;int\u0026gt;edge[N]; void dfs(int now){ k++; vis[now]=1; for(int v:edges[now])edge[v].erase(now); while(edge[now].size()\u0026amp;\u0026amp;k\u0026lt;=n){ if(!edge[now].count(p[k]))ans.push_back({now,p[k]}); dfs(p[k]); } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ans.clear(); k=0; for(int i=1;i\u0026lt;=n;i++){ edge[i].insert(0); edge[0].insert(i); edges[i].push_back(0); edges[0].push_back(i); } for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].insert(v); edge[v].insert(u); edges[u].push_back(v); edges[v].push_back(u); } for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;p[i]; dfs(0); cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto [x,y]:ans)cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Decrease and Swap 开始队友读错题，以为每个盒子里一块石头，差点上机特判，还好冷静了，虽然对结果也没什么影响\n实际上。每个盒子内都是无限块石头，那考虑时，可以考虑某个区间内的整体操作，即我们遍历向后扫，记录当前各出现的 $01$ 次数，如果 $cnt0\u0026gt;cnt1$ 那么，经过神奇的变换操作，我们一定可以将这个区间内所有的 $1$ 变为 $0$，最后如果 $cnt1+cnt0\u0026gt;3 || cnt1+cnt0==0$ 那么就是 Yes\n为什么 $cnt0\u0026gt;cnt1$ 当前区间一定能转化成功:\n因为我们的操作次数是无限的，同时这个触发条件一定有两个 $0$ ，那么我们经过一些交换后，总能使两个 $0$ 到达当前串的末尾，此时前面的盒子直接无脑消掉即可 那么最后 $cnt1+cnt0\u0026gt;3$ 为什么是 Yes:\n最后剩下的没转化的串中，$1$ 的个数大于等于 $0$ 的个数，同时这个串的长度大于 $3$，即我们可以先对几个 $1$ 操作，转化出来两个 $0$，再根据前面的理论，此时的串一定能转换过去 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; string s; int cnt[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; int c1=0,c0=0; for(int i=0;i\u0026lt;n;i++){ if(s[i]==\u0026#39;1\u0026#39;)c1++; else c0++; if(c0\u0026gt;c1)c1=c0=0; } if(c1+c0\u0026gt;3||c1+c0==0){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/icpc2024shanghai/","summary":"前言 铁了，唉，赛时发挥一坨屎 I. In Search of the Ultimate Artifact 赛时一眼盯真，鉴定为纯纯的暴力，自己写了会发现老是不对，让队长上机调了几分钟过了 题意即每次选当前最大的 $k$ 个数相乘，求最后能得到的最大的数是多少，对这个最大的数取模 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=998244353; int n,k; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n,greater\u0026lt;ll\u0026gt;()); ll ans=a[1]%mod; deque\u0026lt;int\u0026gt;q;","title":"ICPC2024shanghai"},{"content":"A. Verify Password 先判断前缀中的数字片段，如果有相邻递减的就 No\n连续的看完之后看后面的字母片段，如果有数字，就 No，同时也要保持非递减\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; void solve() { int n; string s,tmp=\u0026#34;\u0026#34;; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;n;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ tmp+=s[i]; } else break; } if (!tmp.empty()) { for (int i = 0; i \u0026lt; tmp.size() - 1; i++) { if (tmp[i] \u0026gt; tmp[i + 1]) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return; } } } for(int i=tmp.size();i\u0026lt;n-1;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } if(s[i]\u0026gt;s[i+1]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Increase/Decrease/Copy 要把 a 变成 b，每一位判断，先加上 $abs(a_i-b_i)$，同时判断，当前这位变换后，加到 a 末尾补全的代价，找到最小补全代价，最后加上即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; void solve() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt;a(n),b(n+1); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=0;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]; ll ans=0,tmp=1e9,t=0; for(int i=0;i\u0026lt;n;i++){ ans+=abs(a[i]-b[i]); if(a[i]\u0026gt;=b[n]\u0026amp;\u0026amp;a[i]\u0026gt;=b[i]\u0026amp;\u0026amp;b[n]\u0026gt;=b[i])t=1; else if(a[i]\u0026lt;=b[n]\u0026amp;\u0026amp;a[i]\u0026lt;=b[i]\u0026amp;\u0026amp;b[n]\u0026lt;=b[i])t=1; else{ int ta=abs(b[n]-min(a[i],b[i]))+1; int tb=abs(b[n]-max(a[i],b[i]))+1; t=min(ta,tb); } tmp=min(tmp,t); } ans+=tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Job Interview 易发现，会有一个前缀，里面的每个人都去自己最擅长的部门，这个位置之后，所有人都去同一个部门，我们只需要对这个位置二分即可\n通过前缀和，后缀和得到这个位置的实际值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) #define int long long typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n, m; int a[N * 2], b[N * 2], pre[N * 2]; ll ans[N * 2], sum[N * 2], sa[N * 2], sb[N * 2]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n + m + 1; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n + m + 1; i++) cin \u0026gt;\u0026gt; b[i]; for (int i = 1; i \u0026lt;= n + m + 1; i++) pre[i] = pre[i - 1] + (a[i] \u0026gt; b[i]); for (int i = 1; i \u0026lt;= n + m + 1; i++) sum[i] = sum[i - 1] + max(a[i], b[i]); sa[n + m + 2] = sb[n + m + 2] = 0; for (int i = n + m + 1; i \u0026gt; 0; i--) { sa[i] = sa[i + 1] + a[i]; sb[i] = sb[i + 1] + b[i]; } for (int i = 1; i \u0026lt;= n + m + 1; i++) { int l = 0, r = n + m + 1, ans = -1; ll NA, NB; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; int na = pre[mid], nb = mid - na; if (mid \u0026gt;= i) (a[i] \u0026gt; b[i] ? na : nb)--; if (na \u0026gt;= n || nb \u0026gt;= m) { NA = na, NB = nb; r = mid - 1, ans = mid; } else l = mid + 1; } int res = sum[ans] - (ans \u0026gt;= i ? max(a[i], b[i]) : 0ll); res += NB == m ? sa[ans + 1] - (ans + 1 \u0026lt;= i ? a[i] : 0) : sb[ans + 1] - (ans + 1 \u0026lt;= i ? b[i] : 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe166/","summary":"A. Verify Password 先判断前缀中的数字片段，如果有相邻递减的就 No 连续的看完之后看后面的字母片段，如果有数字，就 No，同时也要保持非递减 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; void solve() { int n; string s,tmp=\u0026#34;\u0026#34;; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;n;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ tmp+=s[i]; } else break; } if (!tmp.empty()) { for (int i = 0; i \u0026lt; tmp.size() - 1; i++) { if (tmp[i] \u0026gt; tmp[i + 1]) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return; } } } for(int i=tmp.size();i\u0026lt;n-1;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } if(s[i]\u0026gt;s[i+1]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);","title":"Educational Codeforces Round 166 (Rated for Div. 2)"},{"content":"A. Painting the Ribbon 显然，Alice 的理想操作是每种颜色均匀分布\n而 Bob 的理想操作是选择当前数量最多的颜色，将其他的都喷为这个颜色\n所以只要判断 k 是否大于 $n-mx$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; if(m==1||k\u0026gt;=n-1){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } int ned=n-ceil(1.0*n/m); if(k\u0026lt;ned)cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Make It Ugly 注意到，操作只会使中间的元素进行变化，即 $a_1,a_n$ 会保持不变\n那么目标就是找到两个不同的数，删去他们之前的相同数的片段\n找到最短的相同片段，即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7, inf=1e9; int n,a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int ans=inf,tmp=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i]==a[1])tmp++; else if(tmp)ans=min(ans,tmp),tmp=0; } if(tmp!=n)ans=min(ans,tmp); if(ans==inf)cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Long Multiplication 其实就是使 x,y 最接近的，即对每一位判断，把大的给当前小的，小的给当前大的\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s,t; bool cmp(string s,string t){ if(s.size()\u0026gt;t.size())return 1; if(t.size()\u0026gt;s.size())return 0; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]-\u0026#39;0\u0026#39;\u0026gt;t[i]-\u0026#39;0\u0026#39;)return 1; if(s[i]-\u0026#39;0\u0026#39;\u0026lt;t[i]-\u0026#39;0\u0026#39;)return 0; } return 1; } void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; string as,at; as=at=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;s.size();i++){ int l=s[i]-\u0026#39;0\u0026#39;,r=t[i]-\u0026#39;0\u0026#39;; if(l\u0026gt;r)swap(l,r); if(cmp(as,at))swap(as,at); as+=(r+\u0026#39;0\u0026#39;),at+=(l+\u0026#39;0\u0026#39;); } cout\u0026lt;\u0026lt;as\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;at\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Colored Balls 假设当前球的总量为 $x$，当前数量最多的球的数量为 $a_i$，如果 $a_i * 2 \u0026gt; x$，那么当前的值即为 $a_i$，反之，当前的值为 $x/2$。\n题上给出所有球数总和不超过 5000，即可以对所有球的数量的情况计算当前数量为最多数量时，各种球总量对应的方案数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=998244353; int n,a[N]; ll f[N],ans; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); f[0]=1; for(int i=1;i\u0026lt;=n;i++){ int x=a[i]; for(int j=5000;j\u0026gt;x;j--){ ans=(((j+x)/2+(j+x)%2)*f[j]%mod+ans)%mod; if(j+x\u0026lt;=5000)f[j+x]=(f[j+x]+f[j])%mod; } for(int j=x;j\u0026gt;=0;j--){ ans=(ans+f[j]*x%mod)%mod; if(j+x\u0026lt;=5000)f[j+x]=(f[j+x]+f[j])%mod; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe164/","summary":"A. Painting the Ribbon 显然，Alice 的理想操作是每种颜色均匀分布 而 Bob 的理想操作是选择当前数量最多的颜色，将其他的都喷为这个颜色 所以只要判断 k 是否大于 $n-mx$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; if(m==1||k\u0026gt;=n-1){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } int ned=n-ceil(1.0*n/m); if(k\u0026lt;ned)cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Make It Ugly 注意到，操作只会使中间的元素","title":"Educational Codeforces Round 164 (Rated for Div. 2)"},{"content":"A. Catch the Coin 对每个枚硬币分别判断即可\n只要其 y 轴上的距离能够赶上，一定能取到\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int mn=-abs(x),mx=abs(x); if(y-abs(x)+1\u0026lt;mn)cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Substring and Subsequence 只能 $O(n^2)$ 对每一位判断其后方有多少个相同的即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int ans=s.size()+t.size(); for(int i=0;i\u0026lt;t.size();i++){ int tmp=0; for(int j=0;j\u0026lt;s.size() \u0026amp;\u0026amp; i+tmp\u0026lt;t.size();j++){ if(s[j]==t[i+tmp])tmp++; } ans=min(ans,int(s.size()+t.size())-tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Two Movies 某人对两部电影的评价相同时，将这个评价存下，不同时，取评分大的那项，最后将存下的所有评分加给当前小的那项\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,suma,sumb; deque\u0026lt;int\u0026gt;q; void solve(){ suma=sumb=0; q.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(x\u0026gt;y)suma+=x; else if(y\u0026gt;x)sumb+=y; else q.push_back(x); } for(auto x:q){ if(x\u0026gt;0){ if(suma\u0026gt;sumb)sumb++; else suma++; } else{ if(suma\u0026gt;sumb)suma--; else sumb--; } } cout\u0026lt;\u0026lt;min(suma,sumb)\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Smithing Skill 首先易想到贪心，因为锻造后，一定立马熔铸，这样一次消耗 $a_i-b_i$ 的代价\n当 $a_i-b_i$ 相等时，一定选取 $a$ 小的那个操作，这样可以保证操作次数最多\n同时，$a_i-b_i$ 大的物品，其 $a_i$ 应该小于前面的物品，因为如果这个 $a_i$ 更大，一定是选前面的更优\n所以物品其实是单调栈，将其按照 $a_i-b_i$ 从小到大来存，同时 $a_i$ 逐渐递增\n对于栈中物品，我们优先从后取，因为当材料数量大于第一个的 $a$ 时，我们一定取的是第一个\n只有无法取第一个时，我们才会从后面取，每次取时，记录当前买了几件栈中的物品，dp 中存的就是能买几件后面的物品\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e6+7, mod=1e9+7; int n,m; int a[N],b[N]; map\u0026lt;int,int\u0026gt;vis; int c[N]; ll f[N],g[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]; for(int i=1;i\u0026lt;=n;i++){ int x=a[i]-b[i]; if(vis.find(x)==vis.end())vis[x]=a[i]; else vis[x]=min(vis[x],a[i]); } deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;s; for(auto [x,y]:vis){ if(s.empty())s.push_back({x,y}); else{ if(y\u0026gt;=s.back().second)continue; else s.push_back({x,y}); } } int mx=s.front().second,mn=s.back().second,tmp=0; int ta=s.front().second,tb=s.front().second-s.front().first; for(int i=mn;i\u0026lt;=mx;i++){ if(i==s.back().second){ tmp=s.back().first; s.pop_back(); } f[i]=g[i-tmp]+1; g[i]=max(g[i-1],f[i]); } ll ans=0; for(int i=1;i\u0026lt;=m;i++){ int x; cin\u0026gt;\u0026gt;x; if(x\u0026gt;mx){ int ti=(x-tb)/tmp; x-=ti*tmp; ans+=ti; } ans+=f[x]; } cout\u0026lt;\u0026lt;ans*2\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe167/","summary":"A. Catch the Coin 对每个枚硬币分别判断即可 只要其 y 轴上的距离能够赶上，一定能取到 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int mn=-abs(x),mx=abs(x); if(y-abs(x)+1\u0026lt;mn)cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Substring and Subsequence 只能 $O(n^2)$ 对每一位判断其后方有多少个相同的即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int ans=s.size()+t.size(); for(int","title":"Educational Codeforces Round 167 (Rated for Div. 2)"},{"content":"A. Quintomania 照题意模拟下去即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ if(abs(a[i+1]-a[i])!=5\u0026amp;\u0026amp;abs(a[i+1]-a[i])!=7){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Startup 记录每种牌子的总价值，排序后从大到小取\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=2e5+7, mod=1e9+7; struct Node{ ll id,val; bool operator\u0026lt;(const Node \u0026amp;a){return val\u0026gt;a.val;} }; int n,k; int b[N],c[N]; map\u0026lt;int,int\u0026gt;vis; void solve(){ cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;n; vis.clear(); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i]; for(int i=1;i\u0026lt;=n;i++){ vis[b[i]]+=c[i]; } vector\u0026lt;Node\u0026gt;v; for(auto [x,y]:vis){ v.push_back(Node{x,y}); } sort(v.begin(),v.end()); ll ans=0; for(int i=0;i\u0026lt;min(k, (int)v.size());i++){ ans+=v[i].val; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Anya and 1100 每次修改其实只会对临近的几个位置造成影响，只需要统计附近是否增删了 1100 片段即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s; int q; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;q; int n=s.size(); s=\u0026#34; \u0026#34;+s; set\u0026lt;int\u0026gt;st; for(int i=1;i\u0026lt;=n-3;i++){ if(s.substr(i,4)==\u0026#34;1100\u0026#34;)st.insert(i); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(n\u0026lt;4){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; continue; } s[x]=char(\u0026#39;0\u0026#39;+y); // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; for(int i=max(1, x-4); i\u0026lt;=min(n-3, x+4); i++){ if(s.substr(i,4)==\u0026#34;1100\u0026#34;)st.insert(i); else st.erase(i); } if(st.size())cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. I Love 1543 把图一层一层拆分开，对每一层形成的字符串计数即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int n,m,ans; char mp[N][N]; bool vis[N][N]; char x; void getString(int x){ string s=\u0026#34;\u0026#34;; for(int i=x;i\u0026lt;=m-x+1;i++){ if(vis[x][i])break; s+=mp[x][i],vis[x][i]=1; } for(int i=x+1;i\u0026lt;=n-x+1;i++){ if(vis[i][m-x+1])break; s+=mp[i][m-x+1],vis[i][m-x+1]=1; } for(int i=m-x;i\u0026gt;x;i--){ if(vis[n-x+1][i])break; s+=mp[n-x+1][i],vis[n-x+1][i]=1; } for(int j=n-x+1;j\u0026gt;x;j--){ if(vis[j][x])break; s+=mp[j][x],vis[j][x]=1; } int len=s.size(); // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; s=s+s; for(int i=0;i\u0026lt;len;i++){ if(s.substr(i,4)==\u0026#34;1543\u0026#34;)ans++; } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ans=0; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ cin\u0026gt;\u0026gt;x; mp[i][j]=x; vis[i][j]=0; } } for(int i=1;i\u0026lt;=min(n,m);i++){ if(vis[i][i])break; getString(i); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Reverse the Rivers 两个数按位或，只可能变大，那么每个位置都是一个单调递增的序列，易想到通过二分来查找符合的国家\n输出符合条件的最小的国家序号即可\n赛时没发现 l 初始设置为 0 了，连 wa 数发\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e5+7, mod=1e9+7; const ll inf=1e18; int n,k,q,m; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;q; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+10, vector\u0026lt;ll\u0026gt;(k+10)); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=k;j++){ cin\u0026gt;\u0026gt;a[i][j]; a[i][j]|=a[i-1][j]; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s(k + 1); for(int i=1;i\u0026lt;=k;i++)s[i].push_back(0); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=k;j++){ s[j].push_back(a[i][j]); } } while(q--){ cin\u0026gt;\u0026gt;m; int low=1,up=n; for(int i=1;i\u0026lt;=m;i++){ ll r,c; char x; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x\u0026gt;\u0026gt;c; if(x==\u0026#39;\u0026gt;\u0026#39;){ auto l=upper_bound(s[r].begin(),s[r].end(),c)-s[r].begin(); low = max(low, l); } else{ auto l = lower_bound(s[r].begin(), s[r].end(), c) - s[r].begin(); l--; up = min(up, l); } // cout\u0026lt;\u0026lt;low\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;up\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;low\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;up\u0026lt;\u0026lt;endl; if(low \u0026lt;= up) cout \u0026lt;\u0026lt; low \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } F. XORificator 3000 异或前缀和有一个性质\n$f(x)=\\begin{cases}x,x%4=0\\1,x%4=1\\x+1,x%4=2\\0,x%4=3\\end{cases}$\n同时题中另一性质的数: $x≡3\\mod2^4$\n$x=0000011,0001011,0010011,0011011$\n可以看出，后几位是始终不变的，而前面的会递增，也可以使用异或前缀和求出\n即可以先对前面的位数求异或和，再对后面的位数求异或和\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; ll l,r,i,k; ll fc(ll n){ if(n%4==0) return n; if(n%4==1) return 1; if(n%4==2) return n+1; return 0; } ll fx(ll n,ll i,ll k){ if(!i){ if(!k)return fc(n); else return 0; } ll x=1ll\u0026lt;\u0026lt;i; if(n\u0026lt;k) return 0; ll t=(n-k)/x; ll cnt=t+1; ll res=fc(t)\u0026lt;\u0026lt;i; if(cnt%2)res^=k; return res; } void solve() { cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;i\u0026gt;\u0026gt;k; ll s=fc(l-1)^fc(r); ll tmp=fx(r,i,k)^fx(l-1,i,k); ll ans=s^tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf984/","summary":"A. Quintomania 照题意模拟下去即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ if(abs(a[i+1]-a[i])!=5\u0026amp;\u0026amp;abs(a[i+1]-a[i])!=7){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Startup 记录每种牌子的总价值，排序后从大到小取 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=2e5+7, mod=1e9+7; struct Node{ ll id,val; bool operator\u0026lt;(const Node \u0026amp;a){return val\u0026gt;a.val;} }; int n,k; int b[N],c[N]; map\u0026lt;int,int\u0026gt;vis; void solve(){ cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;n; vis.clear(); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i]; for(int i=1;i\u0026lt;=n;i++){ vis[b[i]]+=c[i]; }","title":"Codeforces Round 984 (Div. 3)"},{"content":"L. Recover Statistics 直接按要求输出 100 个数即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; cout\u0026lt;\u0026lt;100\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=50;i++){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=45;i++){ cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=4;i++){ cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;c+1; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } J. Grand Prix of Ballance 按题意模拟即可\n赛时榜歪了，应该直接上机写的\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; struct Node{ int id,flag; ll val; bool operator\u0026lt;(const Node \u0026amp;t){ if(val==t.val)return id\u0026lt;t.id; return val\u0026gt;t.val; } }a[N]; int n,m,q,op,x,id,flag,cnt; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; flag=0; cnt=0; for(int i=1;i\u0026lt;=m;i++)a[i].id=i,a[i].val=0,a[i].flag=0; while(q--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x; if(x\u0026gt;n)continue; flag=x; cnt=0; } else if(op==2){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;x; if(a[id].flag==flag||x!=flag)continue; a[id].flag=flag; a[id].val+=(m-cnt); cnt++; } else{ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;x; if(a[id].flag==flag||x!=flag)continue; a[id].flag=flag; } } sort(a+1,a+1+m); for(int i=1;i\u0026lt;=m;i++){ cout\u0026lt;\u0026lt;a[i].id\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[i].val\u0026lt;\u0026lt;endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } A. Arrow a Row 首先可以确定 No 的情况：第一个为 -；后三个不是 \u0026gt;\u0026gt;\u0026gt;；没有 - 存在\n接着分析如何构造原串\n我们可以每次确定 1 个位置\n后缀确定后基本不会再变动，所以我们先考虑构造后缀，可以先构造出后缀连续的 \u0026gt; 片段，全部从 1 开始，长度逐渐从 n 递减\n接着构造前面的片段，先保证构造的片段不会影响后缀，即选取的箭串 - 不能影响到后缀，即确定了当前构造的长度\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s; deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;q; void solve(){ cin\u0026gt;\u0026gt;s; int n=s.size(); q.clear(); s=\u0026#34; \u0026#34;+s; if(s.substr(n-2,3)!=\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026#34;||s[1]==\u0026#39;-\u0026#39;||s.find(\u0026#39;-\u0026#39;)==-1){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } cout\u0026lt;\u0026lt;\u0026#34;Yes \u0026#34;; int cnt=0; for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;)cnt++; else break; } for(int i=n;i\u0026gt;n-cnt+3;i--){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;){ q.push_back({1,i}); } else break; } int r=n-cnt+3; for(int i=1;i\u0026lt;r-2;i++){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;){ q.push_back({i,r-i+1}); } } cout\u0026lt;\u0026lt;q.size()\u0026lt;\u0026lt;endl; for(auto [x,y]:q){ cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G. Expanding Array 赛时被卡太久了，不然真感觉银有望\n队友已经手玩出最多 8 种可能，但当时想复杂了\n实际上确实只有这么多可能\n某位上有 0,1 时，二者都可以取，只有 1 时只能进行异或操作，只有 0 时怎么操作都不会产生变化\n所以可以选取 011,101 两个数，看怎样操作才能取得所有的可能\n假设二者为 x,y\n首先是二者本身 x,y\n接着是 x^y x|y x\u0026amp;y\n然后是 x|(x^y) y|(x^y)\n最后是 (x^y)^(x^y) 即为 0\n依次插入一个 set 中即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int n; set\u0026lt;int\u0026gt;s; int a[N]; void solve() { cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ s.insert(a[i]); s.insert(a[i+1]); s.insert(a[i]^a[i+1]); s.insert((a[i]^a[i+1])\u0026amp;a[i]); s.insert((a[i]^a[i+1])\u0026amp;a[i+1]); s.insert(a[i]|a[i+1]); s.insert(a[i]\u0026amp;a[i+1]); s.insert(0); } cout\u0026lt;\u0026lt;s.size()\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } I. Good Partitions 找原数组中的不下降的片段，可以将每个片段的终止位置储存起来，此时的答案就是所有片段长度的 gcd 的因子个数\n常见的维护区间 gcd 是使用线段树，统计因子个数采用埃氏筛即可\n修改时同步 update 即可使 tr[1] 中始终存储为所有片段的 gcd\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int tr[N\u0026lt;\u0026lt;2]; int n,q,a[N],x,v,cf[N],phi[N]; void init(int n){ for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ phi[j*i]++; } } } void update(int now){ tr[now]=__gcd(tr[ls],tr[rs]); } void build(int now,int l,int r){ if(l==r){ if(cf[l]\u0026lt;0){ tr[now]=l; } else tr[now]=0; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void modify(int now,int l,int r,int val,int pos){ if(l==r){ if(val\u0026gt;=0){ tr[now]=0; } else tr[now]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid){ modify(ls,l,mid,val,pos); } else modify(rs,mid+1,r,val,pos); update(now); } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++)cf[i]=a[i+1]-a[i]; if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; while(q--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } return; } build(1,1,n-1); int ans=abs(tr[1]); if(n==1||ans==0)cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;phi[ans]\u0026lt;\u0026lt;endl; while(q--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; a[x]=v; if(x\u0026gt;1)modify(1,1,n-1,a[x]-a[x-1],x-1); if(x\u0026lt;n)modify(1,1,n-1,a[x+1]-a[x],x); if(n==1){ cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; continue; } ans=abs(tr[1]); if(!ans){ cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;phi[ans]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(N); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Athlete Welcome Ceremony 找出所有的可行方案，再利用前缀和求出当前所给的选择的总和即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 3e2 + 5, mod = 1e9 + 7; int n, q, x, y, z; string s; ll dp[2][N][N][4], f[N][N]; map\u0026lt;char, int\u0026gt; tr; int cnt = 0; void init() { if (s[1] == \u0026#39;?\u0026#39;) { dp[1 % 2][1][0][1] = 1; dp[1 % 2][0][1][2] = 1; dp[1 % 2][0][0][3] = 1; cnt++; } else { dp[1 % 2][0][0][tr[s[1]]] = 1; } for (int i = 2; i \u0026lt;= n; i++) { memset(dp[i % 2], 0, sizeof(dp[i % 2])); // 清零当前 dp 层 if (s[i] == \u0026#39;?\u0026#39;) cnt++; for (int j = 0; j \u0026lt;= i; j++) { for (int k = 0; j + k \u0026lt;= i; k++) { if (s[i] == \u0026#39;?\u0026#39;) { // 对于 \u0026#39;?\u0026#39;, 更新状态时考虑所有字符 for (int l = 1; l \u0026lt;= 3; l++) { int x, y; if (l == 1) x = 2, y = 3; else if (l == 2) x = 1, y = 3; else x = 1, y = 2; if (j - (l == 1) \u0026lt; 0 || k - (l == 2) \u0026lt; 0) continue; dp[i % 2][j][k][l] = (dp[i % 2][j][k][l] + dp[(i + 1) % 2][j - (l == 1)][k - (l == 2)][x] + dp[(i + 1) % 2][j - (l == 1)][k - (l == 2)][y]) % mod; } } else { int x = tr[s[i]]; for (int l = 1; l \u0026lt;= 3; l++) { if (l != x) { dp[i % 2][j][k][x] = (dp[i % 2][j][k][x] + dp[(i + 1) % 2][j][k][l]) % mod; } } } } } } // 构建 f 数组（合法三维前缀和） for (int i = 0; i \u0026lt;= cnt; i++) { for (int j = 0; j + i \u0026lt;= cnt; j++) { f[i][j] = 0; for (int k = 1; k \u0026lt;= 3; k++) { f[i][j] = (f[i][j] + dp[n % 2][i][j][k]) % mod; } } // 计算前缀和 for (int j = 1; i + j \u0026lt;= cnt; j++) { f[i][j] = (f[i][j] + f[i][j - 1]) % mod; } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; s = \u0026#34; \u0026#34; + s; // 字符串下标从1开始 init(); while (q--) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; ll ans = 0; // 处理查询，计算合法的三维前缀和 for (int i = 0; i \u0026lt;= x; i++) { int j = cnt - z - i; if (i \u0026gt; cnt) break; if (j \u0026gt; y) continue; j = max(0, j); j = min(j, cnt - i); ans = (ans + f[i][min(y, cnt - i)] - (j \u0026gt; 0 ? f[i][j - 1] : 0) + mod) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; tr[\u0026#39;a\u0026#39;] = 1, tr[\u0026#39;b\u0026#39;] = 2, tr[\u0026#39;c\u0026#39;] = 3; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/icpc2024chengdu/","summary":"L. Recover Statistics 直接按要求输出 100 个数即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; cout\u0026lt;\u0026lt;100\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=50;i++){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=45;i++){ cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=4;i++){ cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;c+1; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } J. Grand Prix of Ballance 按题意模拟即可 赛时榜歪了，应该直接上机写的 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt;","title":"ICPC2024chengdu"},{"content":"牛魔的 vs code 刚开场就炸了，debug 纯靠输出在调\nL - 附加题1 读题可发现，只有相邻的会有干扰，那么除了第一个是 k 种可能，其他的都是 (k-1) 种选择\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e5+7, mod=1e9+7; int ans=0,n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; ans=k; for(int i=2;i\u0026lt;=n;i++){ ans*=(k-1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - SYease 开始想用 dp 暴力写，喜提超时，然后暴力选最佳选项，再用剩余钱替换一部分片段，也错，但是达到了 28/30 误导了好久，以为这个是正解\n实际上就是先用最小价值确定长度，再用剩余的钱看从 9 到 0 能换几个比最小价值选项大的\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e6+7, mod=1e9+7; int n; void solve(){ cin\u0026gt;\u0026gt;n; int mn=10000000,pos=-1; for(int i=1;i\u0026lt;=9;i++){ cin\u0026gt;\u0026gt;c[i].x; if(mn\u0026gt;=c[i].x){ mn=c[i].x; pos=i; } c[i].id=i; } int len=n/mn; int lft=n-len*mn; if(!len){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return; } int cnt[10]={0}; memset(cnt,0,sizeof(cnt)); cnt[pos]=len; for(int i=9;i\u0026gt;=1;i--){ if(i\u0026lt;=pos)break; int tmp=c[i].x-mn; if(tmp\u0026lt;=lft){ int t=lft/tmp; if(t\u0026gt;cnt[pos])break; cnt[i]=t; cnt[pos]-=t; lft-=t*tmp; } } for(int i=9;i\u0026gt;0;i--){ for(int j=1;j\u0026lt;=cnt[i];j++)cout\u0026lt;\u0026lt;i; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G - dyfhpu 要保证操作后数最小，且不能有先导零，其实就是在 k+1 前找最小的首位即可，再在后面开一个单调栈即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; string s; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;k; n=s.size(); int st=1e9; for(int i=0;i\u0026lt;=k;i++){ if(s[i]-\u0026#39;0\u0026#39;\u0026gt;0){ st=min(st,s[i]-\u0026#39;0\u0026#39;); } } int pos=-1; for(int i=0;i\u0026lt;n;i++){ if(s[i]-\u0026#39;0\u0026#39;==st){ pos=i; break; } else{ k--; } } deque\u0026lt;int\u0026gt;q; q.push_back(st); for(int i=pos+1;i\u0026lt;n;i++){ int t=s[i]-\u0026#39;0\u0026#39;; while(q.size()\u0026gt;1\u0026amp;\u0026amp;t\u0026lt;q.back()\u0026amp;\u0026amp;k){ k--; q.pop_back(); } q.push_back(t); } while(k){ q.pop_back(); k--; } for(int x:q)cout\u0026lt;\u0026lt;x; cout\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E - LAING2122 正解比题短系列\n首先注意到 w \\lep 10^6 同时可以选 300 个数，最多用 3 个数来组合\n一个六位数，平均分成三份后，每份都是一个两位数，那么只要把从 1 ~ 100 的 i i100 i10000 都加进去就行了\n这样就能组合出所有的六位数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int w; vector\u0026lt;int\u0026gt;ans; void solve(){ cin\u0026gt;\u0026gt;w; cout\u0026lt;\u0026lt;300\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=100;i++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i*100\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i*10000\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D - haowen521 找给出的数组中的递增片段有几个，每个片段都可以接到上一层的一个节点上，这样接就是最低层数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; int a[N] = {0}; vector\u0026lt;int\u0026gt;seg; void solve(){ seg.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int k=1; for(int i=3;i\u0026lt;=n;i++){ if(a[i]\u0026lt;a[i-1]){ seg.push_back(k); k=1; } else{ k++; } } seg.push_back(k); int now=1; int tmp=1,nxt=0; for(auto x:seg){ if(!tmp){ tmp=nxt; now++; nxt=0; } tmp--; nxt+=x; } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } K - XingRin 赛时写了个 O(n^2 \\log n) 的，但是遇到相同的数时会变 O(n^3 \\log n)\n可以记录每个位置前某个数的出现次数\n这样就可以枚举 j,k 的位置，然后找 j 前方 a[k] 出现了多少和 k 后方 a[j] 出现的次数\nO(N^2) 即可通过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e3+7, mod=1e9+7; int n; int s[N][N],a[N]; ll ans=0; void solve(){ ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; for(int j=1;j\u0026lt;=n;j++){ s[i][j]=s[i-1][j]; } s[i][a[i]]++; } for(int i=2;i\u0026lt;=n;i++){ for(int j=i+1;j\u0026lt;n;j++){ ans+=(s[i-1][a[j]])*(s[n][a[i]]-s[j][a[i]]); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } M - 附加题2 很眼熟，之前应该写过这种的来着，要加强补题\n注意到 k\u0026lt;20 那我们只需要对每个位置开一个 set 最多存 20 个元素即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,q,a[N]; vector\u0026lt;int\u0026gt;edge[N]; multiset\u0026lt;int\u0026gt;s[N]; void dfs(int now,int fa){ for(auto x:edge[now]){ if(x==fa)continue; s[now].insert(a[x]); if(s[now].size()\u0026gt;20)s[now].erase(s[now].begin()); dfs(x,now); } if (fa != 0) { for(auto x:s[now]){ s[fa].insert(x); if(s[fa].size()\u0026gt;20)s[fa].erase(s[fa].begin()); } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); for(int i=1;i\u0026lt;=n;i++){ s[i].insert(a[i]); } while(q--){ int v,k; cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;k; if (k \u0026gt; s[v].size()) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { auto ans = s[v].rbegin(); advance(ans, k-1); cout \u0026lt;\u0026lt; *ans \u0026lt;\u0026lt; endl; } } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H - guohaonan 易发现可以将两个数组拼接起来，a 在前，b 在后，保证整个数组是不降的，那么就是求 n 种数排列成单调不降的方案数，用 dp 跑即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m; ll f[25][N],sum[25][N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)f[1][i]=1,sum[1][i]=i; ll ans=0; m*=2; for(int i=2;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ f[i][j]=sum[i-1][j]; sum[i][j]=((sum[i][j-1]+f[i][j])%mod+mod)%mod; } } for(int i=1;i\u0026lt;=n;i++)ans=((ans+f[m][i])%mod+mod)%mod; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/hpuacm1103/","summary":"牛魔的 vs code 刚开场就炸了，debug 纯靠输出在调 L - 附加题1 读题可发现，只有相邻的会有干扰，那么除了第一个是 k 种可能，其他的都是 (k-1) 种选择 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e5+7, mod=1e9+7; int ans=0,n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; ans=k; for(int i=2;i\u0026lt;=n;i++){ ans*=(k-1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - SYease 开始想用 dp 暴力写，喜提超时，然后暴","title":"Hpuacm1103"},{"content":"牛魔的渣机 ChromeBook\nA. Circuit 每盏灯对应的开关有一个为 on 时是亮的，其他时候都为熄灭\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int off,on; void solve(){ cin\u0026gt;\u0026gt;n; on=off=0; for(int i=1;i\u0026lt;=2*n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x==1)on++; else off++; } int ans1=0,ans2=0; if(on\u0026lt;=n)ans2=on; else{ ans2=n-(on-n); } ans1=n-on/2-off/2; cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Medians 开始题没看完，分的区间长度也必须全为奇数，能分的都分成三个即可，再考虑如果左右的个数为偶数应该往哪个区间加一即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(n==1\u0026amp;\u0026amp;k==1){ cout\u0026lt;\u0026lt;\u0026#34;1\\n1\\n\u0026#34;; return; } if(k==1||k==n){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl; int l=k-1,r=n-k,ans=k,ans2=k+1; if(l%2==0)ans--; if(r%2==0)ans2++; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Trinity 开始暴力两端，显然不全面\n应该考虑每个位置作为中值的可能，再对这个值进行二分查找左右有多少个需要改的即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=2e5+8, mod=1e9+7; int n; int a[N]; int bs1(int x,int y){ int l=1,r=n,ans=0; if(x+y\u0026gt;a[n])return n+1; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(x+y\u0026lt;=a[mid])r=mid-1,ans=mid; else l=mid+1; } return ans; } int bs2(int x){ int l=1,r=n,ans=0; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(a[mid]+a[mid+1]\u0026lt;=x)l=mid+1,ans=mid; else r=mid-1; } return ans; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); int ans=1e9; a[0]=a[1]; a[n+1]=a[n]; for(int i=1;i\u0026lt;=n;i++){ int l=bs1(a[i],a[i-1]); int r=bs2(a[l-1]); r=min(i-1,r); l=n-l+1; ans=min(ans,l+r); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Genokraken 注意到，删边之后的森林都是链，且这条链的根节点不能改变\n同时，$p_i$ 是单调递增的\n可以发现，开一个队列，记录当前的叶节点，如果最小的叶节点和 $i$ 的询问是 $0$，那么将 $i$ 接到这个叶节点下即可\n如果这个询问为 $1$，那么删掉最小的这个叶节点，向后继续询问，直到有询问为 $0$ 的，将其接上即可\n实际上只对每个节点访问了一次 $O(n)$，同时询问量只有 $O(n)$ 次，因为我们的询问是靠队列中的元素来进行的，每次询问会删掉一个，实际上最多每个节点被询问了一次\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 // #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int ans[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ ans[i]=0; } deque\u0026lt;int\u0026gt;q; q.push_back(1); for(int i=2;i\u0026lt;n;i++){ printf(\u0026#34;? %d %d\\n\u0026#34;,q.front(),i); int x; cin\u0026gt;\u0026gt;x; if(x\u0026amp;\u0026amp;!ans[i-1]){ ans[i]=0; q.push_back(i); continue; } while(x){ q.pop_front(); printf(\u0026#34;? %d %d\\n\u0026#34;,q.front(),i); cin\u0026gt;\u0026gt;x; } ans[i]=q.front(); q.pop_front(); q.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;; for(int i=1;i\u0026lt;n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; fflush(stdout); } int main(){ // ios::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf983/","summary":"牛魔的渣机 ChromeBook A. Circuit 每盏灯对应的开关有一个为 on 时是亮的，其他时候都为熄灭 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int off,on; void solve(){ cin\u0026gt;\u0026gt;n; on=off=0; for(int i=1;i\u0026lt;=2*n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x==1)on++; else off++; } int ans1=0,ans2=0; if(on\u0026lt;=n)ans2=on; else{ ans2=n-(on-n); } ans1=n-on/2-off/2; cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Medians 开始题没看完，分的区间长度也必须全为奇数，能分的都分成三个即可，再考虑如果左右的个","title":"Codeforces Round 983 (Div. 2)"},{"content":"A. Strong Password 只需要在相邻字母相同的位置插入一个不同的即可，如果没有这种位置，就在字符串末尾插入一个与当前末尾不同的字符即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve() { string s, ans; cin \u0026gt;\u0026gt; s; int pos = -1; for (int i = 1; i \u0026lt; s.size(); i++) { if (s[i] == s[i - 1]) { pos = i; break; } } if (pos == -1) { ans = s + (s[s.size() - 1] == \u0026#39;a\u0026#39; ? \u0026#39;b\u0026#39; : \u0026#39;a\u0026#39;); } else { if (s[pos] == \u0026#39;a\u0026#39;) ans = s.substr(0, pos) + \u0026#34;b\u0026#34; + s.substr(pos, s.size() - pos); else ans = s.substr(0, pos) + \u0026#34;a\u0026#34; + s.substr(pos, s.size() - pos); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Make Three Regions 初始时只会有一个联通块，且只有两行，那么要把它分为 3 块，只能找\n这种形状的区域\n只需要枚举找到即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; string s; int a[3][N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=2;i++){ cin\u0026gt;\u0026gt;s; for(int j=0;j\u0026lt;n;j++){ a[i][j+1]=(s[j]==\u0026#39;.\u0026#39;?1:-1); } } int ans=0; for(int i=2;i\u0026lt;n;i++){ if(a[1][i-1]==-1\u0026amp;\u0026amp;a[1][i]==1\u0026amp;\u0026amp;a[1][i+1]==-1\u0026amp;\u0026amp;a[2][i-1]==1\u0026amp;\u0026amp;a[2][i]==1\u0026amp;\u0026amp;a[2][i+1]==1)ans++; else if(a[2][i-1]==-1\u0026amp;\u0026amp;a[2][i]==1\u0026amp;\u0026amp;a[2][i+1]==-1\u0026amp;\u0026amp;a[1][i-1]==1\u0026amp;\u0026amp;a[1][i]==1\u0026amp;\u0026amp;a[1][i+1]==1)ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Even Positions 先填充右括号，把已有的左括号全对应上，再全部填充左括号即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; int cnt=0,ans=0; for(int i=1;i\u0026lt;n;i+=2){ if(s[i]==\u0026#39;(\u0026#39;)cnt++; } for(int i=0;i\u0026lt;n;i+=2){ if(i\u0026amp;\u0026amp;s[i-1]==\u0026#39;(\u0026#39;\u0026amp;\u0026amp;cnt)s[i]=\u0026#39;)\u0026#39;; else s[i]=\u0026#39;(\u0026#39;; } // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; deque\u0026lt;int\u0026gt;q; for(int i=0;i\u0026lt;n;i++){ if(s[i]==\u0026#39;(\u0026#39;)q.push_back(i); else ans+=(i-q.front()),q.pop_front(); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Maximize the Root 要使根节点最大，就要使子节点都趋近一个值，从而使根节点加 $1$ 的操作最多\n用 $dfs$ 向下查找每个子树中的最小值 $mn$，当前根如果比 $mn$ 小，那就需要先对这个根进行几次操作，平衡 $mn$ 之后再向上，如果当前根大于 $mn$，将其视作 $mn$ 即可\n最后答案即为 $a[1] + mn$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long vector\u0026lt;int\u0026gt;g[300001]; vector\u0026lt;int\u0026gt;a(300001); void dfs(int x){ int mn=1e16; for(auto u:g[x]){ dfs(u); mn=min(mn,a[u]); } if(mn==1e16)return; if(x==1){a[1]+=mn;return;} if(a[x]\u0026lt;mn)a[x]=(a[x]+mn)/2; else a[x]=mn; } void solve(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; g[i].clear(); } for(int i=2;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; g[x].push_back(i); } dfs(1); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;endl; } signed main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Level Up 200+ 测试点，哈人\n没有修改的操作，所以可以想到预处理\n对于每一只怪兽，在 $k\u0026gt;x$ 时，他一定不逃跑，这个 $x$ 即为对应的阀值\n在求阀值的过程中，可以采用二分答案来查询先前有多少个下标满足条件\n即用权值线段树，看当前 $k$ 出现了多少次\n每次计算得到一个阀值 $x$ 后，将 $x-\u0026gt;n$ 整体加一\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int tr[N\u0026lt;\u0026lt;2]; int a[N],n,k,id,q,b[N]; void build(int now,int l,int r){ if(l==r){ tr[now]=0; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); } void pushdown(int now){ if(tr[now]){ tr[ls]+=tr[now]; tr[rs]+=tr[now]; tr[now]=0; } } void change(int now,int l,int r,int s,int t,int val){ if(s\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=t){ tr[now]+=val; return; } pushdown(now); int mid=(l+r)\u0026gt;\u0026gt;1; if(s\u0026lt;=mid)change(ls,l,mid,s,t,val); if(t\u0026gt;mid)change(rs,mid+1,r,s,t,val); } int query(int now,int l,int r,int id){ if(l==r)return tr[now]; pushdown(now); int mid=(l+r)\u0026gt;\u0026gt;1; if(id\u0026lt;=mid)return query(ls,l,mid,id); else return query(rs,mid+1,r,id); } void solve(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } build(1, 1, n); change(1,1,n,1,n,1); for(int i=2;i\u0026lt;=n;i++){ int l=1,r=n,ans=0; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(query(1,1,n,mid)/mid+1\u0026gt;a[i])l=mid+1; else ans=mid,r=mid-1; } b[i]=ans; change(1,1,n,ans,n,1); } while (q--) { cin \u0026gt;\u0026gt; id \u0026gt;\u0026gt; k; if(b[id]\u0026lt;=k)cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe168/","summary":"A. Strong Password 只需要在相邻字母相同的位置插入一个不同的即可，如果没有这种位置，就在字符串末尾插入一个与当前末尾不同的字符即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve() { string s, ans; cin \u0026gt;\u0026gt; s; int pos = -1; for (int i = 1; i \u0026lt; s.size(); i++) { if (s[i] == s[i - 1]) { pos = i; break; } } if (pos == -1) { ans = s + (s[s.size() - 1] == \u0026#39;a\u0026#39; ? \u0026#39;b\u0026#39; : \u0026#39;a\u0026#39;); } else { if (s[pos] == \u0026#39;a\u0026#39;) ans = s.substr(0, pos) + \u0026#34;b\u0026#34; + s.substr(pos, s.size() - pos); else ans = s.substr(0, pos)","title":"Educational Codeforces Round 168 (Rated for Div. 2)"},{"content":"A. Closest Point 可以发现只有两个点且二者不相邻的时候才有答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+1+n); if(n\u0026gt;2){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else{ if(a[1]+1==a[2])cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Game with Doors 相交片段的门一定都要关上，如果两端不重合就多关一扇\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int l, r, L, R; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int ans = min(r, R) - max(l, L); if (ans \u0026lt; 0) { ans = 1; } else { ans += (l != L); ans += (r != R); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Splitting Items 都取最优手段，那么都是拿当前最大值的物品，降序排序后，Bob 只能利用当前的 k 去弥补与 Alice 上一次拿的物品的差距，即最大只能和 Alice 拿的物品相同\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,k; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+1+n,greater\u0026lt;int\u0026gt;()); ll ali,bob; ali=bob=0; for(int i=1;i\u0026lt;=n;i+=2){ ali+=a[i]; if(i+1\u0026lt;=n){ bob+=a[i+1]; int de=a[i]-a[i+1]; if(k\u0026gt;=de)bob+=de,k-=de; else bob+=k,k=0; } } cout\u0026lt;\u0026lt;ali-bob\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Colored Portals 如果两个城市有交点，那么答案就是二者的距离之差\n如果二者没有交点，就要找点最近的传送城市\n例如用 $1, 2, 3, 4$ 来代表颜色，一城市位于 $1, 2$ 另一城市位于 $3, 4$，那么二者只需要传送到另一个不和本身相同的城市即可，如 $1$ 传送到 $1, 3$ 此时即可完成任务，只需要考虑代价最小的传送方案即可\n开两个数组 $pre,suf$ 来代表某个城市向前和向后传送的最小代价，计算代价时只需要结合考虑即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) const int N=2e5+7, mod=1e9+7; const int inf=1e9; int n,q,l,r; int pre[N],suf[N]; string s[N]; map\u0026lt;string,int\u0026gt;mp; vector\u0026lt;string\u0026gt;v; string rs(string s){ if(s==\u0026#34;BG\u0026#34;)return \u0026#34;RY\u0026#34;; if(s==\u0026#34;BR\u0026#34;)return \u0026#34;GY\u0026#34;; if(s==\u0026#34;GR\u0026#34;)return \u0026#34;BY\u0026#34;; if(s==\u0026#34;RY\u0026#34;)return \u0026#34;BG\u0026#34;; if(s==\u0026#34;GY\u0026#34;)return \u0026#34;BR\u0026#34;; if(s==\u0026#34;BY\u0026#34;)return \u0026#34;GR\u0026#34;; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; pre[i]=0; suf[i]=1e9; } mp.clear(); for(int i=1;i\u0026lt;=n;i++){ for(auto x:v){ if(x!=rs(s[i])\u0026amp;\u0026amp;s[i]!=x)pre[i]=max(pre[i],mp[x]); } mp[s[i]]=i; } mp.clear(); for(int i=n;i\u0026gt;0;i--){ for(auto x:v){ if(x!=rs(s[i])\u0026amp;\u0026amp;s[i]!=x)suf[i]=min(suf[i],(mp[x]==0?inf:mp[x])); } mp[s[i]]=i; } while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if(l\u0026gt;r)swap(l,r); if(rs(s[l])!=s[r])cout\u0026lt;\u0026lt;r-l\u0026lt;\u0026lt;endl; else{ int ans=1e9; if(pre[l]!=0)ans=min(r-pre[l]+l-pre[l],ans); if(suf[r]!=1e9)ans=min(suf[r]-r+suf[r]-l,ans); if(pre[r]!=0){ if(pre[r]\u0026gt;=l)ans=min(r-l,ans); if(pre[r]\u0026lt;=l)ans=min(r-pre[r]+l-pre[r],ans); } if(suf[l]!=1e9){ if(suf[l]\u0026lt;=r)ans=min(r-l,ans); if(suf[l]\u0026gt;=r)ans=min(suf[l]-r+suf[l]-l,ans); } if(ans==1e9)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); v.push_back(\u0026#34;BG\u0026#34;); v.push_back(\u0026#34;BR\u0026#34;); v.push_back(\u0026#34;GR\u0026#34;); v.push_back(\u0026#34;GY\u0026#34;); v.push_back(\u0026#34;RY\u0026#34;); v.push_back(\u0026#34;BY\u0026#34;); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Not a Nim Problem 一眼顶针，鉴定为打表，打表后发现偶数都为 $0$，同时质数是依次递增，奇数非质的 $sg$ 值是它最小的质数因子的 $sg$ 值\n只需要预处理所有的 $sg$ 值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e7+7, mod=1e9+7; bool prime[N]; int sg[N],mn[N]; int n,x; void init(int n){ memset(prime, false, sizeof(prime)); memset(mn, 0, sizeof(mn)); prime[0] = prime[1] = true; for(int i = 2; i \u0026lt;= n; i++){ if(!prime[i]){ for(int j = i * 2; j \u0026lt;= n; j += i){ mn[j]=(mn[j]==0?i:mn[j]); prime[j] = true; } } } } void init2(int n){ int now=2; sg[0]=0,sg[1]=1,sg[2]=0; for(int i=3;i\u0026lt;=n;i++){ if(i\u0026amp;1){ if(!prime[i])sg[i]=now++; else{ sg[i]=sg[mn[i]]; } } else sg[i]=0; } } void solve(){ cin\u0026gt;\u0026gt;n; int ans=0; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=sg[x]; } if(!ans)cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(N); init2(N); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe169/","summary":"A. Closest Point 可以发现只有两个点且二者不相邻的时候才有答案 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+1+n); if(n\u0026gt;2){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else{ if(a[1]+1==a[2])cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Game with Doors 相交片段的门一定都要关上，如果两端不重合就多关一扇 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll;","title":"Educational Codeforces Round 169 (Rated for Div. 2)"},{"content":"A. Perpendicular Segments 两条线取边长为 $min(x,y)$ 的正方形的对角线即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y,k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; x=min(x,y); printf(\u0026#34;0 0 %d %d\\n\u0026#34;,x,x); printf(\u0026#34;%d 0 0 %d\\n\u0026#34;,x,x); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Black Cells 易发现，个数为偶数时，答案即为相邻两个差的最大值\n个数为奇数时，需要借用一个格子，可以在每个奇数位后插入一个，计算当前数组中的相邻差的最大值\n因为数据范围很小，可以直接进行 $O(n^2)$ 的算法，即\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; set\u0026lt;ll\u0026gt;s; ll a[N]; void solve(){ s.clear(); bool flag=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s.insert(a[i]); } if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; return; } ll ans=-1; for(int i=1;i\u0026lt;n;i+=2){ ans=max(ans,a[i+1]-a[i]); } if(n%2==0){ cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=n;i+=2){ if(a[i+1]==a[i]+1)continue; s.insert(a[i]+1); ll tmp=-1; for(auto it=s.begin(); it!=s.end()\u0026amp;\u0026amp;next(it)!=s.end(); ++it,++it){ // cout\u0026lt;\u0026lt;*next(it)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;endl; tmp = max(tmp, *next(it) - *it); } ans = min(ans, tmp); s.erase(a[i]+1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Action Figures 可以把为 1 的位置全部塞入一个栈中\n反过来查找，遇到 0 的话，就看当前栈顶的元素是否比他大，如果比他大，说明栈顶这个元素可以 free\n直到没有 0 开始对栈内元素考虑，如果栈内元素的个数大于 2 那么就可以用栈底元素来使栈顶元素 free\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; string s; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; deque\u0026lt;int\u0026gt;q; ll ans=0; s=\u0026#34; \u0026#34;+s; for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;1\u0026#39;)q.push_back(i); } for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;0\u0026#39;){ if(!q.empty()\u0026amp;\u0026amp;i\u0026lt;q.front())q.pop_front(); ans+=i; } } while(!q.empty()){ ans+=q.back(); q.pop_back(); if(!q.empty())q.pop_front(); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Sums of Segments 设\n$s[i]$ 为 $a[i]$ 的前缀和， $u[i]$ 为 $s[i]$ 的前缀和， $t[i]$ 为分块后的第 $i$ 块的和， $ts[i]$ 为分块后的前缀和 易得出 $b$ 中第 $k$ 块的个数为 $n-k+1$\n所以前 $k$ 块的总数为 $nk-k(k-1)/2$\n总数为单调递增，我们就可以利用二分找到 $l,r$ 对应的块数，假设分别为 $x,y$\n此时 $ans=ts[y]-ts[x]$，但是会有些多加的片段\n此时就需要找到 $l,r$ 在所属块中的第几个\n可以假设 $l$ 对应的是 $s(x,z)$，这一块上最后的元素是 $s(x,n)$，所以 $n-z=xn-\\frac{x(x-1)}2-l$，通过此式找到 $z$ 的值，只需要减掉 $s(x,1)$ 到 $s(x,z-1)$ 的值即可\n同理可以找到 $r$ 多加的片段\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int n,q,l,r; ll a[N],s[N],u[N],t[N],ts[N]; ll x,y,z,v; ll bs(int x){ ll l=1,r=n,ans=1; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if((n*mid-mid*(mid-1)/2)\u0026lt;x)l=mid+1; else r=mid-1,ans=mid; } return ans; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i]; u[i]=u[i-1]+s[i]; } for(int i=n;i\u0026gt;0;i--){ t[i]=t[i+1]+(n-i+1)*a[i]; } for(int i=1;i\u0026lt;=n;i++){ ts[i]=ts[i-1]+t[i]; } cin\u0026gt;\u0026gt;q; while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; x=bs(l),y=bs(r); ll ans=ts[y]-ts[x-1]; z=n-(x*n-x*(x-1)/2-l); v=n-(y*n-y*(y-1)/2-r); ans-=u[z-1]-u[x-1]-(z-x)*s[x-1]; ans-=u[n]-u[v]-s[y-1]*(n-v); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe171/","summary":"A. Perpendicular Segments 两条线取边长为 $min(x,y)$ 的正方形的对角线即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y,k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; x=min(x,y); printf(\u0026#34;0 0 %d %d\\n\u0026#34;,x,x); printf(\u0026#34;%d 0 0 %d\\n\u0026#34;,x,x); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Black Cells 易发现，个数为偶数时，答案即为相邻两个差的最大值 个数为奇数时，需要借用一个格子，可以在每个奇数位后插入一个，计算当前数组中的相邻差","title":"Educational Codeforces Round 171"},{"content":"A. Rectangle Arrangement 最长和最高相加乘二即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; int mx,my; mx=my=-1; for(int i=1;i\u0026lt;=n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; mx=max(mx,x); my=max(my,y); } cout\u0026lt;\u0026lt;(mx+my)*2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Stalin Sort $n\\leq2000$ 直接 $O(n^2)$ 查找当前位后有几个比他大的，都删去\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ int ans=INT_MAX; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } for(int i=1;i\u0026lt;=n;i++){ int tmp=i-1; for(int j=i+1;j\u0026lt;=n;j++){ if(a[j]\u0026gt;a[i])tmp++; } ans=min(tmp,ans); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Add Zeros 观察题目发现 $a_i = |a| + 1 - i$ 中的 $|a|$ 并不会改变，那么只需要考虑当前数组长度即可，将所有 $i$ 对应的 $|a|$ 找到，相同的存入同一数组，用 $dfs$ 暴力查找即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; ll n; ll a[N]; ll ans; map\u0026lt;ll,vector\u0026lt;ll\u0026gt;\u0026gt;vis; set\u0026lt;ll\u0026gt; visited; void dfs(ll now){ if (visited.count(now)) return; visited.insert(now); ans=max(ans,now); if(vis.find(now) != vis.end()){ for(ll x:vis[now]){ dfs(now+x-1); } } } void solve(){ ans=-1; vis.clear(); visited.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++){ vis[a[i] + i - 1].push_back(i); } dfs(n); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D1. The Endspeaker (Easy Version) 多种操作完成某个目标的最小代价，可以考虑 DP\n设 $dp_{i,j}$ 为对于前 $i$ 个数组，使用第 $j$ 总操作的最小代价\n易得转移方程 $dp[i][j]= \\text{min}{dp[p][k]}+m-j,\\text{sum}[p,i]\\le b[j],1\\le k\\le j,1\\le p\\le i$\n显然可以将第一维优化掉，我们只需要通过当前操作能到达 $n$ 即可，可以用后面的操作覆盖前面的\n现在的优化难点在于 $p$ 如何确定\n其实转移过程就是通过一个滑动窗口来进行实时更新，我们可以用双指针来完成这个操作\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; const int inf=1e9; int n,m; ll a[N],b[N],s[N],mx; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; mx=-1; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i]; mx=max(mx,a[i]); } for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;b[i]; if(mx\u0026gt;b[1]){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } vector\u0026lt;int\u0026gt; dp(n+10,inf); dp[0]=0; for(int i=1;i\u0026lt;=m;i++){ int l=0,r=1; while(r\u0026lt;=n){ while(l\u0026lt;r\u0026amp;\u0026amp;s[r]-s[l]\u0026gt;b[i])l++; if(l\u0026lt;r)dp[r]=min(dp[r],dp[l]+m-i); r++; } } cout\u0026lt;\u0026lt;dp[n]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf982/","summary":"A. Rectangle Arrangement 最长和最高相加乘二即为答案 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; int mx,my; mx=my=-1; for(int i=1;i\u0026lt;=n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; mx=max(mx,x); my=max(my,y); } cout\u0026lt;\u0026lt;(mx+my)*2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Stalin Sort $n\\leq2000$ 直接 $O(n^2)$ 查找当前位后有几个比他大的，都删去 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ int ans=INT_MAX; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } for(int i=1;i\u0026lt;=n;i++){ int tmp=i-1; for(int j=i+1;j\u0026lt;=n;j++){ if(a[j]\u0026gt;a[i])tmp++; }","title":"Codeforces Round 982 (Div. 2)"},{"content":"C. A TRUE Battle 如果开头和结尾有 $1$，那么一定 Alice 胜\n如果中间有相邻的两个 $1$，那么 Alice 可以先选这俩中间 Or 再任选一边 Or 最后一定胜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; string s; cin\u0026gt;\u0026gt;s; if(s[0]==\u0026#39;1\u0026#39;||s[n-1]==\u0026#39;1\u0026#39;)cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int i=0;i\u0026lt;n;i++){ if((s[i]-\u0026#39;0\u0026#39;)\u0026amp;\u0026amp;(s[i+1]-\u0026#39;0\u0026#39;)==1){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } D. QED\u0026rsquo;s Favorite Permutation 观察题目发现，除非出现 $LR$ 这样的片段，不然就会形成一个片段，这个片段中的每个元素都可以互换位置。\n那么就可以判断每个片段中是否有不属于这个片段的元素存在，如果有即为 NO，反之为 YES\n开一 $cnt$ 数组来记录位置错乱的值，如果前缀和 $cnt=0$ 那么当前片段即为可行片段\n如果出现了 $LR$ 同时 $cnt!=0$ 那么答案就为 NO\n只需要实时更新不合法的位置即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,q; int p[N],cnt[N]; string s; set\u0026lt;int\u0026gt;st; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;p[i]; for(int i=1;i\u0026lt;=n;i++){ cnt[min(i,p[i])]++; cnt[max(i,p[i])]--; } for(int i=2;i\u0026lt;=n;i++)cnt[i]+=cnt[i-1]; cin\u0026gt;\u0026gt;s; s=\u0026#34; \u0026#34;+s; for(int i=1;i\u0026lt;n;i++){ if(s[i]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[i+1]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[i])st.insert(i); } while(q--){ int x; cin\u0026gt;\u0026gt;x; s[x]=(s[x]==\u0026#39;L\u0026#39;?\u0026#39;R\u0026#39;:\u0026#39;L\u0026#39;); if(s[x-1]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[x]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[x-1])st.insert(x-1); else st.erase(x-1); if(s[x]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[x+1]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[x])st.insert(x); else st.erase(x); if(!st.empty())cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } st.clear(); memset(cnt,0,sizeof(cnt)); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 有点类似的两道题\nCF Round 977 C1. Adjust The Presentation (Easy Version) 初始序列的某个成员，他在播放序列中出现的顺序一定比他后面的人前，不可能在播放序列中出现倒序的情况\n相当与只考虑实际初始序列中的相邻位置，如果上一个人没有播放过，或者他播放的顺序比后面那个晚，那一定不可能达成\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,m,q; int a[N],b[N],c[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;b[i]; memset(c,0x3f3f3f,sizeof(c)); for(int i=1;i\u0026lt;=m;i++){ if(c[b[i]]\u0026gt;N)c[b[i]]=i; } for(int i=2;i\u0026lt;=n;i++){ int now=a[i],lst=a[i-1]; if(c[now]\u0026lt;N\u0026amp;\u0026amp;c[lst]\u0026gt;N||c[now]\u0026lt;c[lst]){ cout\u0026lt;\u0026lt;\u0026#34;TIDAK\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YA\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C2. Adjust The Presentation (Hard Version) 与 C1 相比，加了 Q 次可持久化更改和询问\n实际思路仍和上题相似\n我们可以维护不合法的所有位置，即初始序列中那些相邻的前者未播放，或后者先于前者在播放序列出现的组合\n将所有的不合法组合储存起来，每次更新检查剩下的组合是否为 0，如果为 0 即总序列为合法\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; const ll inf=1e16; int n,m,q; int a[N],b[N],c[N],d[N]; set\u0026lt;int\u0026gt;s[N]; int check(int x){ int cnt=0,l=a[x-1],r=a[x+1],now=a[x]; if(x\u0026lt;n\u0026amp;\u0026amp;d[now]\u0026gt;d[r])cnt++; if(x\u0026gt;1\u0026amp;\u0026amp;d[l]\u0026gt;d[now])cnt++; return cnt; } void solve(){ memset(c, 0, sizeof(c)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; a[i]; s[i].clear(); c[a[i]] = i; d[i] = inf; } for(int i = 1; i \u0026lt;= m; i++){ cin \u0026gt;\u0026gt; b[i]; s[b[i]].insert(i); } for(int i = m; i \u0026gt; 0; i--) d[b[i]] = i; int cnt = 0; for(int i = 1; i \u0026lt; n; i++){ if(d[a[i]] \u0026gt; d[a[i + 1]]) cnt++; } if(!cnt) cout \u0026lt;\u0026lt; \u0026#34;YA\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;TIDAK\\n\u0026#34;; while(q--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; s[b[x]].erase(x); s[y].insert(x); for(int i:{b[x],y}){ cnt-=check(c[i]); if(s[i].empty())d[i]=inf; else d[i]=*s[i].begin(); cnt+=check(c[i]); } b[x]=y; if(!cnt)cout\u0026lt;\u0026lt;\u0026#34;YA\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;TIDAK\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf979/","summary":"C. A TRUE Battle 如果开头和结尾有 $1$，那么一定 Alice 胜 如果中间有相邻的两个 $1$，那么 Alice 可以先选这俩中间 Or 再任选一边 Or 最后一定胜 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; string s; cin\u0026gt;\u0026gt;s; if(s[0]==\u0026#39;1\u0026#39;||s[n-1]==\u0026#39;1\u0026#39;)cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int i=0;i\u0026lt;n;i++){ if((s[i]-\u0026#39;0\u0026#39;)\u0026amp;\u0026amp;(s[i+1]-\u0026#39;0\u0026#39;)==1){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } D. QED\u0026rsquo;s Favorite Permutation 观察题目发现，除非出现 $LR$ 这样的片段，不然就会形成一个片段，这个片段中的每个元素都可以互换位置。 那","title":"Codeforces Round 979 (Div. 2)"},{"content":"C. Swiss Stage 四目 TES 打的像浓 shit，真的恶臭\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) #define lson (now\u0026lt;\u0026lt;1) #define rson (now\u0026lt;\u0026lt;1|1) using namespace std; typedef long long ll; const int N=2e5+7,inf=1e9+7; const ll mod=2097152; void solve() { int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ans[10][10]; ans[0][0]=4; ans[0][1]=4; ans[0][2]=6; ans[1][0]=3; ans[1][1]=3; ans[1][2]=4; ans[2][0]=2; ans[2][1]=2; ans[2][2]=2; cout\u0026lt;\u0026lt;ans[x][y]; } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } J. Graft and Transplant 每次只能选度数不为 $1$ 的点，看一共有多少个能选的点即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,u,v; int deg[55]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; deg[u]++; deg[v]++; } int cnt=0; for(int i=1;i\u0026lt;=n;i++){ if(deg[i]\u0026gt;1)cnt++; } if((cnt\u0026amp;1)||(!cnt))cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Sheep Eat Wolves 开始想的是模拟，但是模拟一直调不出来，最后用 $dp$ 调出来了\n用 $f_{i,j}$ 记录最佳方案的代价，$i,j$ 分别对应当前左侧的羊和狼的数量\n船每次都是坐满最优，使某些狼一直在船上，比船上留空位更优\n同时羊送到对岸，绝对不可能再返回，但是狼可能来回携带，如样例2，那么我们可以枚举带回狼的数量\n递推公式如下\n$f_{i,j}=\\begin{cases}0,\u0026amp;i=0\\\\1,\u0026amp;i\\leq p\\\\min{f_{ij}+f_{i-x,j-y}+2}\\end{cases}$\n最后输出 $f_{x,y}$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+10, mod=1e9+7; int f[N][N],x,y,q,p; bool check(int x,int y){ return (x\u0026amp;\u0026amp;y-x\u0026gt;q); } void solve(){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q; memset(f,-1,sizeof(f)); for(int i=0;i\u0026lt;=x;i++){ for(int j=0;j\u0026lt;=y;j++){ if(check(x-i,y-j))continue; if(i==0){ f[i][j]=0; continue; } if(i\u0026lt;=p){ f[i][j]=1; continue; } for(int k=0;k\u0026lt;=i\u0026amp;\u0026amp;k\u0026lt;=p;k++){ int l=p-k; if(check(i-k,j-l))continue; for(int m=0;m\u0026lt;=p\u0026amp;\u0026amp;m\u0026lt;=y-j+l;m++){ if(k==0\u0026amp;\u0026amp;m==p)continue; if(f[i-k][j-l+m]==-1)continue; if(f[i][j]==-1)f[i][j]=2+f[i-k][j-l+m]; else f[i][j]=min(f[i][j],2+f[i-k][j-l+m]); } } } } cout\u0026lt;\u0026lt;f[x][y]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } K. Maximum Rating 队长一眼顶针出结论，$k$ 是连续的，找上下限即可\n显然上限为先进行所有为正数的比赛，下限为先进行所有为负数的比赛，同时正数的比赛从小到大排\n现在的问题就转化到如何维护这个 $k$ 的范围\n需要用线段树维护，同时根据 $a$ 的范围发现需要动态开点\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; struct Node{ int l,r,cnt; ll sum; }tr[N*2*32]; int tot=0,rt=0; ll a[N]; void add(int\u0026amp; now,int l,int r,int x,int v){ if(!now)now=++tot; tr[now].sum+=x*v; tr[now].cnt+=v; if(l==r)return; ll mid=(l+r)\u0026gt;\u0026gt;1; if(x\u0026lt;=mid)add(tr[now].l,l,mid,x,v); else add(tr[now].r,mid+1,r,x,v); } int ask(int now,int l,int r,ll x){ if(!now)return 0; if(tr[now].sum\u0026lt;=x)return 0; if(l==r)return tr[now].cnt-(x/l); ll mid=(l+r)\u0026gt;\u0026gt;1; if(tr[tr[now].l].sum\u0026gt;x)return tr[tr[now].r].cnt+ask(tr[now].l,l,mid,x); else return ask(tr[now].r,mid+1,r,x-tr[tr[now].l].sum); } void solve(){ int n,q,cnt=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026gt;0)++cnt; add(rt,-1e9,1e9,a[i],1); } while(q--){ ll x,v; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; if(a[x]\u0026gt;0)--cnt; add(rt,-1e9,1e9,a[x],-1); a[x]=v; add(rt,-1e9,1e9,a[x],1); if(a[x]\u0026gt;0)++cnt; int tmp=ask(rt,-1e9,1e9,0); cout\u0026lt;\u0026lt;cnt-tmp+1\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/icpc2023shenyang/","summary":"C. Swiss Stage 四目 TES 打的像浓 shit，真的恶臭 #include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) #define lson (now\u0026lt;\u0026lt;1) #define rson (now\u0026lt;\u0026lt;1|1) using namespace std; typedef long long ll; const int N=2e5+7,inf=1e9+7; const ll mod=2097152; void solve() { int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ans[10][10]; ans[0][0]=4; ans[0][1]=4; ans[0][2]=6; ans[1][0]=3; ans[1][1]=3; ans[1][2]=4; ans[2][0]=2; ans[2][1]=2; ans[2][2]=2; cout\u0026lt;\u0026lt;ans[x][y]; } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } J. Graft and Transplant 每次只能选度数不为 $1$ 的点，看一共有多少个能选的点即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int","title":"ICPC 2023 沈阳 VP"},{"content":"概述 网络是指一个特殊的有向图 $G=(V,E)$，与一般图不同的是有容量和源汇点\n$E$ 中的每条边 $(u,v)$ 都有一个被称为容量的权值，如果某条边 $(u,v)\\not\\in E$，可以假定 $c(u,v)=0$ $V$ 中有两个特殊的点，源点 $s$ 和汇点 $t$ 对于网络 $G=(V,E)$，流是一个从边集 $E$ 到整数集或实数集的函数，满足以下性质\n容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 $0\\leq f(u,v)\\leq c(u,v)$ 流守恒性：除源汇点外，任意结点 $u$ 的净流量为 $0$。其中，我们定义 $u$ 的净流量为 $f(u)=\\sum_{x\\in V}f(u,x)-\\sum_{x\\in V}f(x,u)$ 对于网络 $G=(V,E)$ 和其上的流 $f$，我们定义 $f$ 的流量 $|f|$ 为 $s$ 的净流量 $f(s)$，根据流守恒性 $f(s)=-f(t)$\n对于网络 $G=(V,E)$，如果 ${S,T}$ 是 $V$ 的划分（即 $S\\cup T=V$ 且 $S\\cap T=\\emptyset$），且满足 $s\\in S,t\\in T$，那我们就称 ${S,T}$ 是 $G$ 的一个 $s-t$ 割。定义 $s-t$ 割 ${S,T}$ 的容量为 $||S,T||=\\sum_{u\\in S}\\sum_{v\\in T}c(u,v)$\n常见问题分类 最大流问题：对于网络 $G=(V,E)$，给每条边指定流量，得到合适的流 $f$，使得 $f$ 的流量尽可能大，此时称 $f$ 为 $g$ 的最大流\n最小割问题：对于网络 $G=(V,E)$，找到合适的 $s-t$ 割 ${S,T}$，使得其容量尽可能小，此时称 ${S,T}$ 为 $G$ 的最小割\n最小费用最大流问题：在网络 $G=(V,E)$，对于每条边给定一个权值 $w(u,v)$，称为费用，含义是单位流量通过 $(u,v)$ 花费的代价，对于 $G$ 所有可能的最大流，我们称总费用最小的一者为最小费用最大流\n最大流 最大流问题的学习\n概述 令 $G=(V,E)$ 是一个有源汇点的网络，我们希望在 $G$ 上指定合适的流 $f$，以最大化整个网络的流量 $|f|$（即 $\\sum_{x \\in V} f(s, x) - \\sum_{x \\in V} f(x, s)$），这一问题被称作最大流问题\nFord–Fulkerson 增广 Ford–Fulkerson 增广是计算最大流的一类算法的总称。该方法运用 贪心 的思想，通过寻找 增广路 来更新并求解最大流。\n概述 给定网络 $G$ 和 网络上的流 $f$，做如下定义\n对于边 $(u,v)$，我们将其容量与流量之差称为剩余容量 $c_f(u,v)$，即 $c_f(u,v)=c(u,v)-f(u,v)$\n我们将 $G$ 中所有的结点和剩余容量大于 $0$ 的边构成的子图称为残量网络 $G_f$，即 $G_f=(V,E_f)$，其中 $E_f={(u,v)\\mid c_f(u,v)\u0026gt;0}$\n","permalink":"https://blog.050623.xyz/posts/study/flow/","summary":"概述 网络是指一个特殊的有向图 $G=(V,E)$，与一般图不同的是有容量和源汇点 $E$ 中的每条边 $(u,v)$ 都有一个被称为容量的权值，如果某条边 $(u,v)\\not\\in E$，可以假定 $c(u,v)=0$ $V$ 中有两个特殊的点，源点 $s$ 和汇点 $t$ 对于网络 $G=(V,E)$，流是一个从边集 $E$ 到整数集或实数集的函数，满足以下性质 容量限制：对于每条边","title":"网络流学习记录"},{"content":"J. Strange Sum 最多选两个，每选当前这个会限制选的范围，那么答案就一定是前面最大的加上现在这个的最大值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; ll mx=0,ans=0; for(int i=1;i\u0026lt;=n;i++){ ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x+mx); mx=max(mx,x); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Clone Ranran 如果要克隆增加人数，一定是先在出题操作前增加的，那么就遍历可能的克隆次数，找到总共的最小代价\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=3e2+7,inf=1e9+7; const ll mod=2097152; ll a,b,c; void solve() { ll ans=1e18,now=0,peo=1; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; while(peo\u0026lt;=c*2){ ans=min(ans,(int)ceil(1.0*c/peo)*b+now); now+=a; peo*=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } F. Hotel 因为双人房只能同队的同性别住，那只用对每队考虑即可\n如果同一队内有同性的，那就可以考虑用双人房，否则全用单价低的房间\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=3e2+7,inf=1e9+7; const ll mod=2097152; void solve() { int n,c1,c2,sum=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c1\u0026gt;\u0026gt;c2; for(int i=1;i\u0026lt;=n;++i) { string s; cin\u0026gt;\u0026gt;s; bool flag=0; if(s[0]==s[1]||s[0]==s[2]||s[1]==s[2]) flag=1; int mi=min(c1,c2),ans=3*mi; if(flag) ans=min(ans,mi+c2); sum+=ans; } printf(\u0026#34;%d\\n\u0026#34;,sum); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } G. Perfect Word 所有 $t$ 按长度排序，依次在后面的串是否满足他的子串在前面都出现过即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=1e5+7,inf=1e9+7; const ll mod=2097152; string s[N]; map\u0026lt;string,bool\u0026gt; mp; bool cmp(string x,string y) { return x.length()\u0026lt;y.length(); } void solve() { int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;s[i]; sort(s+1,s+1+n,cmp); for(int i=1;i\u0026lt;=n;++i) { if(s[i].length()==1) mp[s[i]]=1,ans=1; else { string tmp=s[i].substr(0,s[i].length()-1); if(mp.find(tmp)==mp.end()) continue; tmp=s[i].substr(1,s[i].length()-1); if(mp.find(tmp)==mp.end()) continue; mp[s[i]]=1; ans=s[i].length(); } } printf(\u0026#34;%d\u0026#34;,ans); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } E. Find Maximum 打表后发现，遇到 $3$ 的倍数就会变小一次，每三次是一个小片段，根据这个性质用 $dfs$ 暴力找即可\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=1e5+7,inf=1e9+7; const ll mod=2097152; ll F(ll x) { if(x\u0026lt;3) return 1+x; int y=x%3; return y+1+F(x/3); } ll sol(ll l,ll r) { ll ans=0; while(l\u0026lt;=r\u0026amp;\u0026amp;l%3!=0) { ll x=F(l); ans=max(ans,x); ++l; } if(l\u0026gt;r) return ans; while(l\u0026lt;=r\u0026amp;\u0026amp;r%3!=2) { ll x=F(r); ans=max(ans,x); --r; } if(l\u0026gt;r) return ans; ll tmp=sol(l/3,r/3)+3; return max(ans,tmp); } void solve() { ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; printf(\u0026#34;%lld\\n\u0026#34;,sol(l,r)); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } L. Tree 观察题目，发现集合要么是一条链，要么是当前所有的叶子节点，这代表了两种操作，要找到最少的操作次数\n记录当前的叶子节点，往上查找一层，用出度判断是否为分叉情况，找到当前的链数，用这个链数加上取叶子节点的次数，即为当前答案，一直找到往上没有链为止\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; vector\u0026lt;int\u0026gt;nxt[N]; int fa[N],deg[N]; deque\u0026lt;int\u0026gt;leaf; bool vis[N]; void dfs(int x,int f,int len){ fa[x]=f; for(auto y:nxt[x]){ if(y!=f)dfs(y,x,len+1),++deg[x]; } if(!deg[x])leaf.push_back(x); } void solve(){ leaf.clear(); cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; nxt[x].push_back(i); nxt[i].push_back(x); } dfs(1,0,1); int ans=leaf.size(); for(int i=1;!leaf.empty();i++){ int cnt=leaf.size(); while(cnt--){ int x=fa[leaf.front()]; leaf.pop_front(); if(!x)continue; --deg[x]; if(!deg[x])leaf.push_back(x); } ans=min(ans,i+(int)leaf.size()); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;i++)nxt[i].clear(),vis[i]=0,deg[i]=0; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Cells Coloring 网络流，好像挺板的，后面学了补\nA. Bridge LCT，后面学了补\n","permalink":"https://blog.050623.xyz/posts/study/icpc2022xian/","summary":"J. Strange Sum 最多选两个，每选当前这个会限制选的范围，那么答案就一定是前面最大的加上现在这个的最大值 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; ll mx=0,ans=0; for(int i=1;i\u0026lt;=n;i++){ ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x+mx); mx=max(mx,x); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Clone Ranran 如果要克隆增加人数，一定是先在出题操作前增加的，那么就遍历可能的克隆次数，","title":"ICPC 2022 西安 VP"},{"content":"A. Two Screens 找两串相同前缀长度，再加上各自之后的长度\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s,t; int ans; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; ans=0; for(int i=0;i\u0026lt;min(s.size(),t.size());i++){ if(s[i]==t[i]){ ans++; if(i==min(s.size(),t.size())-1){ ans++; ans+=(s.size()-i)+(t.size()-i)-2; } } else{ if(i!=0){ ans++; ans+=(s.size()-i)+(t.size()-i); } else{ ans+=(s.size()-i)+(t.size()-i); } break; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Binomial Coefficients, Kind Of 通过打表发现目标输出其实就是 $2^{k[i]}$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e5+7, mod=1e9+7; ll qpow(int x,int y){ ll res=1; while(x){ if(x\u0026amp;1){ res=(res*y)%mod; } y=(y*y)%mod; x/=2; } return res; } void solve(){ int t; int n[N],k[N]; cin\u0026gt;\u0026gt;t; for(int i=1;i\u0026lt;=t;i++)cin\u0026gt;\u0026gt;n[i]; for(int i=1;i\u0026lt;=t;i++)cin\u0026gt;\u0026gt;k[i]; for(int i=1;i\u0026lt;=t;i++){ if(n[i]\u0026gt;=k[i]) cout\u0026lt;\u0026lt;qpow(k[i],2)\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. New Game 可以发现取牌只能取一段连续片段内的所有牌，那我们只需要遍历所有的牌的种类即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; map\u0026lt;int,int\u0026gt;vis; set\u0026lt;int\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; s.insert(x); vis[x]++; } int lst=-100,len=1; ll tmp=0,ans=0; for(int x:s){ if(x==lst+1){ tmp+=vis[x]; len++; lst=x; if(len\u0026gt;k){ len--; tmp-=vis[x-k]; } } else{ len=1; tmp=vis[x]; lst=x; } ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Attribute Checks 因为 $m$ 和 $|a[i]|$ 的值很小，可以考虑 $DP$ (开始尝试用 $set$ 实现，但是插入操作的 $nlogn$ 会使复杂度过高)\n记录每种任务的需求，当遇到 $r[i]==0$ 时，即可进行dp，可以遍历所有当前总能力值前方的任务数量，取得前缀和，然后用 $dp$ 记录智力取 $i$ 时的最大 $dp$ 值\n然后把用过的数组还原，将 $now+1$ 继续向下进行\n最后遍历所有的 $dp$ 找到最大的值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e6+7, mod=1e9+7, M=5e4+10; int n,m; int r[N],dp[M],st[N],in[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;r[i]; } int now=0; int ans=0; memset(st,0,sizeof(st)); memset(in,0,sizeof(in)); memset(dp,0,sizeof(dp)); for(int i=1;i\u0026lt;=n;i++){ if(r[i]\u0026gt;0)in[r[i]]++; if(r[i]\u0026lt;0)st[-r[i]]++; if(r[i]==0||i==n){ for(int j=1;j\u0026lt;=now;j++){ in[j]+=in[j-1]; st[j]+=st[j-1]; } for(int j=0;j\u0026lt;=now;j++){ dp[j]+=in[j]+st[now-j]; } for(int j=now+1;j\u0026gt;0;j--){ dp[j]=max(dp[j],dp[j-1]); } now++; for(int j=1;j\u0026lt;=now;j++){ in[j]=0; st[j]=0; } } } for(int i=1;i\u0026lt;=now;i++)ans=max(ans,dp[i]); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cfe170/","summary":"A. Two Screens 找两串相同前缀长度，再加上各自之后的长度 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s,t; int ans; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; ans=0; for(int i=0;i\u0026lt;min(s.size(),t.size());i++){ if(s[i]==t[i]){ ans++; if(i==min(s.size(),t.size())-1){ ans++; ans+=(s.size()-i)+(t.size()-i)-2; } } else{ if(i!=0){ ans++; ans+=(s.size()-i)+(t.size()-i); } else{ ans+=(s.size()-i)+(t.size()-i); } break; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Binomial Coefficients, Kind Of 通过打表发现目标输出其实就是 $2^{k[i]}$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e5+7, mod=1e9+7; ll qpow(int","title":"Educational Codeforces Round 170"},{"content":"A. Bus to Pénjamo 每个家族优先按排座，统计所有家族多出来的那一个人的总和，看最后剩几排可以让他们单独座，其余人继续坐满一排\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,r; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;r; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); int ans=0,lft=0; for(int i=n;i\u0026gt;0;i--){ ans+=(a[i]/2)*2; r-=a[i]/2; lft+=a[i]%2; } ans+=min(lft,r); ans-=max(0,(lft-r)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Kar Salesman 结论题，最少我们需要数量最大的那个车型的人数，如果这个值不够买下其他所有的，那就是所有的总和除以 $x$ 的值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=5e5+7, mod=1e9+7; int n,x; int ans,a[N],sum; void solve(){ ans=sum=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; sum+=a[i]; ans=max(ans,a[i]); } if(ans*x\u0026gt;sum)cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;(int)ceil(1.0*sum/x)\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Gerrymandering $DP$\n所有的选区如下\n按列向前推进\n当 $i%3==0$ 时，考虑两行整齐分开排，上下组合排 当 $i%3==1$ 时，考虑有错开的情况 具体可以看代码的转移\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; bool check(char a,char b,char c){ int res=(a==\u0026#39;A\u0026#39;)+(b==\u0026#39;A\u0026#39;)+(c==\u0026#39;A\u0026#39;); return res\u0026gt;=2; } int n; char mp[3][N]; int dp[5][N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;2;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; memset(dp,0,sizeof(dp)); dp[0][1]=0; for(int i=1;i\u0026lt;=n;i++){ if(i%3==1){ dp[0][i+3]=max(dp[0][i+3],dp[0][i]+check(mp[0][i],mp[0][i+1],mp[0][i+2])+check(mp[1][i],mp[1][i+1],mp[1][i+2])); dp[0][i+1]=max(dp[0][i+1],dp[0][i]+check(mp[0][i],mp[1][i],mp[0][i+1])); dp[1][i+1]=max(dp[1][i+1],dp[0][i]+check(mp[1][i],mp[0][i],mp[1][i+1])); } else if(i%3==2){ if(i\u0026lt;=n-3){ dp[0][i+3]=max(dp[0][i+3],dp[0][i]+check(mp[0][i+1],mp[0][i+2],mp[0][i+3])+check(mp[1][i],mp[1][i+1],mp[1][i+2])); dp[1][i+3]=max(dp[1][i+3],dp[1][i]+check(mp[0][i],mp[0][i+1],mp[0][i+2])+check(mp[1][i+1],mp[1][i+2],mp[1][i+3])); } dp[0][i+2]=max(dp[0][i+2],dp[0][i]+check(mp[1][i],mp[1][i+1],mp[0][i+1])); dp[0][i+2]=max(dp[0][i+2],dp[1][i]+check(mp[0][i+1],mp[0][i],mp[1][i+1])); } } cout\u0026lt;\u0026lt;dp[0][n+1]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D1. Asesino (Easy Version) 交互题\n可以发现，如果两个人的身份是真的，那么他们对对方的回答是相同的，可以两两判断，如果有一对不用，伪装者就在这一对中，只需要再取一个比对一次即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; bool query(int x,int y){ cout\u0026lt;\u0026lt;\u0026#34;? \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; int fx,fy; cin\u0026gt;\u0026gt;fx; cout\u0026lt;\u0026lt;\u0026#34;? \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;fy; return fx!=fy; } void solve(){ cin\u0026gt;\u0026gt;n; int pos=-1; for(int i=1;i\u0026lt;n;i+=2){ bool flag=query(i,i+1); if(flag){ pos=i; break; } } if(pos==-1)cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else if(query(pos,pos\u0026gt;1?pos-1:pos+2)) cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;pos\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;pos+1\u0026lt;\u0026lt;endl; } int main(){ // ios::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf978/","summary":"A. Bus to Pénjamo 每个家族优先按排座，统计所有家族多出来的那一个人的总和，看最后剩几排可以让他们单独座，其余人继续坐满一排 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,r; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;r; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); int ans=0,lft=0; for(int i=n;i\u0026gt;0;i--){ ans+=(a[i]/2)*2; r-=a[i]/2; lft+=a[i]%2; } ans+=min(lft,r); ans-=max(0,(lft-r)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Kar Salesman 结论题，最少我们需要数量最大的那个","title":"Codeforces Round 978 (Div. 2)"},{"content":"I. Counter 操作可以都想成连续的，那么输入 $a,b$，意为在 $a-b$ 处进行了一次归零，之后连着进行了 $b$ 次操作，如果中间有冲突，即为 NO\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,m,flag=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=m;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(b\u0026gt;a)flag=1; int l = a - b; if(vis.find(l) != vis.end()){ vis[l] = max(vis[l], a); } else { vis[l] = a; } } int now=-1; for(auto \u0026amp;x:vis){ if(now\u0026gt;=x.first){ flag=1; break; } now=x.second; } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Primitive Root 通过题上公式可以得到 $g=(kP+1)\\oplus(P-1)$\n显然 $g$ 的数量就是 $k$ 的个数\n异或性质： $a-b\\leq a\\oplus b\\leq a+b$\n那么 $0\\leq k\\leq\\left\\lfloor\\frac mP\\right\\rfloor-1$ 时，所有的 $k$ 都成立，$k\\geq\\lceil\\frac mP\\rceil+1$ 时，所有的 $k$ 都不成立，那么只需要特殊判断两边界之间的值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; ll p,m,ans; void solve(){ cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;m; ans=m/p; for(ll i=m/p;i\u0026lt;=ceil(1.0*m/p);i++){ if(((i*p+1)^(p-1))\u0026lt;=m)ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G - Knapsack 显然，免费获取的机会要用在 $w$ 大的物品上\n将所有物品排序，先进行一遍背包，得到对前 $i$ 个物品背包时的最大值\n再用这个值加上未选的物品中 $v$ 最大的 $k$ 个物品，最大值即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e4+7, mod=1e9+7; struct Node{ int w,v; bool operator\u0026lt;(const Node \u0026amp;t){ if(w==t.w)return v\u0026lt;t.v; return w\u0026lt;t.w; } }a[N]; ll n,m,k; ll dp[N][N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].w\u0026gt;\u0026gt;a[i].v; sort(a+1,a+1+n); for(int i=1;i\u0026lt;=n;i++){ for(int j=m;j\u0026gt;=0;j--){ if(j\u0026gt;=a[i].w){ dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[i].w]+a[i].v); } else dp[i][j]=dp[i-1][j]; } } ll ans=0,sum=0; multiset\u0026lt;int\u0026gt;s; if(k){ for(int i=n-k+1;i\u0026lt;=n;i++){ sum+=a[i].v; s.insert(a[i].v); } ans=dp[n-k][m]+sum; for(int i=n-k;i\u0026gt;0;i--){ if(a[i].v\u0026gt;*s.begin()){ sum-=*s.begin(); sum+=a[i].v;; s.erase(s.begin()); s.insert(a[i].v); } ans=max(ans,dp[i-1][m]+sum); } }else ans=dp[n][m]; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } F - Equivalent Rewriting 每一位的值实际是由最后一次操作他的操作决定的，$n$ 个操作本身构成了 $1~n$ 的拓扑序\n只需检查每一位的所有操作，看是否有相邻的操作处于里面，如果有，那么这个 $i \\rightarrow i+1$ 这个序列就是不可被更改的，检查完之后如果有没被标记过的即可交换他们的位置，输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+7; vector\u0026lt;int\u0026gt; a[N]; int ans[N]; bool vis[N]; void solve(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;++i) { ans[i]=i; int k; cin\u0026gt;\u0026gt;k; for(int j=1;j\u0026lt;=k;++j) { int x; cin\u0026gt;\u0026gt;x; a[x].push_back(i); } } for(int i=1;i\u0026lt;=m;++i) { if(a[i].empty()) continue; int x=a[i].back(); for(auto y:a[i]) { if(y==x-1) vis[y]=1; } } bool flag=0; for(int i=1;i\u0026lt;n;++i) { if(!vis[i]) {swap(ans[i],ans[i+1]);flag=1;break;} } if(!flag) cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else { cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; for(int i=1;i\u0026lt;=n;++i) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } for(int i=1;i\u0026lt;=n;++i) vis[i]=0; for(int i=1;i\u0026lt;=m;++i) a[i].clear(); } int main(){ ios::sync_with_stdio(0); cin.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } A - Cool, It’s Yesterday Four Times More 因为 $n*m$ 的数量级很小，可以考虑很暴力的做法\n我们可以用一个 $(x,y,i,j)$ 记录位于 $(x,y)$ 的袋鼠能否踢掉位于 $(i,j)$ 的袋鼠，同时易想到位于同一个联通块的袋鼠，能否获胜是一样的\n要记录 $(x,y,i,j)$ 不能直接使用 $map$ 来存取，这样会使时间复杂度陡升，要将这 $4$ 个数转换为一个数，从而达到 $O(1)$ 的查询\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#39;\\n\u0026#39; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int n,m; char mp[N][N]; int vis[N*N]; bool flag[N*N]; int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0}; int gao(int i, int j, int r, int c) { //此处即为转换函数 return i * m * n * m + j * n * m + r * m + c; } void ungao(int msk, int \u0026amp;i, int \u0026amp;j, int \u0026amp;r, int \u0026amp;c) { //此处为还原函数 i = msk / (m * n * m); j = msk / (n * m) % m; r = msk / m % n; c = msk % m; } bool die(int x,int y){ return (x\u0026lt;0||y\u0026lt;0||x\u0026gt;=n||y\u0026gt;=m||mp[x][y]==\u0026#39;O\u0026#39;); } void bfs(int s){ queue\u0026lt;int\u0026gt;q; q.push(s); vis[s]=s; flag[s]=0; while(q.size()){ int now=q.front(); q.pop(); int x,y,a,b; ungao(now, x, y, a, b); for(int i=0;i\u0026lt;4;i++){ int xx=x+dx[i],yy=y+dy[i]; int aa=a+dx[i],bb=b+dy[i]; if(die(xx,yy))continue; if(die(aa,bb)){ flag[s]=1; continue; } int nxt = gao(xx, yy, aa, bb); if(vis[nxt]\u0026gt;=0)continue; q.push(nxt); vis[nxt]=s; } } } bool check(int x,int y){ for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ if(mp[i][j]==\u0026#39;.\u0026#39;){ if(i==x\u0026amp;\u0026amp;j==y)continue; int state = gao(x, y, i, j); if(vis[state]==-1)bfs(state); if(!flag[vis[state]])return 0; } } } return 1; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++)cin\u0026gt;\u0026gt;mp[i][j]; memset(vis,-1,sizeof(vis)); memset(flag,0,sizeof(flag)); int ans=0; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) if(mp[i][j]==\u0026#39;.\u0026#39;)ans+=check(i,j); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } L - Elevator 偏思维，货物体积只有 $1$ 和 $2$ 这两种情况，可以将体积为 $2$ 的转化为两个体积为 $1$ 的来进行处理\n证明如下\n如果每一趟都能填满 $k$，那么转化前和转化后的结果相同 如果出现了剩下体积为 $1$，但是下一个物品体积为 $2$，我们会跳过当前物品，向下寻找体积为 $1$ 的物品 由图可知，这样的填充并不会对答案造成影响\n所以只需将所有的物品按楼层高度降序排，从高到低每次选够 $k$ 个物品，答案每次加当前最高楼层即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; ll n,k; vector\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;w; void solve(){ w.clear(); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ ll x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; w.push_back({z,x*y}); } sort(w.begin(),w.end(),greater\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;()); ll ans=0,now=w[0].first,lst=0; for(auto [x,y]:w){ if(lst){ if(k\u0026gt;lst+y){ lst+=y; continue; } y-=(k-lst); ans+=now; now=x; ll t=y/k; ans+=now*t; lst=y%k; } else{ now=x; ll t=y/k; ans+=t*now; lst=y%k; } } if(lst)ans+=now; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } M - Trapping Rain Water 根据题目给出的公式格式可以得到 $\\sum_{i=1}^nf_i+\\sum_{i=1}^ng_i-n\\times\\max a_i-\\sum_{i=1}^na_i$\n难点在于如何维护 $\\sum_{i=1}^nf_i$ 和 $\\sum_{i=1}^ng_i$\n$f,g$ 都是单调的序列，可以发现，二者都是连续相同的片段，即片段会以当前片段开头为最大值存在\n这样，我们维护这些片段就只需要用 $set$ 来操作即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define pil pair\u0026lt;int,long long\u0026gt; typedef long long ll; const int N=1e5+7, mod=1e9+7; const ll inf=1e18; int n, q; ll A[N]; ll fA[N], fsm; set\u0026lt;pil\u0026gt; fst; ll gA[N], gsm; set\u0026lt;pil\u0026gt; gst; void clear(ll A[], ll \u0026amp;sm, set\u0026lt;pil\u0026gt; \u0026amp;st) { memset(A, 0, sizeof(ll) * (n + 3)); sm = 0; st.clear(); st.insert(pil(1, 0)); st.insert(pil(n + 1, inf)); } void update(ll A[], ll \u0026amp;sm, set\u0026lt;pil\u0026gt; \u0026amp;st, int x, ll v) { A[x] += v; auto it = prev(st.upper_bound(pil(x, inf))); if (it-\u0026gt;second \u0026gt;= A[x]) return; sm -= (next(it)-\u0026gt;first - it-\u0026gt;first) * it-\u0026gt;second; sm += (x - it-\u0026gt;first) * it-\u0026gt;second + (next(it)-\u0026gt;first - x) * A[x]; it = st.insert(pil(x, A[x])).first; while (next(it)-\u0026gt;second \u0026lt;= A[x]) { sm -= (next(it)-\u0026gt;first - x) * A[x] + (next(next(it))-\u0026gt;first - next(it)-\u0026gt;first) * next(it)-\u0026gt;second; st.erase(next(it)); sm += (next(it)-\u0026gt;first - x) * A[x]; } } void solve() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); ll mx = 0, sm = 0; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;A[i]); mx = max(mx, A[i]); sm += A[i]; } clear(fA, fsm, fst); clear(gA, gsm, gst); for (int i = 1; i \u0026lt;= n; i++) { update(fA, fsm, fst, i, A[i]); update(gA, gsm, gst, n + 1 - i, A[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;v); A[x] += v; mx = max(mx, A[x]); sm += v; update(fA, fsm, fst, x, v); update(gA, gsm, gst, n + 1 - x, v); printf(\u0026#34;%lld\\n\u0026#34;, fsm + gsm - n * mx - sm); } } int main() { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/icpc2023nanjing/","summary":"I. Counter 操作可以都想成连续的，那么输入 $a,b$，意为在 $a-b$ 处进行了一次归零，之后连着进行了 $b$ 次操作，如果中间有冲突，即为 NO #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,m,flag=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=m;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(b\u0026gt;a)flag=1; int l = a - b; if(vis.find(l) != vis.end()){ vis[l] = max(vis[l], a); } else { vis[l] = a; } } int now=-1; for(auto \u0026amp;x:vis){ if(now\u0026gt;=x.first){ flag=1; break; } now=x.second; } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; }","title":"ICPC 2023 南京 VP"},{"content":"树上 DP 顾名思义，在树上进行的 DP，一般通过递归进行\n一般开 $f_{i,j}$ 表示以 $i$ 为根的子树的最优解，第二维表示选不选 $i$\n洛谷 没有上司的舞会 P1352 题目 某大学有 $n$ 个职员，编号为 $1\\ldots n$。\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n解决 设 $f_{i,j}$ 代表以 $i$ 为根的子树的最优解，$j$ 用 $0,1$ 来表示取不取 $i$ 这个人\n对于每个节点，都有两种决策\n不取当前节点，他的子节点都可以取，或不取，$f_{i,0} = \\sum_{x \\in \\text{child}(i)} \\max(f_{x,0}, f_{x,1})$\n取当前节点，他的子节点都不能取，$f_{i,0} = \\sum_{x \\in \\text{child}(i)}f_{x,0}+a_i$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; vector\u0026lt;int\u0026gt; edge[N]; int a[N],n,cnt,f[N][2],ans; bool vis[N]; void dfs(int now) { f[now][0] = 0; f[now][1] = a[now]; for (int i = 0; i \u0026lt; (int)edge[now].size(); i++) { int to = edge[now][i]; dfs(to); f[now][0] += max(f[to][0], f[to][1]); f[now][1] += f[to][0]; } } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; edge[y].push_back(x); vis[x]=1; } int root=0; for(int i=1;i\u0026lt;=n;i++){ if(!vis[i]){ root=i; break; } } dfs(root); cout\u0026lt;\u0026lt;max(f[root][0],f[root][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } CF Sheriff\u0026rsquo;s Defense 2014F 题目 给定一张 $n$ 结点 $n - 1$ 条边的有点权的树。初始每个结点都是黑色。\n你可以执行任意次以下操作：将一个黑点染成白色，并将所有与它相邻的结点的权值减去 $c$（不包括自己）。\n最大化全部白点的权值之和。\n解决 用 $f_{u,j}$ 记录，同上一题\n设计状态 $f_{u,0}$ 表示在以 $u$ 为根的子树下，不选择 $u$ 所能获得的最大价值，初始值为 $0$；\n$f_{u,1}$ 表示在以 $u$ 为根的子树下，选择 $u$ 所能获得的最大价值，初始值为 $a_u$。\n如果某个点不选，那它不会对结果造成影响\n若不选 $u$ 则 $$ f_{u,0} = f_{u,0} + \\max(f_{v,0}, f_{v,1}) $$ 若选 $u$ 则 $$ f_{u,1} = f_{u,1} + \\max(f_{v,0}, f_{v,1} - c \\times 2) $$ 如果选 $v$ 那他会对 $u-\u0026gt;v$ 和 $v-\u0026gt;u$ 这两条路径造成消耗所以要减两个 $c$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,c,s,ans; ll dp[N][2]; vector\u0026lt;int\u0026gt;edge[N]; bool vis[N]; void dfs(int now,int fa){ for(auto i:edge[now]){ if(i!=fa){ dfs(i,now); dp[now][0]+=max(dp[i][0],dp[i][1]); dp[now][1]+=max(dp[i][0],dp[i][1]-(c\u0026lt;\u0026lt;1)); } } } void solve(){ ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c; for(int i=1;i\u0026lt;=n;i++){ edge[i].clear(); cin\u0026gt;\u0026gt;dp[i][1]; dp[i][0]=0; vis[i]=0; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); cout\u0026lt;\u0026lt;max(dp[1][0],dp[1][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 树上背包 即背包问题和树上 DP 的结合\n洛谷 CTSC1997 选课 P2014 题目 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 $a$ 是课程 $b$ 的先修课即只有学完了课程 $a$，才能学习课程 $b$）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？\n解决 新增一个 $0$ 学分的必修课，作为所有无前选课的课的前选课，这样就能构建出一颗以新增节点为根的树\n设 $f_{i,j}$ 为第 $i$ 个节点，$j$ 为背包容量\n初始值为 $f_{i,0} = s_{i}$\n递归每颗子树\n每次递归记录当前背包容量，和当前所能得到的最大值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e4 + 7, mod = 1e9 + 7; int n, m, f[N][N]; vector\u0026lt;int\u0026gt; edge[N]; int s[N]; int dfs(int x) { if (edge[x].empty()) return 0; int sum = 0; for (int i : edge[x]) { int t = dfs(i); sum += t + 1; for (int j = sum; j \u0026gt;= 0; j--) { for (int k = 0; k \u0026lt;= t; k++) { if (j - k - 1 \u0026gt;= 0) f[x][j] = max(f[x][j], f[x][j - k - 1] + f[i][k]); } } } return sum; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int k; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s[i]; edge[k].push_back(i); } for (int i = 1; i \u0026lt;= n; i++) f[i][0] = s[i]; f[0][0] = 0; dfs(0); cout \u0026lt;\u0026lt; f[0][m] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 换根 DP 又被称为二次扫描，通常不指定根节点，同时根节点的变化会使一些值发生变化，例如子节点深度和，点权和等\n通常两次 DFS，第一次预处理深度，点权和等信息，第二次 DFS 进行 DP\n洛谷 STA-Station P3478 题目 给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n一个结点的深度之定义为该节点到根的简单路径上边的数量。\n解决 不妨令 $u$ 为当前结点，$v$ 为当前结点的子结点。首先需要用 $s_i$ 来表示以 $i$ 为根的子树中的结点个数，并且有 $s_u = 1 + \\sum s_v$。显然需要一次 DFS 来计算所有的 $s_i$，这次的 DFS 就是预处理，我们得到了以某个结点为根时其子树中的结点总数。\n考虑状态转移，这里就是体现“换根”的地方了。令 $f_u$ 为以 $u$ 为根时，所有结点的深度之和。\n$f_v \\leftarrow f_u$ 可以体现换根，即以 $u$ 为根转移到以 $v$ 为根。显然在换根的转移过程中，以 $v$ 为根或以 $u$ 为根会导致其子树中的结点的深度产生改变。具体表现为：\n所有在 $v$ 的子树上的结点深度都减少了 $1$，那么总深度和就减少了 $s_v$； 所有不在 $v$ 的子树上的结点深度都增加了 $1$，那么总深度和就增加了 $n - s_v$； 根据这两个条件就可以推出状态转移方程：\n$$ f_v = f_u - s_v + n - s_v = f_u + n - 2 \\times s_v $$\n于是在第二次 DFS 遍历整棵树并状态转移 $f_v = f_u + n - 2 \\times s_v$，那么就能求出以每个结点为根时的深度和了。最后只需要遍历一次所有根结点深度和就可以求出答案。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e6+7, mod=1e9+7; vector\u0026lt;int\u0026gt;edge[N]; ll n; ll f[N],sz[N],dep[N]; void dfs(int u,int fa){ sz[u]=1; dep[u]=dep[fa]+1; for(auto v:edge[u]){ if(v==fa)continue; dfs(v,u); sz[u]+=sz[v]; } } void ans(int u,int fa){ f[u]=f[fa]+n-sz[u]-sz[u]; for(auto v:edge[u]){ if(v==fa)continue; ans(v,u); } } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,1); for(int i=1;i\u0026lt;=n;i++){ f[1]+=dep[i]; } ans(1,1); ll res=-1; int now; for(int i=1;i\u0026lt;=n;i++){ if(f[i]\u0026gt;res){ res=f[i]; now=i; } } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/treedp/","summary":"树上 DP 顾名思义，在树上进行的 DP，一般通过递归进行 一般开 $f_{i,j}$ 表示以 $i$ 为根的子树的最优解，第二维表示选不选 $i$ 洛谷 没有上司的舞会 P1352 题目 某大学有 $n$ 个职员，编号为 $1\\ldots n$。 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。 现在有个周年庆宴会，宴会每邀请","title":"树形DP"},{"content":"A Robin Helps 按题意模拟\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,ans,a[N],cnt,k; void solve(){ cnt=ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026gt;=k)cnt+=a[i]; if(!a[i]\u0026amp;\u0026amp;cnt)cnt--,ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Robin Hood and the Major Oak 显然只有最后 $k$ 个点有效，$i^i$ 的奇偶性只和 $i$ 有关，公式加和即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#39;\\n\u0026#39; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; ll n, k; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll s = (n - k + 1 + n) * k / 2; if (s % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Robin Hood in Town 二分答案，每次都把加的金钱给到当前钱最多的人，一定是最小答案，再二分查找数组中大于等于当前平均值的位置，看是否在中间即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e5 + 7; int n, a[N]; bool check(ll f,ll sum) { a[n]+=f; if(lower_bound(a+1,a+1+n,(sum+f)/2.0/n)-a-1\u0026gt;(n\u0026gt;\u0026gt;1)){ a[n]-=f; return true; } a[n]-=f; return false; } void solve() { ll sum = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum += a[i]; } if (n \u0026lt; 3) { cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; return; } sort(a + 1, a + 1 + n); ll l = 0, r = 1e18, ans = 0; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid, sum)) { ans = mid; r = mid - 1; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D. Robert Hood and Mrs Hood 巨眼熟题，但还是想了半天\n先排序 $l,r$，优先排 $l$，然后开一个 $vis$ 用于记录在 $i$ 天结束的工作有几个\n从第一天开始，看有几个在周期内的任务，当前到访时间的答案即为这个任务数\n向下进行，要先减去前一天结束的任务数，再继续向下找符合条件的任务\n时间复杂度是 $O(n+k)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; struct Node { int l, r; bool operator\u0026lt;(const Node \u0026amp;a) const { return (l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l); } }; int n, d, k, mx, mn; Node a[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { cin \u0026gt;\u0026gt; a[i].l \u0026gt;\u0026gt; a[i].r; } int ans[N] = {0}; int vis[N] = {0}; int now = 1, tmp = 0; sort(a + 1, a + 1 + k); for (int i = 1; i \u0026lt;= n - d + 1; i++) { if (i \u0026gt; 1 \u0026amp;\u0026amp; vis[i - 1]) tmp -= vis[i - 1]; while (now \u0026lt;= k \u0026amp;\u0026amp; i + d - 1 \u0026gt;= a[now].l \u0026amp;\u0026amp; i \u0026lt;= a[now].r) { tmp++; vis[a[now].r]++; now++; } ans[i] = tmp; } mx = mn = 1; for (int i = 2; i \u0026lt;= n - d + 1; i++) { if (ans[mx] \u0026lt; ans[i]) mx = i; if (ans[mn] \u0026gt; ans[i]) mn = i; } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mn \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E. Rendez-vous de Marian et Robin 最短路径问题，可以想到用 $dijkstra$ 解决\n可以看出分为两种状态，骑马和步行\n开两个 $dist$ 数组，分别记录从 $1,n$ 为起点的 $dijkstra$\n$dist$ 要分别记录有马，没马状态下的值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=4e5+7, mod=1e9+7; int n, m, h, dist1[N], dist2[N], inf=1e18; bool vis[N], p[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edge[N]; void dijkstra(int s, int dist[]) { for (int i = 1; i \u0026lt;= n * 2; i++) dist[i] = inf; for (int i = 1; i \u0026lt;= n * 2; i++) vis[i] = 0; dist[s] = 0; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.insert({0, s}); if (p[s]) { dist[n + s] = 0; q.insert({0, n + s}); } while (!q.empty()) { int u = q.begin()-\u0026gt;second; q.erase(q.begin()); if (vis[u]) continue; vis[u] = 1; int t = (u \u0026gt; n ? u - n : u); for (auto [v, w] : edge[t]) { if (u \u0026gt; n) { if (dist[v + n] \u0026gt; dist[u] + w / 2) { dist[v + n] = dist[u] + w / 2; if (!vis[v + n]) q.insert({dist[v + n], v + n}); } } else { if (p[v]) { if (dist[v + n] \u0026gt; dist[u] + w) { dist[v + n] = dist[u] + w; if (!vis[v + n]) q.insert({dist[v + n], v + n}); } } else { if (dist[v] \u0026gt; dist[u] + w) { dist[v] = dist[u] + w; if (!vis[v]) q.insert({dist[v], v}); } } } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; h; for (int i = 1; i \u0026lt;= n; i++) p[i] = 0, edge[i].clear(); for (int i = 1; i \u0026lt;= h; i++) { int x; cin \u0026gt;\u0026gt; x; p[x] = 1; } for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; edge[u].push_back({v, w}); edge[v].push_back({u, w}); } int ans = inf; dijkstra(1, dist1); dijkstra(n, dist2); for (int i = 1; i \u0026lt;= n; i++) { ans = min(ans, max(min(dist1[i], dist1[i + n]), min(dist2[i], dist2[i + n]))); } if (ans == inf) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } F. Sheriff\u0026rsquo;s Defense 树形 dp, 状态 $dp[i][j]$ 表示选不选 $i$ 号节点\n类似没有上司的舞会\n明天写篇树形 dp 的学习记录\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,c,s,ans; ll dp[N][2]; vector\u0026lt;int\u0026gt;edge[N]; bool vis[N]; void dfs(int now,int fa){ for(auto i:edge[now]){ if(i!=fa){ dfs(i,now); dp[now][0]+=max(dp[i][0],dp[i][1]); dp[now][1]+=max(dp[i][0],dp[i][1]-(c\u0026lt;\u0026lt;1)); } } } void solve(){ ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c; for(int i=1;i\u0026lt;=n;i++){ edge[i].clear(); cin\u0026gt;\u0026gt;dp[i][1]; dp[i][0]=0; vis[i]=0; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); cout\u0026lt;\u0026lt;max(dp[1][0],dp[1][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 后两题感觉有点可写，后面再补。。。\nH. Robin Hood Archery 这题凭什么当 H\n显然后手者不可能胜，因为每次都是取当前最大值，那么后手不输的唯一机会就是平局\n奇数个数的时候，一定会输。\n偶数个数的时候，如果出现的数都出现了偶数次，那么就能打成平局\n直接异或的话，可能被某些数据 hack 掉，所以要加上哈希\n随机数生成尽量不要用 time(0) 这些不够随机的数\n使用 random_device 或 chrono::system_clock::now().time_since_epoch().count() 来生成高质量的随机数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e6+7, mod=1e9+7; int n,q,x; int a[N],s[N]; int l,r; random_device rnd; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; s[i]=s[i-1]^a[x]; } while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if((r-l+1)\u0026amp;1)cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else if(s[r]==s[l-1])cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); for(int i=1;i\u0026lt;=1e6;i++){ a[i]=rnd(); } int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf974/","summary":"A Robin Helps 按题意模拟 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,ans,a[N],cnt,k; void solve(){ cnt=ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026gt;=k)cnt+=a[i]; if(!a[i]\u0026amp;\u0026amp;cnt)cnt--,ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Robin Hood and the Major Oak 显然只有最后 $k$ 个点有效，$i^i$ 的奇偶性只和 $i$ 有关，公式加和即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#39;\\n\u0026#39; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; ll n, k; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll s = (n - k +","title":"Codeforces Round 974 (Div. 3)"},{"content":"ABC374 C - Separated Lunch 将 $n$ 个数尽量均分，因为最多只有 20 个数据，可以直接暴搜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e5+7, mod=1e9+7; int n,s,ans=INT_MAX; int a[N]; void dfs(int cnt,int sum){ if(cnt==n){ ans=min(ans,max(sum,s-sum)); return; } dfs(cnt+1,sum); dfs(cnt+1,sum+a[cnt+1]); } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s+=a[i]; } dfs(0,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC374 E - Sensor Optimization Dilemma 2 易想到二分答案，但是在 $check$ 过程中，对每个进程机器的选择需要考虑\n如果直接暴力从 $0$ 到 $mid/a[i]$ 一定会超时\n考虑如果需要生产 $ab$ 个单位的物品，那么第一种机器会消耗 $bp$，第二种机器则会消耗 $ap$，但在最优方案中，两种机器不可能同时到达这么多需求，因为这样就可以用性价比高的替代低的了\n假如 $ab=10,a=5,p=10,b=2,q=5$，我们会优先选 $a$ 因为他的性价比更高，在剩下大于等于 $ab$ 个需求时，我们只会选 $a$ 来满足需求，在小于 $ab$ 时，才会来找需要几个 $b$\n所以 $check$ 只需要找 $max(a[i],b[i])$ 次就够了\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define int long long const int N = 1e5 + 7, mod = 1e9 + 7; int n, x; int a[N], b[N], c[N], d[N]; bool check(int f) { int lst = x; for (int i = 1; i \u0026lt;= n; i++) { int cost = INT_MAX; for (int j = 0; j \u0026lt;= 100; j++) { int remaining = f - j * a[i]; cost = min(cost, j * b[i] + max(0LL, (int)ceil(1.0 * remaining / c[i])) * d[i]); } for (int j = 0; j \u0026lt;= 100; j++) { int remaining = f - j * c[i]; cost = min(cost, j * d[i] + max(0LL, (int)ceil(1.0 * remaining / a[i])) * b[i]); } lst -= cost; if (lst \u0026lt; 0) return false; } return lst \u0026gt;= 0; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i] \u0026gt;\u0026gt; c[i] \u0026gt;\u0026gt; d[i]; } int l = 0, r = 1e9, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { ans = mid; l = mid + 1; } else { r = mid - 1; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC374 F - Shipping 易想到用 $dp$ 解决\n开一个 $dp[i][t]$ 第一维代表已发了 $i$ 件，第二维代表最后一次发快递在什么时刻发的\n可以想到发快递的时间一定是 $t_{i}+k x, k \\in \\mathbb{Z}$\n因为每次发快递的时间，就是此快递刚到，或是先堆积不发，等到后面的快递到了一起发，只有这两种状态\n中间的等待都是无意义的，所以需要考虑的时间点其实并不多\n初始状态即为 $dp[1][t[1]]$ 意为第一件，时间为 $t[1]$，此时总花费值为 $0$\n然后从第二个进入 $dp$ 过程\n当 $i\u0026lt;=k$ 时，此时都可以一次性发出，计算在 $t[i]$ 时发出总花费值，更新 $dp[i][t[i]]$ 的值\n从上一次发 $k$ 件的时间时刻，到上一件的时刻，依次考虑在此时发快递的花费，按照上面的更新过程再来一遍\n最后在 $dp[n]$ 里找最小值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int k,n,x; ll t[N]; map\u0026lt;ll,ll\u0026gt;dp[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;t[i]; dp[1][t[1]]=0; for(int i=2;i\u0026lt;=n;i++){ if(i\u0026lt;=k){ ll res=0; for(int j=1;j\u0026lt;=i;j++)res+=t[i]-t[j]; if(!dp[i].count(t[i]))dp[i][t[i]]=res; else dp[i][t[i]]=min(dp[i][t[i]],res); } for(int j=i-k;j\u0026lt;=i-1;j++){ if(j\u0026gt;0){ for(auto [key,val]:dp[j]){ ll tmp=max(key+x,t[i]); ll res=val; for(int k=j+1;k\u0026lt;=i;k++)res+=tmp-t[k]; if(!dp[i].count(tmp))dp[i][tmp]=res; else dp[i][tmp]=min(dp[i][tmp],res); } } } } ll ans=1e18; for(auto [key,val]:dp[n])ans=min(ans,val); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [NOIP2017]奶酪 dfs 查询，以当前空洞为原点，计算其他空洞到这个圆心的距离，如果小于 2*r 就进行 dfs，如果能碰到 h 就可以完成任务\n要先找到接地的空洞，对他们都进行 dfs\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7; const int MOD = 1e9 + 7; int n, h, r; ll x[N], y[N], z[N]; bool vis[N]; bool flag = false; ll dis(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2) { return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2); } void dfs(int pos) { vis[pos] = true; if (z[pos] + r \u0026gt;= h) { flag = true; return; } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i] \u0026amp;\u0026amp; dis(x[pos], y[pos], z[pos], x[i], y[i], z[i]) \u0026lt;= 4 * r * r) { if (flag) return; dfs(i); } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h \u0026gt;\u0026gt; r; memset(vis, 0, sizeof(vis)); for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; z[i]; } flag = false; for (int i = 1; i \u0026lt;= n; ++i) { if (z[i] - r \u0026lt;= 0 \u0026amp;\u0026amp; !vis[i]) { dfs(i); } } cout \u0026lt;\u0026lt; (flag ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024102222/","summary":"ABC374 C - Separated Lunch 将 $n$ 个数尽量均分，因为最多只有 20 个数据，可以直接暴搜 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e5+7, mod=1e9+7; int n,s,ans=INT_MAX; int a[N]; void dfs(int cnt,int sum){ if(cnt==n){ ans=min(ans,max(sum,s-sum)); return; } dfs(cnt+1,sum); dfs(cnt+1,sum+a[cnt+1]); } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s+=a[i]; } dfs(0,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC374 E - Sensor Optimization Dilemma 2 易想到二分答案，但是在 $check$ 过程中，对每个进程机器的选择需要考虑 如果直接暴力从 $0$ 到","title":"近日刷题记录 3"},{"content":"AtCoder ABC372 D - Buildings 单调栈，逆向进行，找左侧比他大的数，此时栈的大小即为当前位的答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,h[N],ans[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;h[i]; } for(int i=n;i\u0026gt;=1;i--){ ans[i]=s.size(); while(s.size()\u0026amp;\u0026amp;s.top()\u0026lt;h[i])s.pop(); s.push(h[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC372 E - K-th Largest Connected Components 并查集，我们可以开 $n$ 个堆，把每个联通块都存到同一个栈当中，查询时栈的大小小于 $k$ 就输出 -1，反之输出相应值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n, q, u, v, op; set\u0026lt;int\u0026gt; s[N]; int fa[N]; int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { if (s[fx].size() \u0026lt; s[fy].size()) swap(fx, fy); fa[fy] = fx; for (int elem : s[fy]) { s[fx].insert(elem); } s[fy].clear(); } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { fa[i] = i; s[i].insert(i); } while (q--) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (op == 1) { unite(u, v); } else { int x = find(u); if (s[x].size() \u0026lt; v) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { auto it = s[x].rbegin(); advance(it, v - 1); cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC372 F - Teleporting Takahashi 2 根据题意，可以推断出是用 $dp$ 解决\n看题，可以发现一定是个从 $1$ 到 $n$ 的环，然后有 $m$ 条边是多出来的，那么多的方案数一定是由这 $m$ 条边决定的\n开一个 $f[i][k]$ 数组，$i$ 指代当前是哪个节点，$k$ 指代当前是第几步\n可以推断出每个点的第 $k$ 步的方案数\n$f_{v,k}=f_{v-1,k-1}+\\sum_{(u,v)\\in edge}f_{u,k-1}$\n$v$ 是当前点，$u$ 是 $m$ 条边中指向 $v$ 的点\n但如果这么开的话，时间空间都会过大，显然不能通过\n继续观察题目，发现我们可以将第二维滚动优化，变为一维数组\n每次向前一步，这个环的起点就从 $st$ 变更为 $st-1+n$\n可以看出，起始时，是以 1 为起点的一个环，进行了一次移动后，每个点都向后移动，8 这个点就移动到第一位了\n所以 $f[8]\u0026rsquo;$ 的值就是 $f[1]$，$f[1]\u0026rsquo;$ 的值就是 $f[2]$\n按照平移后的点的名称来计算 $f$ 数组的值，按照平移后的点来更新\n先用一个 $lst$ 数组来记录当前的 $f$ 数组中的值，避免更新过程中被覆盖\n接着，我们遍历 $edge$ 数组中存的边， $f_{v}=f_{v}+\\sum_{{u,v}\\in edge}lst_{u}$\n答案即为 $\\sum_{i=1}^{n}f_{i}$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+70, mod=998244353; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;edge; int n,m,k; ll f[N],lst[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--,v--; edge.push_back({u,v}); } f[0]=1; int st=0; for(int i=1;i\u0026lt;=k;i++){ st=(st-1+n)%n; for(auto x:edge){ int u=x.first,v=x.second; u=(st+1+u)%n,v=(st+v)%n; lst[v]=f[v]; lst[u]=f[u]; } for(auto x:edge){ int u=x.first,v=x.second; u=(st+1+u)%n,v=(st+v)%n; f[v]=(f[v]+lst[u])%mod; } } ll ans=0; for(int i=0;i\u0026lt;n;i++){ ans=(ans+f[i])%mod; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } NowCoder 食物链 开三倍空间，储存物种之间相食的关系，相邻层级之间如果是同一父节点，即有相食关系\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e5 + 7; const int mod = 1e9 + 7; int n, k; int d, x, y; int ans = 0; int fa[N]; int find(int x) { if (fa[x] != x) { fa[x] = find(fa[x]); } return fa[x]; } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { fa[fx] = fy; } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= 3 * n; i++) { fa[i] = i; } while (k--) { cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (x \u0026gt; n || y \u0026gt; n) { ans++; continue; } if (d == 1) { if (find(x) == find(y + n) || find(x) == find(y + 2 * n)) { ans++; continue; } unite(x, y); unite(x + n, y + n); unite(x + 2 * n, y + 2 * n); } else { if (find(x) == find(y) || find(x) == find(y + 2 * n)) { ans++; continue; } unite(x, y + n); unite(x + n, y + 2 * n); unite(x + 2 * n, y); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } [NOIP2010]关押罪犯 按冲突值从大到小排序，冲突值大的，先分开，同时标记分开的两个人，这两人现在不会产生冲突，继续向下看，如果遇到标记过的人，我们肯定将另一人放到之前和这个标记过的人冲突过的人所在的监狱，这样三个人都不会产生冲突，再往下如果继续在这三人中产生冲突，那么就是不可避免的了\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e5+7, mod=1e9+7; struct Node{ int a,b,c; bool operator\u0026lt;(const Node \u0026amp;t){return c\u0026gt;t.c;} }a[N]; int fa[N],fr[N]; int n,m; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ fa[find(x)]=fa[find(y)]; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ fa[i]=i; } for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;a[i].a\u0026gt;\u0026gt;a[i].b\u0026gt;\u0026gt;a[i].c; } sort(a+1,a+1+m); for(int i=1;i\u0026lt;=m;i++){ if(find(a[i].a)==find(a[i].b)){ cout\u0026lt;\u0026lt;a[i].c\u0026lt;\u0026lt;endl; return; } if(!fr[a[i].a])fr[a[i].a]=a[i].b; else unite(a[i].b,fr[a[i].a]); if(!fr[a[i].b])fr[a[i].b]=a[i].a; else unite(a[i].a,fr[a[i].b]); } cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } Parity game 拓展域并查集\n$n$ 个点，每个点拓展为两个点，正点和反点，如果 $a$ 和 $b$ 不能在同一个集合内，就把 $a$ 和 $b$ 的反节点放在一起，如果发现 $a$ 和 $b$ 的正节点已经在一起了，说明之前的关系与现在的关系冲突，即不能同时满足\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m; unordered_map\u0026lt;int,int\u0026gt;fa; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ fa[find(x)]=find(y); } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; n++; for(int i=0;i\u0026lt;m;i++){ int x,y; string op; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;op; x--; if(fa.count(x)==0)fa[x]=x,fa[x+n]=x+n; if(fa.count(y)==0)fa[y]=y,fa[y+n]=y+n; if(op==\u0026#34;even\u0026#34;){ if(find(x)==find(y+n)){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } unite(x,y); unite(x+n,y+n); } else{ if(find(x)==find(y)){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } unite(x,y+n); unite(x+n,y); } } cout\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 拆路 并查集本身不支持撤销操作，所以我们转为离线操作，所有数据记录后建图，先不加被删掉的边，在进行操作时，倒序进行，将后删的加回来即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,q,a,b; int fa[N],w[N],u[N],v[N],du[N],dv[N],ans[N]; char op; set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;s; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ int fx=find(x),fy=find(y); if(w[fx]\u0026gt;w[fy])fa[fy]=fx; else fa[fx]=fy; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;w[i]; fa[i]=i; } for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;u[i]\u0026gt;\u0026gt;v[i]; cin\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=q;i++){ cin\u0026gt;\u0026gt;op; if(op==\u0026#39;Q\u0026#39;)cin\u0026gt;\u0026gt;du[i]; else { cin\u0026gt;\u0026gt;du[i]\u0026gt;\u0026gt;dv[i]; s.insert({du[i],dv[i]}); s.insert({dv[i],du[i]}); } } for(int i=1;i\u0026lt;=m;i++){ if(s.find({u[i],v[i]})==s.end())unite(u[i],v[i]); } for(int i=q;i\u0026gt;0;i--){ if(dv[i])unite(du[i],dv[i]); else ans[i]=w[find(du[i])]; } for(int i=1;i\u0026lt;=q;i++){ if(ans[i])cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 老子的全排列呢 输出 1~8 的全排列\n主要是学习 next_permutation 和 prev_permutation\n前者是数组的下一个字典序更大的排序，后者是字典序更小的排序\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int n = 8; int a[8]; for (int i = 0; i \u0026lt; n; i++) { a[i] = i + 1; } do { for (int i = 0; i \u0026lt; 8; i++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; (i != 7 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;); } cout \u0026lt;\u0026lt; endl; } while (next_permutation(a, a + 8)); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 也可以 dfs 硬搜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; bool vis[10]; int a[10]; void dfs(int d){ if(d==9){ for(int i=1;i\u0026lt;=8;i++)cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==8?\u0026#34;\u0026#34;:\u0026#34; \u0026#34;); cout\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=8;i++){ if(!vis[i]){ a[d]=i; vis[i]=1; dfs(d+1); a[d]=0; vis[i]=0; } } } void solve(){ dfs(1); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/202410/","summary":"AtCoder ABC372 D - Buildings 单调栈，逆向进行，找左侧比他大的数，此时栈的大小即为当前位的答案 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,h[N],ans[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;h[i]; } for(int i=n;i\u0026gt;=1;i--){ ans[i]=s.size(); while(s.size()\u0026amp;\u0026amp;s.top()\u0026lt;h[i])s.pop(); s.push(h[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC372 E - K-th Largest Connected Components 并查集，我们可以开 $n$ 个堆，把每个联通块都存到同一个栈当中，查询时栈的大小小于 $k$","title":"近日刷题记录 2"},{"content":"AtCoder ABC371C Make Isomorphic 给你简单的无向图 $G$ 和 $H$ ，每个图都有 $N$ 个顶点：顶点 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。图 $G$ 有 $M_G$ 条边，其第 $i$ 条边 $(1\\leq i\\leq M_G)$ 连接顶点 $u_i$ 和 $v_i$ 。图 $H$ 有 $M_H$ 条边，它的第 $i$ 条边 $(1\\leq i\\leq M_H)$ 连接顶点 $a_i$ 和 $b_i$ 。\n您可以在图 $H$ 上执行以下操作，次数不限，可能为零。\n选择一对满足 $1\\le i\u0026lt;j\\leq N$ 的整数 $(i,j)$ 。支付 $A_{i,j}$ 点成本，如果 $H$ 中的顶点 $i$ 和 $j$ 之间没有边，则添加一条；如果有，则删除。\n求使 $G$ 和 $H$ 同构所需的最小总成本。\n因为 $n\u0026lt;=8$ 所以可以直接暴力，遍历 $h$ 图的每一种与 $g$ 图的对应方式\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 1e3 + 7, mod = 1e9 + 7; void solve() { int n; cin \u0026gt;\u0026gt; n; bool g[N][N], h[N][N]; memset(g, false, sizeof(g)); memset(h, false, sizeof(h)); int mg, mh; cin \u0026gt;\u0026gt; mg; for (int i = 0; i \u0026lt; mg; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u][v] = g[v][u] = true; } cin \u0026gt;\u0026gt; mh; for (int i = 0; i \u0026lt; mh; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; h[u][v] = h[v][u] = true; } int cost[N][N]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; cost[i][j]; cost[j][i] = cost[i][j]; } } int p[n + 1]; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; int ans = 1e9; do { int tmp = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (g[i][j] ^ h[p[i]][p[j]]) tmp += cost[p[i]][p[j]]; } } ans = min(ans, tmp); } while (next_permutation(p + 1, p + 1 + n)); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC371E I Hate Sigma Problems 记录每一个数相同的数上次出现的位置，即可得到其对答案作出的贡献\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; vector\u0026lt;int\u0026gt;a(N),nxt(N),last(N); void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; ll sum=0,cnt=0; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=n;i++){ if(!vis[a[i]]){ vis[a[i]]=1; cnt++; } sum+=cnt; nxt[last[a[i]]]=i; last[a[i]]=i; } ll ans=sum; for(int i=1;i\u0026lt;=n;i++){ int t=nxt[i]; if(!t)t=n+1; sum-=t-i; ans+=sum; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373D Hidden Weights You are given a directed graph with $N$ vertices and $M$ edges. The $j$-th directed edge goes from vertex $u_j$ to vertex $v_j$ and has a weight of $w_j$.\nFind one way to write an integer between $-10^{18}$ and $10^{18}$, inclusive, to each vertex such that the following condition is satisfied.\nLet $x_i$ be the value written on vertex $i$. For all edges $j=1,2,\\dots,M$, it holds that $x_{v_j} - x_{u_j} = w_j$. It is guaranteed that at least one such assignment exists for the given input.\n加边时，加双向边，权值相反，接着直接对某个点开始跑 $bfs$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,m; struct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; ll ans[N],vis[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v,w; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w; edge[u].push_back({v,w}); edge[v].push_back({u,-w}); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; queue\u0026lt;int\u0026gt;q; q.push(i); vis[i]=1; while(!q.empty()){ int u=q.front(); for(auto i:edge[u]){ if(!vis[i.v]){ vis[i.v]=1; ans[i.v]=ans[u]+i.w; q.push(i.v); } } q.pop(); } } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373EHow to Win the Election 啥吊题，一眼看出来排序完二分答案，调一年没调出来\n二分检测时，看当前位加上 $mid$ 票后，是否还有 $\u0026gt;=m$ 个人的票可能比他多\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; ll n, m, k; ll a[N], b[N]; ll s[N]; bool check(ll f, int pos) { ll lft = k - f; int x = upper_bound(b + 1, b + 1 + n, a[pos] + f) - b - 1; int y = n - m + 1; if (n - x \u0026gt;= m) return false; if (b[y] \u0026gt; a[pos]) return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 1]) \u0026gt; lft; return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 2] - a[pos]) \u0026gt; lft; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; if (n == m) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; \u0026#34;0 \u0026#34;; return; } memcpy(b, a, (n + 1) * sizeof(ll)); sort(b + 1, b + 1 + n); for (int i = 1; i \u0026lt;= n; i++) s[i] = s[i - 1] + b[i]; k -= s[n]; for (int i = 1; i \u0026lt;= n; i++) { ll l = 0, r = k, ans = 1e18; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid, i)) ans = mid, r = mid - 1; else l = mid + 1; } cout \u0026lt;\u0026lt; (ans \u0026lt; 1e18 ? ans : -1) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } NowCoder K-th Number 二分答案检测过程中，记录从头到尾每个子区间的比 $mid$ 大的数的个数，然后再遍历数组，看每个位置的数能否作为第 $k$ 大的数进入数组 $b$ ,最后看找的数是否大于 $m$ 个\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; ll m; int a[N],s[N]; bool check(int f){ ll sum=0; int l=0; for(int i=1;i\u0026lt;=n;i++)s[i]=s[i-1]+(a[i]\u0026gt;=f); for(int i=1;i\u0026lt;=n;i++){ while(s[i]-s[l]\u0026gt;=k)l++; sum+=l; } return sum\u0026gt;=m; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int l=1,r=1e9,ans=1; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [SCOI2010]传送带 三分两条传送带上的点，这两点间走直线，其余部分走传送带\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; const double eps=1e-4; double ax,ay,bx,by,cx,cy,dx,dy; double p,q,r; double fx,fy,ex,ey; double dis(double x,double y,double a,double b){ return sqrt(eps+(x-a)*(x-a)+(y-b)*(y-b)); } double chec(double x){ fx=cx+(x/dis(cx,cy,dx,dy)*(dx-cx)),fy=cy+(x/dis(cx,cy,dx,dy)*(dy-cy)); return dis(fx,fy,ex,ey)/r+(dis(cx,cy,dx,dy)-x)/q; } double check(double x){ ex=ax+(x/dis(ax,ay,bx,by)*(bx-ax)),ey=ay+(x/dis(ax,ay,bx,by)*(by-ay)); double l=0,r=dis(cx,cy,dx,dy); for(int i=1;i\u0026lt;=1000;i++){ double lm=l+(r-l)/3,rm=r-(r-l)/3; if(chec(lm)\u0026gt;=chec(rm))l=lm; else r=rm; } return chec(l)+x/p; } void solve(){ cin\u0026gt;\u0026gt;ax\u0026gt;\u0026gt;ay\u0026gt;\u0026gt;bx\u0026gt;\u0026gt;by\u0026gt;\u0026gt;cx\u0026gt;\u0026gt;cy\u0026gt;\u0026gt;dx\u0026gt;\u0026gt;dy\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q\u0026gt;\u0026gt;r; double l=0,r=dis(ax,ay,bx,by); for(int i=1;i\u0026lt;=1000;i++){ double ml=l+(r-l)/3,mr=r-(r-l)/3; if(check(ml)\u0026gt;=check(mr)){ l=ml; } else r=mr; } printf(\u0026#34;%.2lf\u0026#34;,check(l)); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小咪买东西 01 分数规划\n对 $double$ 类二分，限制二分循环次数来控制二分结束即可\n我们二分的是单位价格（即总价值/总花费）\n判断条件即为在这个单位条件下，买 $k$ 个商品能否仍然保持当前单位价格为正\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; int c[N],v[N]; double w[N]; bool check(double x){ for(int i=1;i\u0026lt;=n;i++)w[i]=v[i]-x*c[i]; sort(w+1,w+1+n,greater\u0026lt;double\u0026gt;()); double s=0; for(int i=1;i\u0026lt;=k;i++){ s+=w[i]; } return s\u0026gt;0; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;v[i]; double l=0,r=1e9; for(int i=1;i\u0026lt;=100;i++){ double mid=(l+r)/2; if(check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r)\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 栈和排序 知道入栈顺序，求字典序最大的出栈序列\n我们可以按倒序统计从后到当前位的最大值，在模拟出栈过程中，如果后面有比当前位大的数，那这一位就先不出栈\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; int a[N],mx[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=n;i\u0026gt;0;i--)mx[i]=max(mx[i+1],a[i]); for(int i=1;i\u0026lt;=n;i++){ while(!s.empty()\u0026amp;\u0026amp;s.top()\u0026gt;mx[i]){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } s.push(a[i]); } while(!s.empty()){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [NOIP2016]蚯蚓 如果全部在同一个队列或堆中进行存取，会超时。\n可以考虑分三个队列来储存，一个存的是原数据，切割后的两部分分开存在另外两个队列中。\n同时要考虑随时间变长这个过程，所以只存储原长，在取出时，加上当前时间增长的长度，存进去时，减掉增长的长度。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N = 1e5 + 7, mod = 1e9 + 7; int n, m, q, u, v, t; double p; queue\u0026lt;int\u0026gt; qu[3]; int a[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; t; p = static_cast\u0026lt;double\u0026gt;(u) / v; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + n, greater\u0026lt;int\u0026gt;()); for (int i = 1; i \u0026lt;= n; i++) qu[0].push(a[i]); for (int i = 1; i \u0026lt;= m; i++) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } int len = qu[pos].front() + (i - 1) * q; qu[pos].pop(); if (i % t == 0) cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#34; \u0026#34;; int l = len * p; int r = len - l; qu[1].push(l - q * i); qu[2].push(r - q * i); } cout \u0026lt;\u0026lt; endl; int cnt = 1; while (!qu[1].empty() || !qu[0].empty() || !qu[2].empty()) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } if (cnt % t == 0) cout \u0026lt;\u0026lt; qu[pos].front()+m*q \u0026lt;\u0026lt; \u0026#34; \u0026#34;; qu[pos].pop(); cnt++; } } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } Running Median 对顶堆\n开两个堆，按小到大各存一半，多出来的那个即为中位值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int p, n, a[N]; multiset\u0026lt;int\u0026gt; s1, s2; void balance() { while (s1.size() \u0026gt; s2.size() + 1) { s2.insert(*s1.rbegin()); s1.erase(prev(s1.end())); } while (s2.size() \u0026gt; s1.size()) { s1.insert(*s2.begin()); s2.erase(s2.begin()); } } void solve() { cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; s1.clear(); s2.clear(); int cnt=0,ans[N]; for (int i = 1; i \u0026lt;= n; i++) { if (s1.empty() || a[i] \u0026lt;= *s1.rbegin()) { s1.insert(a[i]); } else { s2.insert(a[i]); } balance(); if (i % 2 == 1) { ans[++cnt]=*s1.rbegin(); } } cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(int i=1;i\u0026lt;=cnt;i++){ cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(i%10==0\u0026amp;\u0026amp;i!=cnt)cout\u0026lt;\u0026lt;endl; } cout \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 任务 可以看到 $x$ 的系数远大于 $y$, 那么在对原数据排序时，优先 $x$.\n遍历每一个任务，将能完成当前任务的所有机器都插入堆中，用二分在堆中找到 $y$ 最小的机器，再继续向下遍历\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; struct Node{ int x,y; bool operator \u0026lt; (const Node\u0026amp; a){ if(x==a.x)return y\u0026gt;a.y; return x\u0026gt;a.x; } }; ll n,m,cnt,ans; Node ma[N],as[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;ma[i].x\u0026gt;\u0026gt;ma[i].y; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;as[i].x\u0026gt;\u0026gt;as[i].y; sort(as+1,as+1+m); sort(ma+1,ma+1+n); multiset\u0026lt;int\u0026gt;s; for(int i=1,j=1;i\u0026lt;=m;i++){ while(j\u0026lt;=n\u0026amp;\u0026amp;as[i].x\u0026lt;=ma[j].x)s.insert(ma[j++].y); auto it=s.lower_bound(as[i].y); if(it!=s.end())cnt++,ans+=500*as[i].x+2*as[i].y,s.erase(it); } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 叠积木 维护附加信息的并查集\n开 $fa[N]$ 并查集 $d[i]$ $i$ 下方的积木数 $cnt[i]$ $i$ 所在的联通块的数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int q, x, y; int fa[N], cnt[N], d[N]; int find(int x) { if (fa[x] == x) return x; int t = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = t; } void unite(int a, int b) { int fx = find(a), fy = find(b); if (fx != fy) { fa[fx] = fy; d[fx] = cnt[fy]; cnt[fy] += cnt[fx]; } } void solve() { cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; N; i++) { fa[i] = i; d[i] = 0; cnt[i] = 1; } while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;M\u0026#39;) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unite(x, y); } else { cin \u0026gt;\u0026gt; x; find(x); cout \u0026lt;\u0026lt; d[x] \u0026lt;\u0026lt; endl; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/202409/","summary":"AtCoder ABC371C Make Isomorphic 给你简单的无向图 $G$ 和 $H$ ，每个图都有 $N$ 个顶点：顶点 $1$ 、 $2$ 、 $\\ldots$ 、 $N$ 。图 $G$ 有 $M_G$ 条边，其第 $i$ 条边 $(1\\leq i\\leq M_G)$ 连接顶点 $u_i$ 和 $v_i$ 。图 $H$ 有 $M_H$ 条边，它的第 $i$ 条边 $(1\\leq i\\leq M_H)$ 连接顶点 $a_i$ 和 $b_i$ 。 您可以在图 $H$ 上执行以下操作，次数不限，可能为零。 选择一对满足 $1\\le i\u0026lt;j\\leq N$ 的整数 $(i,j)$ 。支付 $A_{i,j}$ 点成本，如果 $H$ 中的顶点 $i$ 和 $j$ 之间","title":"近日刷题记录"},{"content":"前言 好久没写题了，被暴打。\n参赛过程也是抽象，开局就罚站 30 min\n补题 L 网络预选赛 好不容易卡出来题面，看到 L 已经过了不少了，卡了半天才提交过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e3+7, mod=1e9+7; void solve(){ int n, m, ans = 0; char mp[N][N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; mp[i][j]; for(int i = 1; i \u0026lt; n; i++){ for(int j = 1; j \u0026lt; m; j++){ if(mp[i][j] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j] == \u0026#39;p\u0026#39; \u0026amp;\u0026amp; mp[i][j+1] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j+1] == \u0026#39;c\u0026#39;) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } K 取沙子游戏 奇数时，一直取 1 即可。\n为偶数时，如果 $\\text{lowbit}(n) \\leq k$，先手取 $\\text{lowbit}(n) \\leq k$，再不断模仿后者即可。\n反之，随意取后的 $\\text{lowbit}$ 一定 $\\leq k$，后手一定获胜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(lowbit(n)\u0026lt;=k)cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B 军训 II 显然是排序后的不整齐度最小，那么方案数就是数组中的重复数的排列组合之和，要注意有升序降序两种，但只有一种数时不考虑\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=998244353; ll n,a[N],ans=0,vis[N],cnt=0,answ=1,com[N]; void solve(){ cin\u0026gt;\u0026gt;n; com[0]=1; for(int i=1;i\u0026lt;=n;i++){ com[i]=(com[i-1]*i)%mod; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(!vis[a[i]])cnt++; vis[a[i]]++; } sort(a+1,a+1+n); for(int i=1;i\u0026lt;=n;i++){ ll mx=a[i],mn=a[i]; for(int j=i+1;j\u0026lt;=n;j++){ mx=max(mx,a[j]),mn=min(mn,a[i]); ans+=(mx-mn); } } for(int i=1;i\u0026lt;=n;i++){ if(vis[a[i]]==1)continue; answ=(answ*com[vis[a[i]]])%mod; vis[a[i]]=1; } if (cnt \u0026gt; 1) answ = (answ * 2) % mod; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;answ\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D 编码器-解码器 观察题目\n$S_i\u0026rsquo;=\\begin{cases}S_{i-1}\u0026rsquo;+a_i+S_{i-1}\u0026rsquo;\u0026amp; i\u0026gt;1\\\\a_1\u0026amp;i=1\\end{cases}$ 可以发现 $S_{i}\u0026rsquo;$ 是由 $S_{i-1}\u0026rsquo;$ 变换而来的，所以可以递推每一位 $i$ 上的答案\n可以开一个三维数组 $f[i][l][r]$ : $i$ 指第几位 $l$ 指从 $t$ 的第几位开始 $r$ 指到 $t$ 的第几位结束\n通过这种方法，我们可以记录 $t$ 的所有子串在当前 $i$ 位出现的次数，只需要将我们需要的子串拼接起来即可得到能找到的 $t$ 串数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=998244353; string s,t; int n,m; ll f[N][N][N]; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; n=s.length(),m=t.length(); for(int i=0;i\u0026lt;m;i++) if(s[0]==t[i])f[0][i][i]=1; for(int i=1;i\u0026lt;n;i++){ for(int l=0;l\u0026lt;m;l++){ for(int r=l;r\u0026lt;m;r++){ f[i][l][r]=(f[i-1][l][r]*2) % mod; if(l==r){ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+1) % mod; } else{ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+f[i-1][l+1][r]) % mod; if(s[i]==t[r])f[i][l][r]=(f[i][l][r]+f[i-1][l][r-1]) % mod; for(int k=l;k\u0026lt;r;k++) f[i][l][r]=(f[i][l][r]+f[i-1][l][k]*f[i-1][k+1][r]) % mod; for(int k=l+1;k\u0026lt;r;k++) if(s[i]==t[k])f[i][l][r]=(f[i][l][r]+f[i-1][l][k-1]*f[i-1][k+1][r]) % mod; } } } } cout\u0026lt;\u0026lt;f[n-1][0][m-1]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024ccpconline/","summary":"前言 好久没写题了，被暴打。 参赛过程也是抽象，开局就罚站 30 min 补题 L 网络预选赛 好不容易卡出来题面，看到 L 已经过了不少了，卡了半天才提交过 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e3+7, mod=1e9+7; void solve(){ int n, m, ans = 0; char mp[N][N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; mp[i][j]; for(int i = 1; i \u0026lt; n; i++){ for(int j = 1; j \u0026lt; m; j++){ if(mp[i][j] ==","title":"2024CCPC网络赛"},{"content":"2024 河南萌新联赛 6 装备二选一（一） 直接比较结果即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int t1 = 100 * b * a + 100 * (100 - a); int t2 = 100 * d * c + 100 * (100 - c); cout \u0026lt;\u0026lt; (t2 \u0026gt; t1 ? \u0026#34;YES\\n\u0026#34; : \u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } 追寻光的方向 开一个 $suf$ 数组，用于记录 $i$ 位置后最大的数的位置，再用 $cnt$ 统计一共需要多少次转移即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) const int N = 1e5+7, mod = 1e9+7; int n, l[N], suf[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i]; suf[n]=suf[n-1]=n; suf[n] = n; for (int i = n-1; i \u0026gt; 0; i--) { if (l[i+1] \u0026gt; l[suf[i+1]]) suf[i] = i+1; else suf[i] = suf[i+1]; } // for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;suf[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; int cnt = 0, now = 1; while (now \u0026lt; n) { now = suf[now]; cnt++; } cout \u0026lt;\u0026lt; cnt - 1 \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 百变吗喽 本身想用 $kmp$ 找最长前缀最长后缀二者两加为 $n$ 时即符合条件，一直只对 $95%$，改不出来，换题解的思路了，标记前缀后缀相同的位置，如果二者能碰到，或超过，就有答案存在，方案数为 $l-r+1$ 个\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int n,i1,i2; string s1,s2; int main(){ cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; n=s2.length(); for(i1=0;i1\u0026lt;n-1 \u0026amp;\u0026amp; s1[i1]==s2[i1];i1++); for(i2=n-1;i2\u0026gt;=0 \u0026amp;\u0026amp; s1[i2-1]==s2[i2];i2--); if(i2\u0026lt;=i1){ cout\u0026lt;\u0026lt;i1-i2+1\u0026lt;\u0026lt;endl; for(int i=i2;i\u0026lt;=i1;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s2[i]\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B6/","summary":"2024 河南萌新联赛 6 装备二选一（一） 直接比较结果即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int t1 = 100 * b * a + 100 * (100 - a); int t2 = 100 * d * c + 100 * (100 - c); cout \u0026lt;\u0026lt; (t2 \u0026gt; t1 ? \u0026#34;YES\\n\u0026#34; : \u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } 追寻光的方向 开一个 $suf$ 数组，用于记录 $i$ 位置后","title":"2024萌新联赛6"},{"content":"2024 河南萌新联赛 5 平方根 直接 $sqrt$ 向下取整即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ unsigned long long n; cin\u0026gt;\u0026gt;n; long long ans=floor(sqrt(n)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } 爬楼梯 递归\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int f[1000005],mod=1e9+7; f[0]=f[1]=1; int n; cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=3;j++){ if(i-j\u0026lt;0)break; f[i]=(f[i]+f[i-j])%mod; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } 区间问题 1 线段树板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) #define int long long int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } signed main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); cin\u0026gt;\u0026gt;m; while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op; if (op == 1) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cin\u0026gt;\u0026gt;x; cout \u0026lt;\u0026lt; query(1, x, x, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 哥德巴赫猜想 埃氏筛找 $5e4$ 以内的质数，暴力枚举是否有符合的即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e7 + 7, mod = 1e9 + 7; bool isp[N]; vector\u0026lt;int\u0026gt; pri; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; pri.size(); i++) { for (int j = pri.size() - 1; j \u0026gt; i; j--) { int tmp = pri[i] + pri[j]; if(tmp\u0026gt;=n)continue; if (isp[n - tmp]) { cout \u0026lt;\u0026lt; pri[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - tmp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pri[j] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } } cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(isp, 1, sizeof(isp)); isp[0] = isp[1] = 0; for (int i = 2; i * i \u0026lt;= N; i++) { if (isp[i]) { for (int j = i * i; j \u0026lt;= N; j += i) isp[j] = 0; } } for (int i = 2; i \u0026lt;= N; i++) if (isp[i]) pri.push_back(i); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 学生分组 先找超出的 $mx$，缺少的 $mn$，如果二者相等，直接得到答案，如果有一者更大，就判断能否用其他的所有数据补全这部分，如果可以答案即为这部分\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; ll l,r; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; // sort(a+1,a+1+n); ll mn=0,mnn=0,mx=0,mxx=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i]\u0026lt;l)mn+=(l-a[i]),mnn+=(r-a[i]); else if(a[i]\u0026gt;r)mx+=(a[i]-r),mxx+=(a[i]-l); else mnn+=(r-a[i]),mxx+=(a[i]-l); } ll ans=0; if(mx==mn)ans=mx; else if(mx\u0026gt;mn){ if(mx\u0026gt;mnn){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mx; } else{ if(mn\u0026gt;mxx){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mn; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小美想游泳 $dijkstra$ 但是找的不是最短路，而是路径中经过的 $max$ 最小，改变 $dist$ 数组中统计的数据即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5; #define int long long const int INF = LLONG_MAX; struct Node { int y, v; Node(int _y, int _v) { y = _y; v = _v; } }; int n, m, s, t, dist[N]; vector\u0026lt;Node\u0026gt; edge[N]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); fill(dist, dist + N, INF); dist[s] = 0; q.insert({0, s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto i : edge[x]) { int new_dist = max(dist[x], i.v); if (new_dist \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = new_dist; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } signed main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, a; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; a; edge[u].push_back({v, a}); edge[v].push_back({u, a}); } cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; dijkstra(s, t); return 0; } 小美想打音游 显然是将所有分数变为已有分数中的一个，将数组排序后，从小到大遍历，计算当前魔力值即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; int sum = 0; vector\u0026lt;int\u0026gt; a(n + 1,0); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum += a[i]; } int ans = LLONG_MAX, pre = 0; sort(a.begin() + 1, a.end()); for (int i = 1; i \u0026lt;= n; i++) { pre += a[i]; ans = min(ans, a[i] * i - pre + sum - pre - a[i] * (n - i)); } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; return 0; } 区间问题 2 开始觉得是线段树，但是数据有 $l = 0$, 流汗黄豆了\n用 $st$ 表可以过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e6+7; #define int long long int n, m; int a[N]; int st[N][21]; int l2[N]; void build() { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; (1 \u0026lt;\u0026lt; j) \u0026lt;= n; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j-1], st[i + (1 \u0026lt;\u0026lt; (j-1))][j-1]); } } } int query(int l, int r) { int j = l2[r - l + 1]; return max(st[l][j], st[r - (1 \u0026lt;\u0026lt; j) + 1][j]); } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; l2[1] = 0; for (int i = 2; i \u0026lt;= n; i++) { l2[i] = l2[i / 2] + 1; } build(); cin \u0026gt;\u0026gt; m; while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; query(l, r) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 小美想跑步 单向建图，建两个，反向找到的值即为跑回点 $1$ 的值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e6 + 7, mod = 1e9 + 7; #define int long long struct Node { int y, v; Node(int _y, int _v) : y(_y), v(_v) {} }; int n, m; vector\u0026lt;Node\u0026gt; edge[N], edges[N]; vector\u0026lt;int\u0026gt; dist(N); void dijkstra(int s, vector\u0026lt;Node\u0026gt;edge[]) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; q; fill(dist.begin(), dist.end(), INT_MAX); dist[s] = 0; q.push({0, s}); while (!q.empty()) { int d = q.top().first; int x = q.top().second; q.pop(); if (d \u0026gt; dist[x]) continue; for (auto\u0026amp; i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { dist[i.y] = dist[x] + i.v; q.push({dist[i.y], i.y}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; edge[u].push_back({v, w}); edges[v].push_back({u, w}); } ll ans = 0; dijkstra(1, edge); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } dijkstra(1, edges); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 日历游戏 暴力 $SG$ 函数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[30][20][40],day[20]={0,31,28,31,30,31,30,31,31,30,31,30,31}; void solve(){ int y,m,d; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; cout\u0026lt;\u0026lt;(sg[y%100][m][d]?\u0026#34;YES\\n\u0026#34;:\u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); for(int i=8;i\u0026lt;=12;i++) for(int j=1;j\u0026lt;=31;j++)sg[24][i][j]=1; sg[24][8][1]=0; for(int i=24;i\u0026gt;=0;i--){ for(int j=12;j\u0026gt;=1;j--){ if(i==24\u0026amp;\u0026amp;j\u0026gt;=8)continue; int d=day[j]; if(i%4==0\u0026amp;\u0026amp;j==2)d++; for(int k=d;k\u0026gt;0;k--){ int x=i,y=j,z=k+1; if(z\u0026gt;d)z=1,y++; if(y\u0026gt;12)y=1,x++; if(sg[x][y][z]==0){ sg[i][j][k]=1; continue; } x=i,y=j+1,z=k; bool flag=0; if(y\u0026gt;12)y=1,x++,flag=1; else if(y!=2){ if(z\u0026lt;=day[y])flag=1; } else{ int tmp=28; if(i%4==0)tmp=29; if(z\u0026lt;=tmp)flag=1; } if(flag\u0026amp;\u0026amp;sg[x][y][z]==0)sg[i][j][k]=1; } } } int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 小美想收集 可以二分答案，判断是否符合二分图的性质\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; int n, m; int f[N]; struct Node { int x, y, z; }; vector\u0026lt;Node\u0026gt; a; int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } bool check(int mid) { iota(f, f + n + n + 1, 0); for (auto x : a) { if (x.z \u0026gt; mid) { int fx = find(x.x), fy = find(x.y); if (fx == fy) return false; f[find(x.x + n)] = find(x.y); f[find(x.y + n)] = find(x.x); } } return true; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; a.resize(m + 1); for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i].x \u0026gt;\u0026gt; a[i].y \u0026gt;\u0026gt; a[i].z; int l = 0, r = 1e6, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid - 1,ans=mid; else l = mid + 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B5/","summary":"2024 河南萌新联赛 5 平方根 直接 $sqrt$ 向下取整即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ unsigned long long n; cin\u0026gt;\u0026gt;n; long long ans=floor(sqrt(n)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } 爬楼梯 递归 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int f[1000005],mod=1e9+7; f[0]=f[1]=1; int n; cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=3;j++){ if(i-j\u0026lt;0)break; f[i]=(f[i]+f[i-j])%mod; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } 区间问题 1 线段树板 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) #define int long long int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum","title":"2024萌新联赛5"},{"content":"AtCoder Beginner Contest 366 补题 A - Election 2 判断当前是否有值大于 $n/2$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,t,a; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t\u0026gt;\u0026gt;a; if(n==1\u0026amp;\u0026amp;t==0\u0026amp;\u0026amp;a==0){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else if(t\u0026gt;n/2||a\u0026gt;n/2){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B - Vertical Writing 翻转字符串，同时对翻转后的每行从末尾开始清 * 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,mx=0; cin\u0026gt;\u0026gt;n; string s[N]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; mx=max(mx,(int)s[i].length()); } string ans[mx+1]; for(int i=0;i\u0026lt;mx;i++){ for(int j=n;j\u0026gt;0;j--){ if(i\u0026gt;=s[j].length()) ans[i]+=\u0026#34;*\u0026#34;; else ans[i]+=s[j][i]; } } for(int i=0;i\u0026lt;mx;i++){ bool flag=0; for(int j=n-1;j\u0026gt;=0;j--){ if(ans[i][j]==\u0026#39;*\u0026#39;\u0026amp;\u0026amp;!flag){ ans[i][j]=\u0026#39; \u0026#39;; } if(ans[i][j]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;ans[i][j]\u0026lt;=\u0026#39;z\u0026#39;){ flag=1; } } cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - Balls and Bag Query 开一个 map 记录某一个值当前出现了几次，第一次出现就 cnt++, 出现次数变为 0 就 cnt\u0026ndash; 最后输出 cnt\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int q; cin\u0026gt;\u0026gt;q; unordered_map\u0026lt;int,int\u0026gt;vis; int cnt=0; while(q--){ int op,x; cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x; if(!vis[x])cnt++; vis[x]++; } else if(op==2){ cin\u0026gt;\u0026gt;x; vis[x]--; if(!vis[x])cnt--; } else cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D - Cuboid Sum Query 三维前缀和板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e2+10, mod = 1e9+7; #define int long long void solve(){ int n, a[N][N][N], q, lx, rx, ly, ry, lz, rz; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt;= n; j++){ for(int k = 1; k \u0026lt;= n; k++) cin \u0026gt;\u0026gt; a[i][j][k]; } } for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i - 1][j][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j - 1][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j][k - 1]; cin \u0026gt;\u0026gt; q; while(q--){ cin \u0026gt;\u0026gt; lx \u0026gt;\u0026gt; rx \u0026gt;\u0026gt; ly \u0026gt;\u0026gt; ry \u0026gt;\u0026gt; lz \u0026gt;\u0026gt; rz; ll sum = a[rx][ry][rz] - (lx \u0026gt; 1 ? a[lx-1][ry][rz] : 0) - (ly \u0026gt; 1 ? a[rx][ly-1][rz] : 0) - (lz \u0026gt; 1 ? a[rx][ry][lz-1] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 ? a[lx-1][ly-1][rz] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ry][lz-1] : 0) + (ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[rx][ly-1][lz-1] : 0) - (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ly-1][lz-1] : 0); cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } E - Manhattan Multifocal Ellipse 可以枚举 $x$ 从 $-2e6$ 到 $2e6$，去掉原式中的绝对值得到，$\\sum_{x_i \u0026lt; x} (x - x_i) + \\sum_{x_i \\geq x} (x_i - x)$，通过此公式可以得到每个 $x$ 的 $\\sum_{i=1}^{n} |x - x_i|$，同理求得 $\\sum_{i=1}^{n} |y - y_i|$，分别存入两个数组，将两个数组升序排序，此时只需要用双指针对每个 $x$ 找到其对应的最大的 $y$ 对应的位置，累加即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; auto fc(vector\u0026lt;int\u0026gt; \u0026amp;a){ sort(a.begin(), a.end()); vector\u0026lt;ll\u0026gt; dis; int r = 2e6+7; int id = 0; ll pre = 0, suf = accumulate(a.begin(), a.end(), 0LL); for(int i = -r; i \u0026lt;= r; i++){ ll sum = 0; while(id \u0026lt; a.size() \u0026amp;\u0026amp; a[id] \u0026lt; i){ pre += a[id]; suf -= a[id]; ++id; } sum = 1LL * id * i - pre + suf - 1LL * (a.size() - id) * i; dis.push_back(sum); } sort(dis.begin(), dis.end()); return dis; } void solve(){ int n, d; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; vector\u0026lt;int\u0026gt; x(n), y(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; auto dx = fc(x); auto dy = fc(y); ll ans = 0; int id = dx.size(); for(auto i : dx){ while(id \u0026gt; 0 \u0026amp;\u0026amp; dy[id-1] + i \u0026gt; d) --id; ans += id; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } F - Maximum Composition 函数之间，选择的偏序（顺序）问题。这个偏序怎么定义呢？函数 $f_i, f_j$，如果 $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$，则有 $a_i(a_jx + b_j) + b_i \\geq a_j(a_ix + b_i) + b_j$，我们把 $i, j$ 分离在一左一右，得到 $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$。\n如果 $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$，则 $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$，那么排序顺序已经清晰\n要使 $ans$ 最大，不光要找到偏序顺序，还要找到用哪 k 个函数，那就转化为了 01背包 问题\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; struct Node { int a, b; bool operator \u0026lt; (const Node \u0026amp;t) const { return (a - 1) * t.b \u0026lt; (t.a - 1) * b; } }; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;Node\u0026gt; l(n + 1); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i].a \u0026gt;\u0026gt; l[i].b; sort(l.begin()+1,l.end()); vector\u0026lt;ll\u0026gt; dp(k + 1, 0); dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = k; j \u0026gt;= 1; j--) { dp[j] = max(dp[j - 1] * l[i].a + l[i].b, dp[j]); } } cout \u0026lt;\u0026lt; dp[k] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/abc366/","summary":"AtCoder Beginner Contest 366 补题 A - Election 2 判断当前是否有值大于 $n/2$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,t,a; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t\u0026gt;\u0026gt;a; if(n==1\u0026amp;\u0026amp;t==0\u0026amp;\u0026amp;a==0){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else if(t\u0026gt;n/2||a\u0026gt;n/2){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B - Vertical Writing 翻转字符串，同时对翻转后的每行从末尾开始清 * 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,mx=0; cin\u0026gt;\u0026gt;n; string s[N]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; mx=max(mx,(int)s[i].length()); } string ans[mx+1]; for(int i=0;i\u0026lt;mx;i++){","title":"ABC366"},{"content":"2024 杭电多校 4 补题 多层血条 模拟, 只会最覆盖最上面的一层血量, 所以不用担心下层血量是什么, 只用找到最上面的那一层是什么即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string h=\u0026#34;ABCDE\u0026#34;; void solve(){ int n,m,hp,dmg; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;hp\u0026gt;\u0026gt;dmg; int lst=(hp/m)%5,x=m; string upp; upp.resize(m+1,\u0026#39; \u0026#39;); if(hp\u0026lt;=m){ for(int i=1;i\u0026lt;=hp;i++)upp[i]=h[0],x=i; } else{ int rest=hp%m; // cout\u0026lt;\u0026lt;rest\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;i++){ if(rest)upp[i]=h[lst],x=i,rest--; else upp[i]=h[(lst-1+5)%5]; } } while(dmg){ if(upp[x]==\u0026#39;.\u0026#39;)break; upp[x]=\u0026#39;.\u0026#39;; x--; dmg--; if(x==0)x=m; } for(int i=0;i\u0026lt;=n+1;i++){ for(int j=0;j\u0026lt;=m+1;j++){ if((i==0\u0026amp;\u0026amp;j==0)||(i==0\u0026amp;\u0026amp;j==m+1)||(i==n+1\u0026amp;\u0026amp;j==0)||(i==n+1\u0026amp;\u0026amp;j==m+1))cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; else if(i==0||i==n+1)cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; else if(j==0||j==m+1)cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;; else cout\u0026lt;\u0026lt;upp[j]; } cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 昵称检索 昵称分姓名和生日两部分, 而姓名需在生日前, 那么就要找尽量前的姓名, 尽量后的生日\n预处理 $nxt[i][j]$ 表示 $s[i][n]$ 中字符 $j$ 最靠左的出现位置, 从左到右找到名字的最后一位在哪, 记为 $a[i]$, 同理,倒着求生日的最后一位在哪, 记为 $b[i]$\n最后找有多少对 $(i, j)$ 满足 $i \u0026lt; j$ 即可.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e6+7, mod=1e9+7; int n,m,ans[N]; int day[15] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string s,a; int vis[26],mp[N][26]; int fd(int *u){ int x=m+1; for(int i=3;~i;i--){ x--; if(x\u0026lt;1)return 0; x=mp[x][u[i]]; } return x; } int fc(){ int x=0; for(int i=0;i\u0026lt;a.size();i++){ x++; if(x\u0026gt;m)return m+1; x=mp[x][a[i]-\u0026#39;a\u0026#39;]; } return x; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;10;i++)vis[i]=0; for(int i=1;i\u0026lt;=m;i++){ if(s[i-1]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;9\u0026#39;)vis[s[i-1]-\u0026#39;0\u0026#39;]=i; for(int j=0;j\u0026lt;=9;j++)mp[i][j]=vis[j]; } for(int i=0;i\u0026lt;=m+1;i++)ans[i]=0; for(int i=1;i\u0026lt;=12;i++){ for(int j=1;j\u0026lt;=day[i];j++){ int p[4]; p[0]=i/10,p[1]=i%10,p[2]=j/10,p[3]=j%10; int x=fd(p); if(x)ans[x]++; } } for(int i=m;i\u0026gt;1;i--)ans[i-1]+=ans[i]; for(int j=0;j\u0026lt;26;j++)vis[j]=m+1; for(int i=m;i;i--){ if(s[i-1]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;z\u0026#39;)vis[s[i-1]-\u0026#39;a\u0026#39;]=i; for(int j=0;j\u0026lt;26;j++)mp[i][j]=vis[j]; } int sum=0; while(n--){ cin\u0026gt;\u0026gt;a; int x=fc(); if(x\u0026lt;m)sum+=ans[x+1]; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 最优 $k$ 子段 前缀和统计区间和, 用二分找答案\n开一个 set 存当前前缀和和位置, 判断合法区间条件为, 当前位置能否和 set 中所存的元素构成大于等于 $lim$ 的一个片段, 同时片段长度要为质数, 如果能找到, 就将当前记录个数 + 1.\n二分条件即为 check 返回的值是否大于等于 $k$, 需要注意 $k * 2 \\leq n$, 因为最小的质数为 2, $k * 2$ 是 $n$ 的最小长度\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e8+7, mod=1e9+7; bool ip[N]; int n,k; ll a[N]; int check(int lim){ set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; s; s.insert({0,0}); int res=0; for(int i=1;i\u0026lt;=n;i++){ auto it = s.begin(); while(it != s.end()){ if(a[i] - it-\u0026gt;first \u0026lt; lim) it = s.end(); else if(ip[i - it-\u0026gt;second]) break; else it++; } if(it != s.end()) res++, s.clear(); s.insert({a[i], i}); } return res; } void solve(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i=1; i\u0026lt;=n; i++){ cin \u0026gt;\u0026gt; a[i]; a[i]+=a[i-1]; } if(2*k \u0026gt; n){ cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; return; } int l = -2000, r = N; while(l \u0026lt; r){ ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; if(check(mid) \u0026gt;= k) l = mid; else r = mid - 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(ip, 1, sizeof(ip)); ip[0] = ip[1] = 0; for(int i=2; i*i\u0026lt;=N; i++){ if(ip[i]){ for(int j=i*i; j\u0026lt;=N; j+=i) ip[j]=0; } } int t; cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024hdu4/","summary":"2024 杭电多校 4 补题 多层血条 模拟, 只会最覆盖最上面的一层血量, 所以不用担心下层血量是什么, 只用找到最上面的那一层是什么即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string h=\u0026#34;ABCDE\u0026#34;; void solve(){ int n,m,hp,dmg; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;hp\u0026gt;\u0026gt;dmg; int lst=(hp/m)%5,x=m; string upp; upp.resize(m+1,\u0026#39; \u0026#39;); if(hp\u0026lt;=m){ for(int i=1;i\u0026lt;=hp;i++)upp[i]=h[0],x=i; } else{ int rest=hp%m; // cout\u0026lt;\u0026lt;rest\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;i++){ if(rest)upp[i]=h[lst],x=i,rest--; else upp[i]=h[(lst-1+5)%5]; } } while(dmg){ if(upp[x]==\u0026#39;.\u0026#39;)break; upp[x]=\u0026#39;.\u0026#39;; x--; dmg--; if(x==0)x=m; } for(int i=0;i\u0026lt;=n+1;i++){ for(int j=0;j\u0026lt;=m+1;j++){ if((i==0\u0026amp;\u0026amp;j==0)||(i==0\u0026amp;\u0026amp;j==m+1)||(i==n+1\u0026amp;\u0026amp;j==0)||(i==n+1\u0026amp;\u0026amp;j==m+1))cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; else if(i==0||i==n+1)cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; else if(j==0||j==m+1)cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;; else cout\u0026lt;\u0026lt;upp[j]; } cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 昵称检索 昵称分姓名和生日两部分,","title":"2024HDU4"},{"content":"2024 萌新联赛 4 D 简单的素数 遍历 $1 \\sim \\sqrt{n}$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8+10; void solve(){ int n,flag=0; cin\u0026gt;\u0026gt;n; for(int i=2;i*i\u0026lt;=n;i++){ if(n%i==0){ flag=1; break; } } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } F 小雷的算式 按题意模拟\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; #define int long long void solve(){ string s; cin\u0026gt;\u0026gt;s; int ans=0,tmp=0; vector\u0026lt;int\u0026gt;a; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;+\u0026#39;){ a.push_back(tmp); ans+=tmp,tmp=0; } else{ tmp*=10; tmp+=(s[i]-\u0026#39;0\u0026#39;); } } a.push_back(tmp); ans+=tmp; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;()); cout\u0026lt;\u0026lt;a[0]; for(int i=1;i\u0026lt;a.size();i++){ cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;a[i]; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H 聪明且狡猾的恶魔 $1$ 号恶魔为了保证自己能获胜，会给 $\\frac{n}{2}$ 个恶魔一人一个金币，保证自己能获胜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,x; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;n; int ans=x; if(n\u0026amp;1)ans-=n/2; else ans-=n/2-1; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B 小雷的神奇电脑 经验证，可得答案会在排序后相邻的两个元素中得出\n同或结果即为：所有位都为 $1$ 的值减去二者的异或\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int a[n+100]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int u[32],cnt=1; u[0]=1; for(int i=1;i\u0026lt;32;i++){ cnt*=2; u[i]=u[i-1]+cnt; } sort(a+1,a+1+n); int ans=2e9; for(int i=1;i\u0026lt;n;i++){ ans=min(ans,a[i]^a[i+1]); } cout\u0026lt;\u0026lt;u[m-1]-ans\u0026lt;\u0026lt;endl; } C 岗位分配 志愿者无差别，意思是分配到岗位上的是谁不重要，重要的是人数\n先固定每个岗位该有的人，再对剩下的人分析\n剩下的人每个人都有 $(n + 1)$ 种选择，那么我们的目标就是将他们分为 $(n + 1)$ 组，即用 $n$ 个隔板分开他们\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7, mod = 998244353; ll pre[N]; void init(){ pre[0] = 1; for(int i = 1; i \u0026lt; N; i++){ pre[i] = (pre[i-1] * i) % mod; } } ll rmod(ll a, ll m) { ll res = 1, y = m - 2; while (y \u0026gt; 0) { if (y % 2 == 1) res = (res * a) % m; a = (a * a) % m; y /= 2; } return res; } ll com(ll n, ll k) { if (k \u0026gt; n) return 0; return pre[n] * rmod(pre[k], mod) % mod * rmod(pre[n - k], mod) % mod; } ll mod_exp(ll base, ll exp, ll m) { ll res = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) res = (res * base) % m; base = (base * base) % m; exp /= 2; } return res; } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); ll ans = 1; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; m-=a[i]; } ans = (ans * com(m+n, m)) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; init(); // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } I 马拉松 $x \\rightarrow y$ 中间的点都忽略，找两侧各有几个点，相乘即为答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 3e5+7; int n,x,y; int s[N],vis[N]; vector\u0026lt;int\u0026gt;v[N]; bool onxy[N]; int dfs(int x){ vis[x]=1; s[x]=1; if(x==y)onxy[x]=1; for(auto i:v[x]){ if(!vis[i]){ s[x]+=dfs(i); onxy[x]|=onxy[i]; } } return s[x]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(x); int lx; for(auto i:v[x]){ if(onxy[i]==1){ lx=s[x]-s[i]; } } cout\u0026lt;\u0026lt;1LL*lx*s[y]\u0026lt;\u0026lt;endl; } J 尖塔第四强的高手 LCA 板，小于 $1e5$ 的 fibonacci 数只有 $24$ 个，提前找到，再根据题意，对所有的点依次跑 LCA 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; vector\u0026lt;int\u0026gt; v[N]; int d[N], f[N][32]; vector\u0026lt;int\u0026gt; a; void dfs(int x, int y) { d[x] = d[y] + 1; f[x][0] = y; for (int i = 1; i \u0026lt;= 31; i++) { f[x][i] = f[f[x][i-1]][i-1]; } for (int i = 0; i \u0026lt; v[x].size(); i++) { if (d[v[x][i]] == 0) dfs(v[x][i], x); } } int lca(int x, int y) { if (d[x] \u0026lt; d[y]) swap(x, y); for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; d[f[x][i]] \u0026gt;= d[y]) x = f[x][i]; } if (x == y) return x; for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; f[y][i] != 0 \u0026amp;\u0026amp; f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } return f[x][0]; } void solve() { int f1 = 1, f2 = 1; a.push_back(f1); a.push_back(f2); while (true) { int nxt = f1 + f2; if (nxt \u0026gt; N) break; a.push_back(nxt); f1 = f2; f2 = nxt; } int n, r, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; n; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; v[x].push_back(y); v[y].push_back(x); } dfs(r, 0); while (q--) { int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; tmp; for (int i = k; i \u0026lt; a.size(); i++) { if (x + a[i] \u0026gt; n) break; tmp.push_back(x + a[i]); } int ans=0; if(tmp.size()){ ans = tmp[0]; for (int i = 1; i \u0026lt; tmp.size(); i++) { ans = lca(ans, tmp[i]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E AND 质数只有一个偶数 $2$，如果没有 $2$，就不可能有符合的区间，因为最后一位一定为 $1$\n在有 $2$ 的时候，因为必须选 $2$，同时 $2, 3$ 这个区间也不符合，符合条件的就有 $r - l + 1 - 2$ 个，如果只有 $2$，要记得特判\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8 + 10; vector\u0026lt;int\u0026gt; prime; bool isnp[N]; void pre(int n) { fill(isnp, isnp + n + 1, false); for (int i = 2; i \u0026lt;= n; i++) { if (!isnp[i]) prime.push_back(i); for (auto j : prime) { if (j * i \u0026gt; n) break; isnp[j * i] = true; if (i % j == 0) break; } } } void solve() { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; auto l = lower_bound(prime.begin(), prime.end(), x)-prime.begin(); auto r = upper_bound(prime.begin(), prime.end(), y)-prime.begin(); cout \u0026lt;\u0026lt; (r - l) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (x == 2 \u0026amp;\u0026amp; x == y || x \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; else { cout \u0026lt;\u0026lt; (r - l - 2) \u0026lt;\u0026lt; endl; } } int main() { pre(N); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } K 比赛 用线段树，记录每个数字出现的次数，再从左到右，从右到左，各查询一遍，记录左右两次比 $a[i]$ 大、小、相等的有几个，最后得到答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long lll; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) const int N = 1e5 + 7, mod = 1e9 + 7; int n, a[N], tr[N \u0026lt;\u0026lt; 2], ll[N], lu[N], rl[N], ru[N], le[N], re[N]; void update(int now, int l, int r, int pos, int val) { if (l == r) { tr[now] += val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(ls, l, mid, pos, val); else update(rs, mid + 1, r, pos, val); tr[now] = tr[ls] + tr[rs]; } int query(int now, int l, int r, int s, int t) { if (s \u0026gt; r || t \u0026lt; l) return 0; if (s \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) return tr[now]; int mid = (l + r) \u0026gt;\u0026gt; 1; return query(ls, l, mid, s, t) + query(rs, mid + 1, r, s, t); } void solve() { lll ans = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; memset(tr, 0, sizeof(tr)); for (int i = 1; i \u0026lt;= n; i++) { ll[i] = query(1, 1, N, 1, a[i]); lu[i] = query(1, 1, N, a[i], N); le[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); } memset(tr, 0, sizeof(tr)); for (int i = n; i \u0026gt; 0; i--) { rl[i] = query(1, 1, N, 1, a[i]); ru[i] = query(1, 1, N, a[i], N); re[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); ans += 1LL * rl[i] * lu[i]; ans += 1LL * ru[i] * ll[i]; ans -= 1LL * re[i] * le[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B4/","summary":"2024 萌新联赛 4 D 简单的素数 遍历 $1 \\sim \\sqrt{n}$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8+10; void solve(){ int n,flag=0; cin\u0026gt;\u0026gt;n; for(int i=2;i*i\u0026lt;=n;i++){ if(n%i==0){ flag=1; break; } } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } F 小雷的算式 按题意模拟 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; #define int long long void solve(){ string s; cin\u0026gt;\u0026gt;s; int ans=0,tmp=0; vector\u0026lt;int\u0026gt;a; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;+\u0026#39;){ a.push_back(tmp); ans+=tmp,tmp=0; } else{ tmp*=10; tmp+=(s[i]-\u0026#39;0\u0026#39;); } } a.push_back(tmp); ans+=tmp; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;()); cout\u0026lt;\u0026lt;a[0]; for(int i=1;i\u0026lt;a.size();i++){ cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;a[i]; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H 聪明且狡猾的恶魔 $1$ 号恶魔","title":"2024萌新联赛4"},{"content":"LCA(最近公共祖先) 简介 两个节点的最近公共祖先，就是两个点的公共祖先里，离根最远的那个\n$LCA({u}) = u$ $u$ 是 $v$ 的祖先，当且仅当 $LCA({u, v}) = u$ 如果 $u, v$ 互不为祖先，那么二者存在 $LCA({u, v})$ 的两颗不同子树中 前序遍历中，$LCA(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $LCA(S)$ 则出现在所有 $S$ 中元素之后 两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $LCA(A\\cup B)=LCA(LCA(A), LCA(B))$ 两点的最近公共祖先必定处在树上两点间的最短路上 $d(u,v)=h(u)+h(v)-2h(LCA(u,v))$，其中 $d$ 是树上两点间的距离，$h$ 代表某点到树根的距离 求法 朴素算法 每次都找深度较大的点，令其向上搜索，显然两个点最后会相遇，相遇位置即为 $LCA$，或者先调整深度较大的点，使二者深度相同后，一起向上跳转，最后也会相遇\n需要先 $dfs$ 预处理整棵树，此过程为 $O(n)$, 查询过程也为 $O(n)$\n倍增算法 简介 是朴素算法的改进版本，预处理 $fa[x][i]$ 数组，使游标可以快速移动，减少跳转次数。\n$fa[x][i]$ 表示的是点 $x$ 的第 $2^i$ 个祖先。可以通过 $dfs$ 预处理得到\n优化跳转的过程：首先，我们要将 $u, v$ 跳转到同一深度，计算得出二者深度之差为 $y$，将 $y$ 用二进制拆分，将 $y$ 次游标跳转优化为 $y$ 的二进制中 $1$ 的个数次跳转。接着从最大的 $i$ 开始循环尝试，一直到 $0$，如果 $fa[u][i] \\neq fa[v][i]$，那么最后的 $LCA$ 为 $fa[u][0]$\n预处理的时间复杂度是 $O(n \\log n)$, 查询的时间复杂度是 $O(\\log n)$\n模板 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 6e5+7; int n,m,s; vector\u0026lt;int\u0026gt;v[N]; int d[N],f[N][32]; void dfs(int x,int y){ d[x]=d[y]+1; f[x][0]=y; for(int i=1;i\u0026lt;=31;i++){ f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i\u0026lt;v[x].size();i++){ if(d[v[x][i]]==0)dfs(v[x][i],x); } } int lca(int x,int y){ if(d[x]\u0026lt;d[y])swap(x,y); for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;d[f[x][i]]\u0026gt;=d[y]) x=f[x][i]; } if(x==y)return x; for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;f[y][i]!=0\u0026amp;\u0026amp;f[x][i]!=f[y][i]){ x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;lca(x,y)\u0026lt;\u0026lt;endl; } } 例题 HDU 2586 树上最短路查询\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 40005; vector\u0026lt;int\u0026gt;v[N],w[N]; int fa[N][31],cost[N][31],dep[N]; int n,m,a,b,c; void dfs(int now,int fno){ fa[now][0]=fno; dep[now]=dep[fa[now][0]]+1; for(int i=1;i\u0026lt;31;i++){ fa[now][i]=fa[fa[now][i-1]][i-1]; cost[now][i]=cost[fa[now][i-1]][i-1]+cost[now][i-1]; } int sz=v[now].size(); for(int i=0;i\u0026lt;sz;i++){ if(v[now][i]==fno)continue; cost[v[now][i]][0]=w[now][i]; dfs(v[now][i],now); } } int lca(int x,int y){ if(dep[x]\u0026gt;dep[y])swap(x,y); int tmp=dep[y]-dep[x],ans=0; for(int j=0;tmp;++j,tmp\u0026gt;\u0026gt;=1){ if(tmp\u0026amp;1)ans+=cost[y][j],y=fa[y][j]; } if(y==x)return ans; for(int j=30;j\u0026gt;=0\u0026amp;\u0026amp;y!=x;j--){ if(fa[x][j]!=fa[y][j]){ ans+=cost[x][j]+cost[y][j]; x=fa[x][j]; y=fa[y][j]; } } ans+=cost[x][0]+cost[y][0]; return ans; } void solve(){ memset(fa,0,sizeof(fa)); memset(cost,0,sizeof(cost)); memset(dep,0,sizeof(dep)); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ v[i].clear(); w[i].clear(); } for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; v[a].push_back(b); v[b].push_back(a); w[a].push_back(c); w[b].push_back(c); } dfs(1,0); for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;lca(a,b)\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } Tarjan 算法 简介 是离线算法，需要使用并查集记录某个结点的祖先结点\n首先接受输入边(领接链表)，查询边(另一个链表中)。查询边其实是虚拟加的边，每次输入查询边的时候，都将此边和其反向边加入到 $queryedge$ 数组里 然后对其进行 $DFS$ 遍历，同时使用 $vis$ 数组记录结点是否被访问，$parent$ 记录当前结点的父亲结点 每次遍历到某个结点的时候，认为这个结点的根节点就是他本身，。让以这个结点为根节点的 $DFS$ 全遍历完以后，再将这个结点的根节点设置为这个结点的父一级结点 回溯的时候，如果以该节点为起点，$queryedge$ 查询边的另一个结点也恰好访问过了，直接更新查询边的 $LCA$ 结果 输出结果 Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$。\n朴素的 Tarjan 算法处理所有 $m$ 次询问的时间复杂度为 $O(m \\alpha(m+n, n) + n)$\n模板 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Edge { public: int toVertex, fromVertex; int next; int LCA; Edge() : toVertex(-1), fromVertex(-1), next(-1), LCA(-1) {}; Edge(int u, int v, int n) : fromVertex(u), toVertex(v), next(n), LCA(-1) {}; }; const int MAX = 100; int head[MAX], queryHead[MAX]; Edge edge[MAX], queryEdge[MAX]; int parent[MAX], visited[MAX]; int vertexCount, queryCount; int find(int x) { if (parent[x] == x) { return x; } else { return parent[x] = find(parent[x]); } } void tarjan(int u) { parent[u] = u; visited[u] = 1; for (int i = head[u]; i != -1; i = edge[i].next) { Edge\u0026amp; e = edge[i]; if (!visited[e.toVertex]) { tarjan(e.toVertex); parent[e.toVertex] = u; } } for (int i = queryHead[u]; i != -1; i = queryEdge[i].next) { Edge\u0026amp; e = queryEdge[i]; if (visited[e.toVertex]) { queryEdge[i ^ 1].LCA = e.LCA = find(e.toVertex); } } } int main() { memset(head, 0xff, sizeof(head)); memset(queryHead, 0xff, sizeof(queryHead)); cin \u0026gt;\u0026gt; vertexCount \u0026gt;\u0026gt; queryCount; int count = 0; for (int i = 0; i \u0026lt; vertexCount - 1; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; edge[count] = Edge(start, end, head[start]); head[start] = count; count++; edge[count] = Edge(end, start, head[end]); head[end] = count; count++; } count = 0; for (int i = 0; i \u0026lt; queryCount; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; queryEdge[count] = Edge(start, end, queryHead[start]); queryHead[start] = count; count++; queryEdge[count] = Edge(end, start, queryHead[end]); queryHead[end] = count; count++; } tarjan(1); for (int i = 0; i \u0026lt; queryCount; i++) { Edge\u0026amp; e = queryEdge[i * 2]; cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; e.fromVertex \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; e.toVertex \u0026lt;\u0026lt; \u0026#34;) \u0026#34; \u0026lt;\u0026lt; e.LCA \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://blog.050623.xyz/posts/study/lca/","summary":"LCA(最近公共祖先) 简介 两个节点的最近公共祖先，就是两个点的公共祖先里，离根最远的那个 $LCA({u}) = u$ $u$ 是 $v$ 的祖先，当且仅当 $LCA({u, v}) = u$ 如果 $u, v$ 互不为祖先，那么二者存在 $LCA({u, v})$ 的两颗不同子树中 前序遍历中，$LCA(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $LCA(S)$ 则出现在所有 $S$ 中元素之后 两点集并的最近公","title":"LCA"},{"content":"线段树学习 简介 常用的用来维护 区间信息 的数据结构。\n线段树可以在 $O(\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n实现过程即为将每个长度不为 $1$ 的片段分成左右两个片段，不断递归下去，把区间分为树形结构，通过合并两端来求值\n模板 单点修改 操作 $1$ 单点修改\n操作 $2$ 查询区间最小值\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv; }tr[N\u0026lt;\u0026lt;2]; void update(int now){ tr[now].minv=min(tr[ls].minv,tr[rs].minv); } void build(int now,int l,int r){ if(l==r){ tr[now].minv=a[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now].minv=val; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } int query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now].minv; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return min(query(ls,l,r,s,mid),query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n)\u0026lt;\u0026lt;endl; } return 0; } 区间合并 不光记录最小值，同时记录最小值出现次数\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv,cnt; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.minv=min(l.minv,r.minv); if(l.minv==r.minv)a.cnt=l.cnt+r.cnt; else if(l.minv\u0026lt;r.minv)a.cnt=l.cnt; else a.cnt=r.cnt; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],1}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,1};; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).minv\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;query(1,x,y,1,n).cnt\u0026lt;\u0026lt;endl; } return 0; } 最大子段和 数组片段中有正有负，需要统计的数据变多，合并时可能涉及到左右片段相接部分\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int mss,mpre,msuf,s; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.mss=max({l.mss,r.mss,l.msuf+r.mpre}); a.mpre=max(l.mpre,l.s+r.mpre); a.msuf=max(r.msuf,r.s+l.msuf); a.s=l.s+r.s; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],a[l],a[l],a[l]}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,val,val,val}; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).mss\u0026lt;\u0026lt;endl; } return 0; } 懒惰标记 对片段修改，用懒惰标记标记当前段，之后再取到时，将标记传到子段\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { cin \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 懒惰标记 2 不光有区间加，还有区间乘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n, mod, q; int a[N]; struct Tag { int mul, add; }; struct Node { int len, sum; Tag tag; } tr[N\u0026lt;\u0026lt;2]; Tag operator + (const Tag \u0026amp;a, const Tag \u0026amp;b) { return {a.mul * b.mul % mod, (a.add * b.mul + b.add) % mod}; } Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = (l.sum + r.sum) % mod; a.tag = {1, 0}; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, Tag t) { tr[now].tag = tr[now].tag + t; tr[now].sum = (tr[now].sum * t.mul + tr[now].len * t.add) % mod; } void pushdown(int now) { if (tr[now].tag.mul != 1 || tr[now].tag.add) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = {1, 0}; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], {1, 0}}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, Tag val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans = (ans + query(ls, l, r, s, mid)) % mod; if (r \u0026gt; mid) ans = (ans + query(rs, l, r, mid + 1, t)) % mod; return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (q--) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; Tag z = {1, 0}; if (op == 1) { cin \u0026gt;\u0026gt; z.mul; modify(1, x, y, 1, n, z); } else if (op == 2) { cin \u0026gt;\u0026gt; z.add; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } 线段树上二分 重点改的是查询部分\n找到区间中第一个大于等于 $d$ 的位置\n但是 $l == s$, $r == t$ 时不返回，继续递归\n时间复杂度仍然是 $O(\\log n)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 int n, m; int a[N]; struct Node { int mx; } tr[N \u0026lt;\u0026lt; 2]; Node operator+(const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.mx = max(l.mx, r.mx); return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void build(int now, int l, int r) { if (l == r) { tr[now] = {a[l]}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void change(int now, int s, int t, int pos, int val) { if (s == t) { tr[now] = {val}; return; } int mid = (s + t) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) change(ls, s, mid, pos, val); if (pos \u0026gt; mid) change(rs, mid + 1, t, pos, val); update(now); } int search(int now, int l, int r, int s, int t, int d) { if (l == s \u0026amp;\u0026amp; r == t) { if (tr[now].mx \u0026lt; d) return -1; if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; if (tr[ls].mx \u0026gt;= d) return search(ls, l, mid, s, mid, d); return search(rs, mid + 1, r, mid + 1, t, d); } int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) return search(ls, l, r, s, mid, d); if (r \u0026gt; mid) return search(rs, l, r, mid + 1, t, d); int pos = search(ls, l, mid, s, mid, d); if (pos != -1) return pos; return search(rs, mid + 1, r, mid + 1, t, d); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, d; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { change(1, 1, n, x, y); } else { cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; search(1, x, y, 1, n, d) \u0026lt;\u0026lt; endl; } } return 0; } ","permalink":"https://blog.050623.xyz/posts/study/%E7%BA%BF%E6%AE%B5%E6%A0%91/","summary":"线段树学习 简介 常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(\\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 实现过程即为将每个长度不为 $1$ 的片段分成左右两个片段，不断递归下去，把区间分为树形结构，通过合并两端来求值 模板 单点修改 操作 $1$","title":"线段树"},{"content":"2024 河南萌新联赛 3 B 正则表达式 签到，四个数字都在 $[1,255]$ 之间即为合法\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s) { int n = s.size(); int num = 0, dots = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;.\u0026#39;) { if (num \u0026lt; 0 || num \u0026gt; 255) return false; num = 0; } else if (isdigit(s[i])) { num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) return false; } else { return false; } } if (num \u0026lt; 0 || num \u0026gt; 255) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; int cnt = 0; for(int i=1;i\u0026lt;=n;i++) { string s; cin \u0026gt;\u0026gt; s; if (check(s)) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C Circle 找规律，手模两遍发现 $n = 1$，时为 $2$，其他情况都是每次增加 $(2 \\cdot (n - 1))$ 个圆，化简关系式得 $S(n) = n^2 - n + 2$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n==0) cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;; else cout\u0026lt;\u0026lt;1LL*n*n-n+2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } J keillempkill学姐の卷积 按题意模拟即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define int long long int n,m; int a[25][25],b[25][25],c[25][25]; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++)cin\u0026gt;\u0026gt;a[i][j]; } for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;m;j++)cin\u0026gt;\u0026gt;b[i][j]; } for(int i=0;i\u0026lt;m-n+1;i++){ for(int j=0;j\u0026lt;m-n+1;j++){ int now=0; for(int x=i;x\u0026lt;n+i;x++){ for(int y=j;y\u0026lt;n+j;y++) now+=(a[x-i][y-j]*b[x][y]); } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } L SSH 大 STL\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int q, n, m; unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; ips, keys; unordered_map\u0026lt;string, string\u0026gt; p2p; int main() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= m; i++) { string pub, pri; cin \u0026gt;\u0026gt; pub \u0026gt;\u0026gt; pri; p2p[pri] = pub; } for (int i = 1; i \u0026lt;= n; i++) { string ip; int k; cin \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; k; for (int j = 1; j \u0026lt;= k; j++) { string user, pub; int t; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; t; ips[ip].push_back(user); for (int l = 1; l \u0026lt;= t; l++) { cin \u0026gt;\u0026gt; pub; keys[user].push_back(pub); } } } while (q--) { string user, ip, pri; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; pri; if (find(ips[ip].begin(), ips[ip].end(), user) != ips[ip].end() \u0026amp;\u0026amp; find(keys[user].begin(), keys[user].end(), p2p[pri]) != keys[user].end()) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } } } F 累加器 正解是暴力跑一遍，记录从 $1$ 到 $i$ 的改变次数，询问时用 $pre[r] - pre[l]$ 即可\n赛时 eng 在找规律了，可以发现从第 $0$ 位开始，每次改变次数都 $/2$，如果遇到前一位原来为 $1$ 现在为 $0$ 的，就将现在记录的 $now + 1$，最后也可得出答案\n赛时代码\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int x,y,xx[32],yy[32]; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int t=x+y; for(int i=31;i\u0026gt;=0;i--){ if((x\u0026gt;\u0026gt;i)\u0026amp;1)xx[i]=1; else xx[i]=0; if((t\u0026gt;\u0026gt;i)\u0026amp;1)yy[i]=1; else yy[i]=0; } int now=y,ans=y; for(int i=1;i\u0026lt;32;i++){ if(xx[i-1]==1\u0026amp;\u0026amp;yy[i-1]==0)now++; ans+=(now/2); // cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; now/=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } I 游戏 两次最短路，一次只可以走通路的，另一次先拿钥匙，再走到终点，比较两次哪个短哪个是答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; #define int long long struct Node { int y, w; }; vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; edge(N), edges(N); int n, m, k, dist[N]; int a, b, c, d; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int dijkstra(int s, int t, vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; \u0026amp;edge) { q.clear(); fill(dist, dist + N, LLONG_MAX); dist[s] = 0; q.insert({dist[s], s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto \u0026amp;i : edge[x]) { if (dist[x] + i.w \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.w; q.insert({dist[i.y], i.y}); } } } return dist[t]; } signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (d == 1) { edge[a].push_back({b, c}); edge[b].push_back({a, c}); } edges[a].push_back({b, c}); edges[b].push_back({a, c}); } int ans = LLONG_MAX, fk = -1; fk = dijkstra(1, k, edge); if (fk != LLONG_MAX) { ans = min(dijkstra(1, n, edge), dijkstra(k, n, edges) + fk); } else { ans = dijkstra(1, n, edge); } if (ans == LLONG_MAX) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } K 暴食之史莱姆 对于一个史莱姆，他在左侧能吃掉的数量，即为左侧第一个比他小的史莱姆能吃的数量，右侧同理。所以他能吃的数量即为左侧能吃的数量加上右侧能吃的数量\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; int n,a[N],f[N]; deque\u0026lt;int\u0026gt;q; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i]) q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } q.clear(); for(int i=n;i\u0026gt;0;i--){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i])q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;f[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E 区间 线段树\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5+10; int a[N]; struct Node{ int l,r,mx,len; }tr[N\u0026lt;\u0026lt;2]; void build(int now,int l,int r){ tr[now]=Node{r-l+1,r-l+1,r-l+1,r-l+1}; if(l==r)return; int mid=(l+r)\u0026gt;\u0026gt;1; build((now\u0026lt;\u0026lt;1),l,mid); build(((now\u0026lt;\u0026lt;1)|1),mid+1,r); } Node update(Node x,Node y){ if(x.len==0)return y; if(y.len==0)return x; Node ans; ans.len=x.len+y.len; int tmp=max(x.mx,y.mx); ans.mx=max(x.r+y.l,tmp); ans.l=x.l; ans.r=y.r; if(x.l==x.len)ans.l+=y.l; if(y.r==y.len)ans.r+=x.r; return ans; } void change(int now,int l,int r,int x){ if(l==r){ a[l]^=1; tr[now].l=tr[now].r=tr[now].mx=a[l]^1; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(x\u0026lt;=mid)change((now\u0026lt;\u0026lt;1),l,mid,x); else change(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x); tr[now]=update(tr[(now\u0026lt;\u0026lt;1)],tr[((now\u0026lt;\u0026lt;1)|1)]); } Node query(int now,int l,int r,int x,int y){ if(l\u0026gt;=x\u0026amp;\u0026amp;r\u0026lt;=y)return tr[now]; int mid=(l+r)\u0026gt;\u0026gt;1; Node ans={0,0,0,0}; if(x\u0026lt;=mid)ans=query((now\u0026lt;\u0026lt;1),l,mid,x,y); if(y\u0026gt;mid)ans=update(ans,query(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x,y)); return ans; } int main(){ int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; build(1,1,n); while(q--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x; if(op==1)change(1,1,n,x); else { cin\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;query(1,1,n,x,y).mx\u0026lt;\u0026lt;endl; } } } H 魔法 用 $dp[x][y][k]$, 记录在 $(x, y)$ 处使用 $k$ 次魔法，最小的权值之和\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int n,m,h; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;h; vector a(n + 1, vector(m + 1, 0)); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++)cin\u0026gt;\u0026gt;a[i][j]; vector dp(n + 1, vector(m + 1, vector(n + m, 1e16))); dp[1][1][0]=a[1][1],dp[1][1][1]=0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (i == 1 \u0026amp;\u0026amp; j == 1) continue; for (int k = 0; k \u0026lt; n + m; k++) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + a[i][j]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k] + a[i][j]); if (k) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1]); } } } } for(int i=0;i\u0026lt;n+m;i++){ if(dp[n][m][i]\u0026lt;h){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } } } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); } G 求值 易想到将 $w$ 和前面的关系式分开看，答案即为关系式和 $w$ 最接近时的答案，可以想到 $A$ $B$ $C$ 三者的顺序其实无所谓，只和他们的大小有关系，假设关系式结果为 $S$，$A \u0026lt; B \u0026lt; C$, 那么 $S$ 最小就是 $A \\cdot n$，最大就是 $C \\cdot n$，所以我们先固定从选 $n$ 个 $A$ 开始，每次循环中增加 $1$ 个 $B - A$ 的值，这样就在 $O(n)$ 的时间中解决了 $A$ $B$ 的数量，再在每次循环中针对 $C$ 进行选取，如果当前 $(W - S) / (C - B)$ 的值大于 $i$ 那么我们就选 $i$ 个 $C$，否则就选 $(W - S) / (C - B - A)$ 个 $C$ 和 $(W - S) / (C - B) + 1$ 的值进行比较，选最优的\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int aa[3],a,b,c,n,w; cin\u0026gt;\u0026gt;aa[0]\u0026gt;\u0026gt;aa[1]\u0026gt;\u0026gt;aa[2]\u0026gt;\u0026gt;n\u0026gt;\u0026gt;w; sort(aa,aa+3); a=aa[0],b=aa[1]-aa[0],c=aa[2]-aa[1]; int ans,res=w-a*n; ans=res; if(ans\u0026lt;=0){ cout\u0026lt;\u0026lt;-ans\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=n;i++){ res-=b; ans=min(ans,abs(res)); if(res\u0026lt;=0)break; if(c==0)continue; int t=res/c; if(t\u0026gt;i)ans=min(ans,res-c*i); else ans=min(ans,res-c*t); if(i\u0026gt;t)ans=min(ans,abs(res-c*(t+1))); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } G 开心消消乐 一个数异或他本身为 $0$，如果相邻的数相同，他们只需要消耗一次，不同的就增加消耗，特例是为 $0$，的不需要消耗\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,last=-1,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x!=last){ last=x; if(x!=0) ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } ","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B3/","summary":"2024 河南萌新联赛 3 B 正则表达式 签到，四个数字都在 $[1,255]$ 之间即为合法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s) { int n = s.size(); int num = 0, dots = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;.\u0026#39;) { if (num \u0026lt; 0 || num \u0026gt; 255) return false; num = 0; } else if (isdigit(s[i])) { num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) return false; } else { return false; } } if (num \u0026lt; 0 || num \u0026gt; 255) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; int cnt = 0; for(int i=1;i\u0026lt;=n;i++) { string s; cin \u0026gt;\u0026gt; s; if (check(s))","title":"2024萌新联赛3"},{"content":"最小生成树基础算法学习 定义 我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。\n注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。\nKruskal 算法 简介 基本思想是从小到大加入边，是个贪心算法。\n将所有边的边权排序，从小到大加入生成树中，如果某次加入会生成环就舍弃此边，直到加入了 $n - 1$ 条边，形成树。时间复杂度为 $O(m \\log m)$\n实现 struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int find(int i){ if(fa[i]==i)return i; return fa[i]=find(fa[i]); } int Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=find(a[i].x),y=find(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } return cnt; } 例题 洛谷P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int findset(int i){ if(fa[i]==i)return i; return fa[i]=findset(fa[i]); } void Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=findset(a[i].x),y=findset(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } if(cnt==1) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;a[i].x\u0026gt;\u0026gt;a[i].y\u0026gt;\u0026gt;a[i].v; Kruskal(); return 0; } Prim 算法 简介 基本思想是从一个点开始，不断加点，而不是 Kruskal 的加边\n具体做法就是在当前图可连点上选择距离最近的一个点，将这个点加入图，继续找最近的点，直到所有的点都找到\n时间复杂度一般为 $O(n^2)$\n实现 struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } 例题 洛谷P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; edge[x].push_back(Node(y,z)); edge[y].push_back(Node(x,z)); } Prim(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","summary":"最小生成树基础算法学习 定义 我们定义无向连通图的 最小生成树（Minimum Spanning Tree，MST）为边权和最小的生成树。 注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。 Kruskal 算法 简介 基本思想是从小到大加入边，是个贪心算法。 将所有边的边权排序，从小到大加入生成树中，如果某次加入会","title":"最小生成树"},{"content":"最短路基础算法学习 特点汇总 最短路算法 Floyd Bellman–Ford Dijkstra Johnson 最短路类型 每对结点之间的最短路 单源最短路 单源最短路 每对结点之间的最短路 作用于 任意图 任意图 非负权图 任意图 能否检测负环？ 能 能 不能 能 时间复杂度 $O(N^3)$ $O(NM)$ $O(M \\log M)$ $O(NM \\log M)$ Floyd 算法 简介 用来求任意两个结点之间的最短路\n复杂度较高 $O(n^3)$ 容易实现\n使用与任何图，不管有向无向，边权正负，但是最短路必须存在，不能存在负环(即边权之和为负数的环，可以无限次通过减少所求答案)\n实现 定义一个数组 $f[k][x][y]$，表示只允许经过点 1 到 $k$ (包含点 1 到点 $k$ 的子图，$x$ $y$ 不一定在子图中)，点 $x$ 到点 $y$ 的最短路长度\n$f[n][x][y]$ 即为 $x$ 到 $y$ 的最短路长度\n$f[0][x][y]$: $x$ 和 $y$ 之间有联通路时为二者的边权，若无则为 $+\\infty $ 如果 $x == y$ 则为 0\n$f[k][x][y] = \\min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])$（$f[k-1][x][y]$，为不经过 $k$ 点的最短路径，而 $f[k-1][x][k]+f[k-1][k][y]$，为经过了 $k$ 点的最短路）。\n可以发现第一维是无影响的，因此空间复杂度可以优化到 $O(n^2)$\nvoid floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } 例题 洛谷 B3647\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int f[110][110]; int inf = 1e9; void floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,w; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; if(!f[x][y])f[x][y]=f[y][x]=w; else f[x][y]=f[y][x]=min(f[x][y],w); } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ if(f[i][j])continue; if(i==j)f[i][j]=0; else f[i][j]=inf; } } floyd(); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++)cout\u0026lt;\u0026lt;f[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } Bellman-Ford 算法 简介 基于松驰操作的最短路算法，可以求出有负权的图的最短路，并可以对最短路不存在的情况进行判断\nSPFA 是 Bellman-Ford 的一种实现\n松驰操作指的是 $dis[v] = \\min(dis[v], dis[u] + w[u][v])$\nBellman-Ford 算法做的就是不断尝试对图上每一条边进行松驰，每一轮循环都尝试对图上所有的边进行一次松驰操作，当一次循环中没有成功的松驰操作时，算法停止\n整个算法最多进行 $n - 1$ 轮松驰操作，所以时间复杂度为 $O(nm)$\n如果从 $s$ 点出发，抵达一个负环，松驰会无休止的进行下去，如果 $n - 1$ 轮后还有能松驰的边，说明从 $s$ 点出发，能够抵达一个负环\n如果以 $s$ 点跑，没有找到负环，只能说明从 $s$ 点无法到达负环，如果要判断图上是否有负环，需要建立一个超级源点 $o$ 对图上每个点连一条权值为 0 的边，再以 $o$ 为起点跑一遍 Bellman-Ford\n实现 struct Node{ int u,v,w; }; vector\u0026lt;Node\u0026gt;edge; int dis[10100],u,v,w; int n,m; const int INF = 1e9; bool bellmanford(int n,int s){ memset(dis,INF,sizeof(dis)); dis[s]=0; bool flag=false; for(int i=1;i\u0026lt;=n;i++){ flag=false; for(int j=0;j\u0026lt;edge.size();j++){ u=edge[j].u,v=edge[j].v,w=edge[j].w; if(dis[u]==INF)continue; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; flag=true; } } if(!flag)break; } return flag; } 队列优化 SPFA\n很显然，只有上次被松驰的点所连接的边，才可能进行下一次的松驰操作\n可以用队列来维护可能引起松驰操作的点\nSPFA 也可以用于判断 $s$ 是否能抵达负环，只需记录最短路经过了多少条边即可，若经过了至少 $n$ 条边，说明 $s$ 可以抵达一个负环\nstruct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int dis[N],cnt[N],vis[N]; queue\u0026lt;int\u0026gt;q; bool spfa(int n,int s){ memset(dis,63,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto x:edge[u]){ int v=x.v,w=x.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n)return false; if(!vis[v])q.push(v),vis[v]=1; } } } return true; } 例题 洛谷 P3385\nBellman-Ford\nSPFA\nDijkstra 算法 简介 求解 非负权图 上单源最短路径\n将点分为两个集合，一个为已确定最短路径的点集 $s$，另一个为未确定最短路长度的点集 $t$，初始状态所有点都在 $t$ 中\n初始化 $dis[s] = 0$, 其他点的 $dis$ 均为 $+\\infty $\n然后重复下列操作：\n(1) 从 $t$ 中取一个最短路长度最小的点，移到 $s$ 中\n(2) 对刚加入 $s$ 中的点进行所有出边的松驰操作\n直到 $t$ 为空，算法结束\n暴力实现 时间复杂度为 $O(n^2)$\n堆优化 时间复杂度 $O(m \\log n)$\n实现 暴力\nstruct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; //开一个结构体用于储存边的信息，y 代表这条边通向哪，v 代表这条边的边权 int n,m,u,v,w,s,t,dist[N]; bool vis[N]; vector\u0026lt;Node\u0026gt;edge[N];//edge 数组的下标就是边的起始点，Node 中的 y 代表这条边通向哪个点 void dijkstra(int s,int t){//s 指代起点，t 指代终点 memset(vis,0,sizeof(vis)); memset(dist,127,sizeof(dist)); //初始将所有点的最短路都设置为无穷大 dist[s]=0;//起点到自己的距离为 0 for(;;){ int x=-1;//x 是这一轮循环中找到的最短路径 for(int i=1;i\u0026lt;=n;i++){ if(!vis[i]\u0026amp;\u0026amp;dist[i]\u0026lt;(1\u0026lt;\u0026lt;30))//如果当前这个点没被更新过，并且到达它的最短路不是初始化的无穷大，我们就考虑他是不是当前的最优选择 if(x==-1||dist[i]\u0026lt;dist[x])x=i;//如果 x 还未被更新，或者到这个点的最短路比之前选的更短，我们就更新 x } if(x==t||x==-1)break;//如果 x 为终点，或遍历所有点后 x 还没更新，就终止算法 vis[x]=1;//标记当前这个 x 避免之后重复使用 for(auto i:edge[x]){//遍历以 x 这个点为起点的所有边 dist[i.y]=min(dist[i.y],dist[x]+i.v);//更新能到达的点的最短路 } } } 堆优化\nstruct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } 例题 洛谷P1339\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; edge[u].push_back(Node(v, c)); edge[v].push_back(Node(u, c)); } dijkstra(s, t); return 0; } Johnson 全源最短路径算法 实现 为了实现有负权图上的 Dijkstra，我们可以新建一个虚拟节点 $o$，从这个点向其他所有点连一条边权为 0 的边\n接下来用 Bellman-Ford 求出节点 $o$ 到其他所有点的最短路，记为 $h[i]$\n假如存在一条从 $u$ 到 $v$，边权为 $w$ 的边，则将其边权重设为 $w + h[u] - h[v]$\n接下来以每个点为起点，跑 $n$ 轮 Dijkstra 即可求出任意两点间的最短路了\n该算法时间复杂度是 $O(nm \\log m)$\n","permalink":"https://blog.050623.xyz/posts/study/%E6%9C%80%E7%9F%AD%E8%B7%AF/","summary":"最短路基础算法学习 特点汇总 最短路算法 Floyd Bellman–Ford Dijkstra Johnson 最短路类型 每对结点之间的最短路 单源最短路 单源最短路 每对结点之间的最短路 作用于 任意图 任意图 非负权图 任意图 能否检测负环？ 能 能 不能 能 时间复杂度 $O(N^3)$ $O(NM)$ $O(M \\log M)$ $O(NM \\log M)$ Floyd 算法 简介 用来求任意两个结点之间的最短路 复杂度较高 $O(n^3)$ 容易实现 使","title":"最短路"},{"content":"2024 河南萌新联赛 1 A 造数 给定整数 $n$，操作 1：$+1$，操作 2：$+2$，操作 3：$\\times 2$，多少次将 $0$ 转化到 $n$\n逆向思维，把 $n$ 化为 $0$ 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 $n$ 的数组 $a$，两种操作选一个进行一次或不操作。\n显然将数组最大值 $\\times n$ 后答案最大\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end()); int sum=0; for(int i=0;i\u0026lt;n;i++){ sum+=a[i]; } sum=max(sum+n,sum+(n-1)*a[n-1]); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } K 图上计数 构造的两块联通块即为最接近 $n/2$ 的两块\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int n,m; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } if(n\u0026lt;=1){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return 0; } cout\u0026lt;\u0026lt;(long long)n/2*(n-n/2)\u0026lt;\u0026lt;endl; } I 除法移位 $a$ 中最大值位于第一位时即是答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t; vector\u0026lt;int\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int mx=0,ans=0; for(int i=1;i\u0026lt;=min(t,n);i++){ if(a[n-i+1]\u0026gt;mx){ mx=a[n-i+1]; ans=i%n; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } F 两难抉择新编 与 H 类似，但是操作范围随 $i$ 改变而改变 $O(n^{3/2})$ 暴力过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); int sum = 0, ans = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) sum ^= a[i]; ans = sum; for (int i = 1; i \u0026lt;= n; i++) { for (int x = 1; x \u0026lt;= n / i; x++) { int t1 = sum ^ a[i] ^ (a[i] + x); int t2 = sum ^ a[i] ^ (a[i] * x); ans = max(ans, max(t1, t2)); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } G 旅途的终点 反悔贪心，前 $k$ 个直接存入 set，后续的小于 set 内第一个元素就替换，否则就正常进行\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll __int128 int main(){ long long n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;long long\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; multiset\u0026lt;ll\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ s.insert(a[i]); if(s.size()\u0026gt;k){ m-=*s.begin(); if(m\u0026lt;=0){ cout\u0026lt;\u0026lt;i-1\u0026lt;\u0026lt;endl; return 0; } s.erase(s.begin()); } } cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; return 0; } B 爱探险的朵拉 图中可能有环，那么就是要找包含环的最长链，或是无环的最长链\n记录每个点的入度，如果某个点的入度为 $0$，他们不会构成环，即可作为链起点，再依次对入度为 $0$ 的点操作，找出他们能构成最长的链有多长。\n之后再以每个点为起点找答案，如果前面的过程标记过则跳过，没标记过说明这是环上点，用 dfs 找这个环加上前链有多长，并更新答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+10; int a[N],dis[N],cnt[N]; bool vis[N]; deque\u0026lt;int\u0026gt;q; int dfs(int x){ int sum=0,mx=0; for(int i=x;;i=a[i]){ if(vis[i])break; vis[i]=1; ++sum; mx=max(mx,dis[i]); } return mx+sum; } int main(){ int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; cnt[a[i]]++; } for(int i=1;i\u0026lt;=n;i++) if(!cnt[i])q.push_back(i); while(!q.empty()){ int x=q.front(); q.pop_front(); vis[x]=1; dis[a[x]]=max(dis[a[x]],dis[x]+1); --cnt[a[x]]; if(!cnt[a[x]])q.push_back(a[x]); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; int tmp=dfs(i); ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } C 有大家喜欢的零食吗 二分图匹配板子，之后学了补\nD 小蓝的二进制询问 显然是前缀和，那么重点就是如何计算前 $x$ 个数的 $1$ 的个数\n从最低位看起，只有 $0$，$1$，二者循环，再往上 $1$ 位，仍然为 $0$，$1$ 循环，显然每一位上的循环都是一样的，我们对每一位能出现的 $1$ 进行计算，当前位数为 $k$ 时，这一位上就会有 $2^k$ 个 $1$ 和 $2^k$ 个 $0$。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 998244353; ll sum(ll x,int y){ if(x==0) return 0; ll s=1LL\u0026lt;\u0026lt;y; ll cnt=x/s; ll ans=cnt*s/2; ll d=cnt*s+(1LL\u0026lt;\u0026lt;(y-1)); ll dd=x-d+1; if(dd\u0026gt;0) ans+=dd; return ans; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ ll ans=0,l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; for(int i=61;i\u0026gt;0;i--){ ll p=(sum(r,i)%MOD-sum(l-1,i)%MOD+MOD)%MOD; ans=(ans+p)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } J 最大矩阵匹配 将矩阵上下翻转后，变为固定左上一个点，向其他三个方向拓展的问题，用二维前缀和辅助判断三个点是否都为 $1$，来实现 DP 状态转移\n","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B1/","summary":"2024 河南萌新联赛 1 A 造数 给定整数 $n$，操作 1：$+1$，操作 2：$+2$，操作 3：$\\times 2$，多少次将 $0$ 转化到 $n$ 逆向思维，把 $n$ 化为 $0$ 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 $n$ 的数组 $a$，两种操作选一个进行一次或不操作。 显然将数组最大值 $\\times n$ 后答案最大 #include \u0026lt;bits/stdc++.h\u0026gt;","title":"2024萌新联赛1"},{"content":"Codeforces Round 962 还得练\nA Legs 先除 $4$ 再除 $2$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 $a$ 到 $z$ 这 $26$ 个字符分别开前缀和，统计 $l$ 到 $r$ 之间他们不同的数量，更改差异数量除 $2$ (向上取整)，即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; int n, q; string a, b; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = \u0026#34; \u0026#34; + a; b = \u0026#34; \u0026#34; + b; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; va(26, vector\u0026lt;int\u0026gt;(n + 1, 0)), vb(26, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { va[x - \u0026#39;a\u0026#39;][i] = va[x - \u0026#39;a\u0026#39;][i - 1]; vb[x - \u0026#39;a\u0026#39;][i] = vb[x - \u0026#39;a\u0026#39;][i - 1]; } va[a[i] - \u0026#39;a\u0026#39;][i]++; vb[b[i] - \u0026#39;a\u0026#39;][i]++; } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; long long ans = 0; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { ans += abs((va[x - \u0026#39;a\u0026#39;][r] - va[x - \u0026#39;a\u0026#39;][l - 1]) - (vb[x - \u0026#39;a\u0026#39;][r] - vb[x - \u0026#39;a\u0026#39;][l - 1])); } if(ans\u0026amp;1)ans++; ans/=2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D Fun 给定两个整数 $n$ 和 $x$ ，求 $ab + ac + bc \\leq n$ 和 $a + b + c \\leq x$ 的个正整数的三元组 $(a, b, c)$ 的个数。 注意顺序问题(例如 $(1, 1, 2)$ 和 $(1, 2, 1)$ 被视为不同)， $a$ ， $b$ ， $c$ 必须严格大于 $0$ 。\n赛时只顾着研究这两个式子能否融合化简为一个式子，还是见题少了\n看第一个式子可知，$a * b \\leq n$, 所以 $b$ 有 $n\\log n$ 个选择，可以循环 $ab$ 求解\n再通过两个式子推得 $c \\leq \\frac{n - ab}{a + b}$ 和 $c \\leq x - a - b$ ,将范围小的加入答案即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ ll n,x,ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ ll mn=min((n-i*j)/(i+j),(x-i-j)); mn=max(mn,0); ans+=mn; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E Decode 赛时题都没弄太明白 每次找到符合区间会使答案加 $l * (n - r + 1)$\n用前缀和记录当前位置 $1$ $0$ 出现次数，$1$ 指代此处为 $1$，$-1$ 指代此处为 $0$。然后逐位记录当前前缀和的大小，如果之前存过，那么就更新答案。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 1e9 + 7; void solve(){ string s; cin\u0026gt;\u0026gt;s; int n=s.size(); s=\u0026#34; \u0026#34;+s; vector\u0026lt;ll\u0026gt;pre(n+1,0); for(int i=1;i\u0026lt;=n;i++){ pre[i]=(s[i]==\u0026#39;1\u0026#39;?1:-1)+pre[i-1]; } map\u0026lt;int,ll\u0026gt;cnt; cnt[0]=1; ll ans=0; for(int i=1;i\u0026lt;=n;i++){ ans=(ans+cnt[pre[i]]*(n-i+1)*1LL%MOD)%MOD; cnt[pre[i]]=(cnt[pre[i]]+i+1)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/cf962/","summary":"Codeforces Round 962 还得练 A Legs 先除 $4$ 再除 $2$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 $a$ 到 $z$ 这 $26$ 个字符分别开前缀和，统计 $l$ 到 $r$ 之间他们不同的数量，更改差异数量除 $2$ (向上取整)，即可 #include \u0026lt;bits/stdc++.h\u0026gt;","title":"CF962"},{"content":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确\n类似有向无环图，由一个状态转移到下一个状态\n对先手来说，存在两种状态，即必胜态和必败态\n必胜态 当前状态的后续为必败态，当前状态即为必胜态\n必败态 不存在后续，或是所有后续都必胜\nDP 解决博弈 利用状态转移的关系，来解决简单的博弈问题\n移棋子问题 $n \\times m$ 的棋盘，$(1,1)$ 在左上角，$(n,m)$ 在右下角，每格标明黑白两色\n上面有一个棋子，Alice 和 Bob 轮流移动这个棋子，Alice 先手移动，每次可以向上或向左移动一格，一旦移动到第一行或第一列游戏结束，执行最后一步移动的人，如果将棋子移动到黑格，就获胜，反之，则失败。\n现在给这个棋子的起始位置，问最后获胜的玩家是谁，对于所有的 $(i,j)$ 满足 $2 \\leq i,j \\leq n$ 输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN][MAXN],n,m; string a,b; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=0;i\u0026lt;=m-2;i++){ dp[1][i+2]=(a[i]==\u0026#39;W\u0026#39;); } for(int i=0;i\u0026lt;=n-2;i++){ dp[i+2][1]=(b[i]==\u0026#39;W\u0026#39;); } for(int i=2;i\u0026lt;=n;i++){ for(int j=2;j\u0026lt;=m;j++){ dp[i][j]=!(dp[i-1][j]\u0026amp;\u0026amp;dp[i][j-1]); if(dp[i][j])cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;B\u0026#34;; } puts(\u0026#34;\u0026#34;); } } 取石子游戏 有一堆石子，大小为 $x$，Alice 和 Bob 轮流操作，Alice 先手，Alice 每次可以取 $a[i]$ 个石子，Bob 可以取 $b[i]$ 个，谁不能操作就输。\n问谁能获胜，对 $x = 1 \\sim m$ 都输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n1, n2, m, a[N], b[N], A[N], B[N]; int main(){ cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n1; i++){ cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n2; i++){ cin \u0026gt;\u0026gt; b[i]; } for (int i = 1; i \u0026lt;= m; i++){ for (int j = 1; j \u0026lt;= n1; j++){ if(i \u0026gt;= a[j] \u0026amp;\u0026amp; B[i-a[j]] == 0){ A[i] = 1; break; } } for (int j = 1; j \u0026lt;= n2; j++){ if(i \u0026gt;= b[j] \u0026amp;\u0026amp; A[i-b[j]] == 0){ B[i] = 1; break; } } puts(A[i] ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); } return 0; } 带和局的情况 存在先手必败，胜\n存在和，和\n败\n经典模型 巴什博弈 有 $n$ 个石子，每次取 $1 \\sim m$ 个，Alice 先取，谁取最后一颗谁胜\n$n % (m + 1) = 0$，先手必败\n$n % (m + 1) \\neq 0$，先手必胜\n威佐夫博弈 有两堆石子，分别有 $a, b$ 颗，每次可以选一堆取 $x$ 个，也可以选两堆都取 $x$ 个\n所以 $(a, b)$ 有三种转移，$(a-x, b)$, $(a, b-x)$, $(a-x, b-x)$;\n打表找规律\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 首先发现 $(a, b)$ 和 $(b, a)$，状态相同，即同为必败态或必胜态\n再对 $a \u0026lt; b$ 的情况分析，发现 $a$ 是从 $1$ 到 $n$ 的，$b - a$ 逐渐递增，依次为 $1, 2, 3, 4, 5, \u0026hellip;$\nNim 模型 有 $n$ 堆石子，每堆有 $a[i]$ 个石子，Alice 和 Bob 轮流取，Alice 先取，每次可以从选一堆任取 $x$ 个石子，可以拿光，但不能不拿，谁最后把所有的拿光谁获胜\n先打表\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; // for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) // if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 发现 $i == j$，经推广更多维，可以总结出必败态：$A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\n要证明此结论，可从三个定理入手\n1：没有后续状态的状态是必败态\n2：对于 $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n \\neq 0$ 的局面一定存在某种移动使 $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\n3：对于 $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$，不存在一种移动使 $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\n例题练习 石子游戏 2 有 $n$ 堆石子，每堆有 $a[i]$ 个石子，Alice 和 Bob 轮流操作，每次可以把一堆个数为奇数的石子分为两堆，两堆都不能为空，或把两堆为偶数的石子和为一堆\n可以注意到两种操作都是对堆数改变，那么堆数的奇偶性就是突破点，同时根据操作的实质，可以发现只有 $1$ 个石子的堆是无法继续操作的，最后石堆将变成全是 $1$ 或者 $1$ 个偶数剩下的全是 $1$\n所以结论就是：如果石堆全是 $1$，则先手必败，如果不是全为 $1$ 那么就检测结束时堆数的奇偶性是否改变\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, odd, one; int x; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1;i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; x; if (x % 2 == 1) odd++; if (x == 1) one++; } if (one != n) odd++; if ((odd + n) % 2 != 0)cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#34;; return 0; } 石子游戏 3 有 $n$ 堆石子，每堆有 $a[i]$ 个石子，Alice 和 Bob 轮流操作，选择 $n/2$ 堆非空石子，每堆移除掉正数个(可以不同)的石子，从 Alice 开始。\n倒推：\n必败：超过 $n/2$ 个堆已经为 $0$ 必胜：有 $1 \\sim n/2$ 个堆为 $0$\n必败：有 $\u0026gt; n/2$ 个堆石子数量为 $1$\n必胜：有 $1 \\sim n/2$ 个堆的数量为 $1$\n必败：有 $\u0026gt; n/2$ 个堆的数量为 $2$\n\u0026hellip;\u0026hellip;\n有大于 $n/2$ 个堆的数量 = min，必败\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, mx = 1e9, cnt; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if (x \u0026lt; mx) mx = x, cnt = 0; if (x == mx) cnt++; } if (cnt \u0026gt; n/2) cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; return 0; } SG 板子 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[1010]; int main() { int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; i++) { set\u0026lt;int\u0026gt; s; for (int j = 1; j \u0026lt;= i; j *= p) { s.insert(sg[i - j]); } while (s.count(sg[i])) sg[i]++; printf(\u0026#34;%d %d\\n\u0026#34;, i, sg[i]); } return 0; } ","permalink":"https://blog.050623.xyz/posts/study/%E5%8D%9A%E5%BC%88%E8%AE%BA/","summary":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确 类似有向无环图，由一个状态转移到下一个状态 对先手来说，存在两种状态，即必胜态和必败态 必胜态 当前状态的后续为必败态，当前状态即为必胜态 必败态 不存在后续，或是所有后续都必胜 DP 解决博弈 利用状态转移的关系，来解决简单的博弈问题 移棋子问题 $n","title":"博弈论"},{"content":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把\nI 重生之zbk要拿回属于他的一切 签到，暴力找 $chuan$ 的数量即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;\u0026#34;DHY\\n\u0026#34;; } } A 国际旅行 I 认真读题可得知，恒为联通图，排序所有国家即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n,m,q,k; vector\u0026lt;int\u0026gt;a(N); map\u0026lt;int,int\u0026gt;vis; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } sort(a.begin()+1,a.begin()+1+n); while(q--){ cin\u0026gt;\u0026gt;k; cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; } } J 这是签到 矩阵计算板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int a[6][6]; int cal(int n, int a[6][6]) { if (n == 1) return a[0][0]; int res = 0; int sub[6][6]; for (int x = 0; x \u0026lt; n; x++) { int subi = 0; for (int i = 1; i \u0026lt; n; i++) { int subj = 0; for (int j = 0; j \u0026lt; n; j++) { if (j == x) continue; sub[subi][subj] = a[i][j]; subj++; } subi++; } res += (x % 2 == 0 ? 1 : -1) * a[0][x] * cal(n - 1, sub); } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; a[i][j]; int ans = INT_MAX; int u=min(n,m); for(int i=1;i\u0026lt;=u;i++){ ans=min(ans,cal(i,a)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H 狼狼的备忘录 STL 大法好\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, cnt, m; string s; map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; note; map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; vis; set\u0026lt;string\u0026gt; peo; void erase(string \u0026amp;a, string \u0026amp;b) { if (a == b) { b = \u0026#34;\u0026#34;; return; } if (a.size() \u0026gt; b.size() \u0026amp;\u0026amp; a.substr(a.size() - b.size()) == b) { b = \u0026#34;\u0026#34;; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; cnt; peo.insert(s); for (int j = 1; j \u0026lt;= cnt; j++) { string t; cin \u0026gt;\u0026gt; t; if (!vis[s][t]) note[s].push_back(t); vis[s][t]++; } } for (auto x : peo) { int m = note[x].size(); for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { erase(note[x][i], note[x][j]); erase(note[x][j], note[x][i]); } } sort(note[x].begin(), note[x].end()); note[x].erase(remove(note[x].begin(), note[x].end(), \u0026#34;\u0026#34;), note[x].end()); } cout \u0026lt;\u0026lt; peo.size() \u0026lt;\u0026lt; endl; for (auto x : peo) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; note[x].size(); for (auto s : note[x]) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s; } cout \u0026lt;\u0026lt; endl; } return 0; } D A*BBBB 高精度 根据题意可知 是同一个结果往前移 $b.size()$ 次相加 赛时笨比没调出来 python 引入 demical 库过的\n赛时代码\nfrom decimal import * import sys t=int(input()) for i in range(t): setcontext(Context(prec=2000000, Emax=2000000, Emin=0)) print((Decimal(sys.stdin.readline())*Decimal(sys.stdin.readline()))) 正解\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e7+10; typedef long long ll; int a[N],sum[N],ans[N\u0026lt;\u0026lt;1]; string A,B; void solve(){ cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B; int la=A.length(),lb=B.length(),b=B[0]-\u0026#39;0\u0026#39;; ll last=0; a[la+1]=0; for(int i=1;i\u0026lt;=la;i++){ a[i]=(A[la-i]-\u0026#39;0\u0026#39;)*b+last; last=a[i]/10; a[i]*=10; sum[i]=sum[i-1]+a[i]; } sum[la+1]=sum[la]+last; last=0; for(int i=1;i\u0026lt;=la+lb;i++){ int l=min(i,la+1),r=max(0,i-lb); ans[i]=sum[l]-sum[r]+last; last=ans[i]/10; ans[i]%=10; } bool flag=0; for(int i=la+lb;i\u0026gt;=1;--i) { if(!ans[i]) { if(flag) printf(\u0026#34;%d\u0026#34;,ans[i]); } else { flag=1; printf(\u0026#34;%d\u0026#34;,ans[i]); } } if(!flag) printf(\u0026#34;0\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E \u0026ldquo;好\u0026quot;字符 观察得到 $a$，$b$ 同一字符所处位置相邻差值构成的一个循环同构如果相同，就符合题意\n那么就对 26 个字符各跑一次 找到位置 存入字符串 找到该串的最小表示 比较即可\n需要注意将原 $a$，$b$ 再复制本身一遍 因为这样才能保证找的最小表示没有缺少\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp(int nxt[], string a) { int n = a.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; a[i] != a[j]) j = nxt[j - 1]; if (a[i] == a[j]) j++; nxt[i] = j; } return n - nxt[n - 1]; } string getmin(string s, int n) { s = s + s; int i = 0, j = 1; while (j \u0026lt; n) { int k = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) ++k; if (s[i + k] \u0026gt; s[j + k]) i += k + 1; else j += k + 1; if (i == j) j++; if (i \u0026gt; j) swap(i, j); } string t = s.substr(i, n); return t; } int main() { int n; string a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = a + a; b = b + b; map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; va, vb; map\u0026lt;char, string\u0026gt; sa, sb; for (int i = 0; i \u0026lt; n * 2; i++) { va[a[i]].push_back(i); vb[b[i]].push_back(i); } int cnt = 0, nxt[2000010]; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { if (va[x].size() != vb[x].size() || va[x].size() == 0 || vb[x].size() == 0) continue; for (int i = 1; i \u0026lt; va[x].size(); i++) { sa[x] += to_string(va[x][i] - va[x][i - 1]); } for (int i = 1; i \u0026lt; vb[x].size(); i++) { sb[x] += to_string(vb[x][i] - vb[x][i - 1]); } if (getmin(sa[x], kmp(nxt, sa[x])) == getmin(sb[x], kmp(nxt, sb[x]))) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C 小 $w$ 和大 $W$ 的对决 sg 暴力打表 发现 8 个为一个循环 最后两个交换位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int calc(int x){ if(x%8==0)return x-1; if(x%8==7)return x+1; else return x; } int ans; int main(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=calc(x); } if(ans==0)cout\u0026lt;\u0026lt;\u0026#34;W win\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;w win\\n\u0026#34;; } G $lxy$ 的通风报信 因为数据不大，直接 bfs 跑每个点对其他点的距离，再求最小生成树即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; struct Node{ int x,y,id; }b[N]; int n,m,ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},tot,dis[N][N],a[N][N]; bool vis[N]; deque\u0026lt;Node\u0026gt;q; void bfs(int id){ q.clear(); q.push_back(Node{b[id].x,b[id].y,0}); dis[b[id].x][b[id].y]=0; while(!q.empty()){ Node now=q.front(); q.pop_front(); for(int i=0;i\u0026lt;4;i++){ int x=now.x+dx[i],y=now.y+dy[i]; if(x\u0026lt;1||y\u0026lt;1||x\u0026gt;n||y\u0026gt;m||a[x][y]==-1)continue; if(dis[x][y]\u0026gt;now.id+1){ dis[x][y]=now.id+1; q.push_back(Node{x,y,dis[x][y]}); } } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ dis[i][j]=1e9; char x; cin\u0026gt;\u0026gt;x; if(x==\u0026#39;.\u0026#39;)a[i][j]=0; else if(x==\u0026#39;#\u0026#39;)a[i][j]=-1; else { a[i][j]=++tot; b[tot]=Node{i,j,tot}; } } } dis[b[1].x][b[1].y]=0; for(int i=1;i\u0026lt;=tot;i++){ int mi=1e9,id=0; for(int j=1;j\u0026lt;=tot;++j){ if(vis[j])continue; if(mi\u0026gt;dis[b[j].x][b[j].y])mi=dis[b[j].x][b[j].y],id=j; } if(!id){ puts(\u0026#34;No\u0026#34;); return; } vis[id]=1; ans+=mi; if(i!=tot)bfs(id); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B2/","summary":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把 I 重生之zbk要拿回属于他的一切 签到，暴力找 $chuan$ 的数量即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using","title":"2024萌新联赛2"},{"content":"最小表示法 理论学习 给定一个字符串 $s$，首尾相接（循环同构），找到其字典序最小的情况 $O(n)$\n用两个指针 $i,j$，分别指向目前两个可能是答案的起始位置\n初始 $i = 1, j = 2$，随着算法进行增大\n假设现在 $i \u0026lt; j$，且从 $i$ 开始的 $k$ 位字符和从 $j$ 开始的 $k$ 位字符是一样的，此时这两段子串相同\n如果 $s[i+k] \\neq s[j+k]$\n谁大谁往后移动 $k+1$ 个位置\n如果 $s[i+k] == s[j+k]$\n随便移动一个\n最后小于 $n$ 的那个指针就是所求答案\nvoid getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } 例题 循环同构判断 给定两个字符串 $a, b$，判断两个字符串是否循环同构\n只需判断两个字符串最小表示是否一样即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a,b; int getmin(string s){ int n=s.size(); int i=0,j=1; s=s+s; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)++j; if(i\u0026gt;j)swap(i,j); } return i; } int main(){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=getmin(a),j=getmin(b),k=0;k\u0026lt;n;k++){ if(a[(i+k)%n]!=b[(j+k)%n]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return 0; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } 最小循环覆盖 给出字符串 $a$，求出这个字符串的字典序最小的最小循环覆盖\n先用 $kmp$ 求出最小循环片段长度，再求这个长度的子串的最小表示\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a; int nxt[100005]; int kmp(){ int n=a.size(); nxt[0]=0; int j=0; for(int i=1;i\u0026lt;n;i++){ while(j\u0026amp;\u0026amp;a[i]!=a[j]) j=nxt[j-1]; if(a[i]==a[j]) j++; nxt[i]=j; } return n-nxt[n-1]; } void getmin(string s,int n){ s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int l=i;l\u0026lt;i+n;l++)cout\u0026lt;\u0026lt;s[l]; } int main(){ cin\u0026gt;\u0026gt;a; getmin(a,kmp()); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"最小表示法 理论学习 给定一个字符串 $s$，首尾相接（循环同构），找到其字典序最小的情况 $O(n)$ 用两个指针 $i,j$，分别指向目前两个可能是答案的起始位置 初始 $i = 1, j = 2$，随着算法进行增大 假设现在 $i \u0026lt; j$，且从 $i$ 开始的 $k$ 位字符和从 $j$ 开始的 $k$ 位字符是一样的，此时这两段子串相同 如果 $s[i+k] \\neq s[j+k]$ 谁大","title":"最小表示法"},{"content":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出 $N$。\n签到，直接暴力\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vis[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分 输入: 1 s3://hdu-oj-bucket/problem=1/type=data/ 输出： s3 hdu-oj-bucket problem=1 type=data\n签到，按题意拆分字符串即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string s; cin\u0026gt;\u0026gt;s; int pos = s.find(\u0026#34;://\u0026#34;); cout\u0026lt;\u0026lt;s.substr(0,pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; pos+=3; int now = s.find(\u0026#34;/\u0026#34;,pos); cout\u0026lt;\u0026lt;s.substr(pos,now-pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; while(1){ pos=now+1; if(pos\u0026gt;=s.size())break; now = s.find(\u0026#34;/\u0026#34;,pos); string t = s.substr(pos,now-pos); int flag = t.find(\u0026#34;=\u0026#34;); if(flag!=-1)cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1001 鸡爪 给 $n$ 条边，任意顶点，构造数量最多的鸡爪，同时保证输出每条边的两个顶点时，保证行优先遍历，字典序最小。\n鸡爪的定义：1 个顶点，和它所连的 3 条边，不包括其他顶点，不可重复利用。\n构造，易想出 $n$ 条边，最多构造出 $n/3$ 个鸡爪，多出的 1 或 2 个边，补到顶点1上即可。\n因为字典序最小，所以顶点 1 上连的边肯定最多，我们就让 1 连到所有的顶点上，这样其他所有构造鸡爪的顶点 $n$ 都能用上 $1-n$ 这条边。因此 1 自己用的边肯定是入度最小的几个顶点，即编号最大的顶点，类推到之后的顶点，都是先采用与其之前的顶点的边，再从最后面选。到顶点 4 开始，不再需要往后采用，因为前面有 3 个顶点提供边，不再需要额外的顶点来提供边。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n\u0026gt;=3){ int now=0,cnt=n/3+3; for(int i=1;i\u0026lt;=min(n/3,3);i++){ for(int j=i+1;j\u0026lt;=cnt-i+1;j++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(i==1\u0026amp;\u0026amp;j==cnt-i+1){ int now=j; while(n%3!=0){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;++now\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; n--; } } } } } else{ for(int i=2;i\u0026lt;=n+1;i++)cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1006 传奇勇士小凯 有一个 $n$ 个结点的有根树，你需要从 1 号结点走到任意一个叶子节点，每天你有 $p[i]/15$ 的可能性可以向任意一个儿子节点走一步（ $i$ 为你当前所在的节点编号），询问你期望最多可以在这颗树上走多久\n期望计算，在某一节点停留的步数应该为 $15/p[i]$ 。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; ll ans=0, LCM=360360; vector\u0026lt;int\u0026gt; nxt[N]; vector\u0026lt;int\u0026gt; p(N); ll gcd(int x,int y){ if(!x||!y)return x+y; return gcd(y,x%y); } void dfs(int u,int fa, ll sum) { sum += (LCM / p[u]); if(sum\u0026gt;ans)ans=sum; for (auto x : nxt[u]) { if(x==fa)continue; dfs(x, u, sum); } } void solve() { int n; cin \u0026gt;\u0026gt; n; ans=0; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; nxt[u].push_back(v); nxt[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; dfs(1, 0, 0); ll d=gcd(15*ans,LCM); printf(\u0026#34;%lld/%lld\\n\u0026#34;,15*ans/d,LCM/d); for (int i = 1; i \u0026lt;= n; i++) nxt[i].clear(); } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1003 绝对不模拟的简单魔方 1)暴力，从初始状态开始模拟，每次对比当前状态和给出状态，若相同或不同点仅两个，即得到答案\n2)将魔方视为 2 阶的，预处理得到 24 种可能状态，与给出状态对比，至多有一个角不同，即为答案。\n之后补... 1011 在 A 里面找有 C 的 B AC自动机（还不会，之后补\u0026hellip;.\n","permalink":"https://blog.050623.xyz/posts/study/2024hdu2/","summary":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出 $N$。 签到，直接暴力 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vis[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分","title":"2024HDU2"},{"content":"Manacher 理念学习 解决最长回文子串问题\n给出一个任意字符串，求出这个字符串中最长的回文子串\n正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 $s$ 中不存在的字符，把 $s$ 中每一位隔开，再求新串中奇数长度的最长回文子串即可\n对于新串 $s$ ，我们的目的是求出从它的任意位置 $i$ 出发，往两边最远能拓展出的回文子串的长度，记做 $p[i]$ (包括 $i$ 本身，所以最小为 1)\n维护 $p[i]$ 的值：\n维护一个到目前位置的 $R$ 最大的区间 $[L, R]$，其中 $L = M - p[M] + 1$ ($M \u0026lt; i$) $R = M + p[M] - 1$\n$[L, R]$ 是一个回文串 如果 $i \\leq R$:\n找到 $i$ 对于 $M$ 的对称点 $k$，此时 $i - M = M - k, k = 2 * M - i$; 此时有两种情况：\n(1) 如果 $p[k]$ 对应的回文区间 $[k - p[k] + 1, k + p[k] - 1]$，不含左端点 $L$，说明这个回文区间在 $[L, R]$ 之中，此时我们可以得到 $p[i] = p[k]$\n(2) 如果包含了左端点 $L$，此时 $[L, 2k-L]$ 这一端为回文串。由于 $[L, R]$ 是回文串，可得出 $[2i-R, R]$ 也是回文串。往两端暴力拓展即可。 如果 $i \u0026gt; R$：\n暴力两端拓展即可 都要记得更新 $M, L, R$ 的值。\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } 洛谷例题 P3805\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; int n,p[2*N]; string s,t; void manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s; manacher(); return 0; } 坑点：字符串 $t$ 要 resize，不然 re\n","permalink":"https://blog.050623.xyz/posts/study/manacher/","summary":"Manacher 理念学习 解决最长回文子串问题 给出一个任意字符串，求出这个字符串中最长的回文子串 正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 $s$ 中不存在的字符，把 $s$ 中每一位隔开，再求新串中奇数长度的最长回文子串即可 对于新串 $s$ ，我们的目的是求出从它的任意位置 $i$ 出发，往两边最远能拓展出的回文","title":"Manacher"},{"content":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点\nkmp 相关 子串查询 输入两个字符串 $s$, $p$，查询 $p$ 是否在 $s$ 中出现，若出现输出出现位置，否则输出 $-1$\n简化版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){ while(j==m||(j\u0026amp;\u0026amp;s[i]!=p[j])) j=nxt[j-1]; if(s[i]==p[j]) j++; f[i]=j; } for(int i=0;i\u0026lt;n;i++){ if(f[i]==m)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 寻找最小循环子串 字符串 $s$ 是由某个子串重复连接而成的，寻找构成 $s$ 的最小子串的长度\n答案其实就是 $n - \\text{nxt}[n]$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],n,m; void kmp(){ m=p.size(); int j=0; nxt[0]=0; p=p; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } cout\u0026lt;\u0026lt;m-nxt[m-1]\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;p; kmp(); return 0; } Secret word 给出字符串 $s$，寻找最长字符串 $p$，$p$ 满足（是 $s$ 的子串，翻转后是 $s$ 的前缀）\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int nxt[200001],n; void kmp(){ n=s.size(); int j=0; nxt[0]=0; string t=s; reverse(t.begin(),t.end()); s=s+\u0026#34;#\u0026#34;+t; for(int i=1;i\u0026lt;n*2+1;i++){ while(j\u0026amp;\u0026amp;s[i]!=s[j]) j=nxt[j-1]; if(s[i]==s[j]) j++; nxt[i]=j; } int ans=-1; for(int i=n;i\u0026lt;2*n+1;i++){ ans=max(ans,nxt[i]); } for(int i=ans-1;i\u0026gt;=0;i--)cout\u0026lt;\u0026lt;s[i]; } int main(){ cin\u0026gt;\u0026gt;s; kmp(); return 0; } exkmp 洛谷 P5410\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; typedef long long ll; string s,p; ll z[N*2],n,m; void exkmp(string s,string p){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; ll L=0,R=-1; z[0]=m; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ ll k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } ll ans=0; for(int i=0;i\u0026lt;m;i++)ans^=(1LL*(i+1)*(z[i]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ans=0; for(int i=0;i\u0026lt;n;i++)ans^=(1LL*(i+1)*(z[i+m+1]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(s,p); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/0721/","summary":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点 kmp 相关 子串查询 输入两个字符串 $s$, $p$，查询 $p$ 是否在 $s$ 中出现，若出现输出出现位置，否则输出 $-1$ 简化版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0;","title":"0721"},{"content":"KMP学习记录 理念学习 字符串匹配问题 查找$s$中$p$是否出现\n暴力匹配 $O(nm)$\n哈希优化 $O(n+m)$\nKMP 线性复杂度解决 $O(n+m)$\nKMP 中对于 $s$ 中每个位置 $i$，我们要找到最大的 $j$ 满足$s[i - j +1]\u0026hellip;s[i]$ 和 $p[1]\u0026hellip;[j]$ 相同\n$f[i]$ 对应$j$的位置，$j$对应$p$中的位置\n如果 $j$ 不等于 $m$，并且 $s[i + 1] == p[j + 1]$，$j$ 右移一位\n否则，$j$ 向前回退，到满足 $s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j]$ 且 $k$ 最大的位\n如果 $s[i + 1]$ 仍不等于 $p[j + 1]$，不停向前回退，直到相等或 $j = 0$\n快速求出 $k$\n易得到求 $k$ 与 $s$ 无关\n最大的 $k$ 满足 $k \u0026lt; j$，使得 $p[1]..p[k]$ 和 $p[j - k + 1]\u0026hellip;p[j]$ 完全相同\n可以用 $next$ 维护每个 $j$ 对应的 $k$\nvoid kmp(){ n=s.size()+1,m=p.size()+1;//字符串下标从 1 开始 int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } 洛谷例题 P3375\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n, m; string s, p; int nxt[N], f[N]; void kmp() { n = s.size(); m = p.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j]) j = nxt[j - 1]; if (p[i] == p[j]) j++; nxt[i] = j; } j = 0; for (int i = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j]) j = nxt[j - 1]; if (s[i] == p[j]) j++; f[i] = j; if (j == m) { cout \u0026lt;\u0026lt; i - m + 2 \u0026lt;\u0026lt; endl; j = nxt[j - 1]; } } for (int i = 0; i \u0026lt; m; i++) { cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; kmp(); return 0; } EXKMP(Z-algorithm) 理论学习 线性时间复杂度求出字符串$s$和他的任意后缀 $s[i]\u0026hellip;s[n]$ 的最长公共前缀的长度 $O(n)$\n与 kmp 的区别：一个是到 $s[i]$ 结束，一个是从 $s[i]$ 开始\n定义 $z[1] = 0$，从 $2$ 到 $n$ 枚举 $i$，依次计算 $z[i]$ 的值\n计算 $z[i]$ 时，前面的 $z$ 都已经计算好了\n对于 $j$，有 $s[j]\u0026hellip;s[j + z[j] - 1]$ 和 $s[1]\u0026hellip;s[z[j]]$ 完全相等\n为了计算 $z[i]$，在枚举$i$的过程中，需要维护$R$的最大区间 $[L, R]$，其中 $L = j$，$R =j + z[i] - 1$\n初始时 $L = 1,R = 0$\n如果 $i \\leq R$:\n易知 $s[L]\u0026hellip;s[R] = s[1]\u0026hellip;s[R - L + 1]$\n令 $k = i - L + 1$，$i$ 与 $k$ 的位置对应，此时$s[i]..s[R] = s[k]..s[R - L + 1]$\n如果 $z[k] \u0026lt; R - i + 1$，说明从 $k$ 开始匹配不到那么远，也就是从 $i$ 开始匹配不到 $R$，此时 $z[i] = z[k]$\n反之，说明可以匹配到 $R$ 那么远，从 $R+1$ 开始往后暴力\n如果 $i \u0026gt; R$:\n暴力枚举匹配，记得更新 $L$ 和 $R$\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } 例题 给出字符串 $s$, $p$，求 $s$ 中 $p$ 出现的次数和位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int z[200001],n,m; void exkmp(){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; int L=0,R=-1; z[0]=0; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } int ans=0; for(int i=m+1;i\u0026lt;m+n+1;i++) if(z[i]==m)ans++; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=m+1;i\u0026lt;n+m+1;i++) if(z[i]==m)cout\u0026lt;\u0026lt;i-m\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(); return 0; } ","permalink":"https://blog.050623.xyz/posts/study/kmp/","summary":"KMP学习记录 理念学习 字符串匹配问题 查找$s$中$p$是否出现 暴力匹配 $O(nm)$ 哈希优化 $O(n+m)$ KMP 线性复杂度解决 $O(n+m)$ KMP 中对于 $s$ 中每个位置 $i$，我们要找到最大的 $j$ 满足$s[i - j +1]\u0026hellip;s[i]$ 和 $p[1]\u0026hellip;[j]$ 相同 $f[i]$ 对应$j$的位置，$j$对应$p$中的位置 如果 $j$ 不等于 $m$，并且 $s[i + 1] == p[j + 1]$，$j$ 右移一位 否则，","title":"KMP"},{"content":"简单的排序实现 快速排序 快排 分治思想 复杂度 $[n\\log n, n^2]$ 不稳定 \u0026ndash;$x$随机取\n排序区间为 $[l, r]$ 时，长度小于 $1$，直接退出，否则选一个数字 $x$ 作为比较元素\n将大于 $x$ 的放右边，小于 $x$ 的放左边，等于 $x$ 的随意放\n确定 $x$ 的位置后，对两侧继续递归\nvoid quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand() % (r - l + 1)]); // 保证 x 随机取 int x = a[l]; int i = l, j = r; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt; x) // 不能写成 a[j] \u0026gt;= x j--; if (i \u0026lt; j) a[i++] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt; x) // 不能写成 a[i] \u0026lt;= x i++; if (i \u0026lt; j) a[j--] = a[i]; } a[i] = x; quicksort(l, i - 1); // 不能递归 i quicksort(i + 1, r); } //另一种写法\nvoid Quicksort(int l, int r){ if(l\u0026gt;=r)return; int b[100001],c[100001]; int x=a[l+rand()\u0026amp;(r-l+1)]; int l1=0,l2=0,y=0; for(int i=l;i\u0026lt;=r;i++){ if(a[i]\u0026lt;x) b[++l1]=a[i]; else if(a[i]\u0026gt;x) c[++l2]=a[i]; else ++y; } for(int i=1;i\u0026lt;=l1;i++) a[l+i-1]=b[i]; for(int i=1;i\u0026lt;=y;i++) a[l+l1+i-1]=x; for(int i=1;i\u0026lt;=l2;i++) a[l+l1+y+i-1]=c[i]; Quicksort(l,l+l1-1); Quicksort(l+l1+y,r); } 归并排序 归并排序 分治 复杂度 $n\\log n$ 且稳定 要排序 $[l, r]$，长度为$1$直接退出，否则分为 $[l, m],[m+1, r]$; 递归两个子区间进行归并排序 将排序好的子区间合并\nvoid mergesort(int l,int r){ if(l==r)return; int m=(l+r)/2; mergesort(l,m); mergesort(m+1,r); int p1=l,p2=m+1,tot=0; while(p1\u0026lt;=m\u0026amp;\u0026amp;p2\u0026lt;=r){ if(a[p1]\u0026lt;=a[p2]) c[++tot]==a[p1++]; else c[++tot]=a[p2++]; } while(p1\u0026lt;=m) c[++tot]=a[p1++]; while(p2\u0026lt;=m) c[++tot]=a[p2++]; for(int i=1;i\u0026lt;=tot;i++) a[i+l-1]=c[i]; } 计数排序 计数排序 适合值域范围较小 复杂度 $n+k$ 稳定 统计每个数字出现了几次 统计完出现次数，求前缀和，可知道每个数字在拍完序的位置的范围 保证稳定性，倒着确定原本每个位置上的数字最后排在低级位\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[a[i]]; for(int i=1;i\u0026lt;=m;i++) for(int j=1;j\u0026lt;=c[i];j++) printf(\u0026#34;%d\u0026#34;,i); printf(\u0026#34;\\n\u0026#34;); for(int i=2;i\u0026lt;=m;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[i]=c[a[i]]--; for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d\u0026#34;,r[i]); printf(\u0026#34;\\n\u0026#34;); } 基数排序 基数排序 复杂度 $nk$ 拆分成 $m$ 个关键字 从后往前 依次对 $m$ 个关键字进行排序 每次排序会使用上一次排序的结果 一般使用计数排序来完成每次的排序 例如对三位数排序 先排个位 再排十位 再排百位 经常被用于字符串的排序 后缀数组的核心就是基数排序\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[v[i]]; for(int i=1;i\u0026lt;=9;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[sa[i]]=c[v[sa[i]]]--; for(int i=1;i\u0026lt;=n;i++) sa[r[i]]=i; } void radixsort(){ for(int i=1;i\u0026lt;=n;i++) sa[i]=i; int x=1; for(int i=1;i\u0026lt;=m;i++,x*=10){ for(int j=1;j\u0026lt;=n;j++){ v[j]=a[j]/x%10; } countingsort(); } } ","permalink":"https://blog.050623.xyz/posts/study/easy-sort/","summary":"简单的排序实现 快速排序 快排 分治思想 复杂度 $[n\\log n, n^2]$ 不稳定 \u0026ndash;$x$随机取 排序区间为 $[l, r]$ 时，长度小于 $1$，直接退出，否则选一个数字 $x$ 作为比较元素 将大于 $x$ 的放右边，小于 $x$ 的放左边，等于 $x$ 的随意放 确定 $x$ 的位置后，对两侧继续递归 void quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand()","title":"简单的排序"}]