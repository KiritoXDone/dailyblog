[{"content":"æ‚é¡¹ åŠ é€Ÿ sync_with_stdio(0);cin.tie(0);cout.tie(0)\néšæœºæ•° : random_device æˆ– chrono::system_clock::now().time_since_epoch().count()\næœ€çŸ­è·¯ dijkstra $O(mlogn)$\nstruct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } SPFA $O(km)$ k ä¸ºå¸¸æ•°ï¼Œæœ€å·®ä¸º $O(nm)$\nstruct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int dis[N],cnt[N],vis[N]; queue\u0026lt;int\u0026gt;q; bool spfa(int n,int s){ memset(dis,63,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto x:edge[u]){ int v=x.v,w=x.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n)return false; if(!vis[v])q.push(v),vis[v]=1; } } } return true; } æœ€å°ç”Ÿæˆæ ‘ Kruskal $O(mlogm)$ åŠ è¾¹\nstruct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int find(int i){ if(fa[i]==i)return i; return fa[i]=find(fa[i]); } int Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=find(a[i].x),y=find(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } return cnt; } Prim $O(n^2)$ åŠ ç‚¹\nstruct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } LCA æœ€è¿‘å…¬å…±ç¥–å…ˆ\nå€å¢é¢„å¤„ç† $O(nlogn)$ æŸ¥è¯¢ $O(logn)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 6e5+7; int n,m,s; vector\u0026lt;int\u0026gt;v[N]; int d[N],f[N][32]; void dfs(int x,int y){ d[x]=d[y]+1; f[x][0]=y; for(int i=1;i\u0026lt;=31;i++){ f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i\u0026lt;v[x].size();i++){ if(d[v[x][i]]==0)dfs(v[x][i],x); } } int lca(int x,int y){ if(d[x]\u0026lt;d[y])swap(x,y); for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;d[f[x][i]]\u0026gt;=d[y]) x=f[x][i]; } if(x==y)return x; for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;f[y][i]!=0\u0026amp;\u0026amp;f[x][i]!=f[y][i]){ x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;lca(x,y)\u0026lt;\u0026lt;endl; } } SG æ¿ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[1010]; int main() { int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; i++) { set\u0026lt;int\u0026gt; s; for (int j = 1; j \u0026lt;= i; j *= p) { s.insert(sg[i - j]); } while (s.count(sg[i])) sg[i]++; printf(\u0026#34;%d %d\\n\u0026#34;, i, sg[i]); } return 0; } å­—ç¬¦ä¸² KMP void kmp(){ n=s.size()+1,m=p.size()+1;//å­—ç¬¦ä¸²ä¸‹æ ‡ä» 1 å¼€å§‹ int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } EXKMP(z-algorithm) æ±‚ s å’Œä»–çš„åç¼€çš„æœ€é•¿å…¬å…±å‰ç¼€\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } Manacher æ±‚å‡ºå­—ç¬¦ä¸²ä¸­æœ€é•¿å›æ–‡ç‰‡æ®µ\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } æœ€å°è¡¨ç¤ºæ³• void getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } æ•°è®º å¿«é€Ÿå¹‚ long long qpow(long long a, long long b) { long long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = res * a; a = a * a; b \u0026gt;\u0026gt;= 1; } return res; } exgcd i64 exgcd(i64 a, i64 b, i64 \u0026amp;x, i64 \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } i64 g = exgcd(b, a % b, y, x); y -= a / b * x; return g; } // ax + b = 0 (mod m) std::pair\u0026lt;i64, i64\u0026gt; sol(i64 a, i64 b, i64 m) { assert(m \u0026gt; 0); b *= -1; i64 x, y; i64 g = exgcd(a, m, x, y); if (g \u0026lt; 0) { g *= -1; x *= -1; y *= -1; } if (b % g != 0) { return {-1, -1}; } x = x * (b / g) % (m / g); if (x \u0026lt; 0) { x += m / g; } return {x, m / g}; } æ¬§æ‹‰ç­› std::vector\u0026lt;int\u0026gt; minp, primes; void sieve(int n) { minp.assign(n + 1, 0); primes.clear(); for (int i = 2; i \u0026lt;= n; i++) { if (minp[i] == 0) { minp[i] = i; primes.push_back(i); } for (auto p : primes) { if (i * p \u0026gt; n) { break; } minp[i * p] = p; if (p == minp[i]) { break; } } } } bool isprime(int n) { return minp[n] == n; } é«˜ç²¾åº¦ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; constexpr int N = 1000; struct BigInt { int a[N]; BigInt(int x = 0) : a{} { for (int i = 0; x; i++) { a[i] = x % 10; x /= 10; } } BigInt \u0026amp;operator*=(int x) { for (int i = 0; i \u0026lt; N; i++) { a[i] *= x; } for (int i = 0; i \u0026lt; N - 1; i++) { a[i + 1] += a[i] / 10; a[i] %= 10; } return *this; } BigInt \u0026amp;operator/=(int x) { for (int i = N - 1; i \u0026gt;= 0; i--) { if (i) { a[i - 1] += a[i] % x * 10; } a[i] /= x; } return *this; } BigInt \u0026amp;operator+=(const BigInt \u0026amp;x) { for (int i = 0; i \u0026lt; N; i++) { a[i] += x.a[i]; if (a[i] \u0026gt;= 10) { a[i + 1] += 1; a[i] -= 10; } } return *this; } }; std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;o, const BigInt \u0026amp;a) { int t = N - 1; while (a.a[t] == 0 \u0026amp;\u0026amp; t \u0026gt; 0) { t--; } for (int i = t; i \u0026gt;= 0; i--) { o \u0026lt;\u0026lt; a.a[i]; } return o; } çº¿æ®µæ ‘ struct Tag { int mul, add; }; struct Node { int len, sum; Tag tag; } tr[N\u0026lt;\u0026lt;2]; Tag operator + (const Tag \u0026amp;a, const Tag \u0026amp;b) { return {a.mul * b.mul % mod, (a.add * b.mul + b.add) % mod}; } Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = (l.sum + r.sum) % mod; a.tag = {1, 0}; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, Tag t) { tr[now].tag = tr[now].tag + t; tr[now].sum = (tr[now].sum * t.mul + tr[now].len * t.add) % mod; } void pushdown(int now) { if (tr[now].tag.mul != 1 || tr[now].tag.add) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = {1, 0}; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], {1, 0}}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, Tag val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans = (ans + query(ls, l, r, s, mid)) % mod; if (r \u0026gt; mid) ans = (ans + query(rs, l, r, mid + 1, t)) % mod; return ans; } ","permalink":"http://localhost:1313/posts/study/template/","summary":"å¸¸ç”¨æ¨¡æ¿ï¼Œä¸æ—¶æ›´æ–°","title":"Template"},{"content":"åŸºæœ¬éƒ½æ˜¯æ­åœ¨ Serv00 ä¸Šçš„\nåˆæäº†å‡ ä¸ª CF Worker ä¸Šçš„\nAlist é“¾æ¥\nPrivateBin é“¾æ¥\nå›¾åºŠ é“¾æ¥\nå‰ªè´´æ¿ é“¾æ¥\nWebSSH å·²åºŸå¼ƒ æš‚ç”¨ Linux-do ä½¬å‹çš„æœåŠ¡ é“¾æ¥\nCron-Serv00 é“¾æ¥\nUptime-KUMA é“¾æ¥\nProxy è®¢é˜…è½¬æ¢ï¼šé“¾æ¥ Serv00 å’Œ CF Worker èŠ‚ç‚¹ï¼šé“¾æ¥ ","permalink":"http://localhost:1313/posts/tech/tools/","summary":"è‡ªå»ºä½¿æˆ‘å¿«ä¹","title":"è‡ªå»ºå°ç©å…·"},{"content":"å‰è¨€ åˆæ˜¯å·®ç½šæ—¶èƒ½å·é“¶ï¼Œå”‰ï¼Œè¿˜æ˜¯å®åŠ›ä¸å¤Ÿï¼Œè¿™åœºæ„Ÿè§‰å¯å†™çš„ä¸å°‘ï¼Œå’Œä¹‹å‰ vp å—äº¬é‚£åœºå·®ä¸å¤š\nA. The Fool åˆšå¼€å§‹ä¸€çœ¼ä»¥ä¸ºæ‰¾ QWQ å·®ç‚¹äº¤äº†ï¼Œè¿˜å¥½è€ƒè™‘äº†ä¸€ä¸‹ï¼Œå®é™…æ˜¯ä¸€å †ç›¸åŒçš„ä¸²ï¼Œé‡Œé¢ä¼šæœ‰ä¸€ä¸ªä¸²ä¸å…¶ä»–ä¸²ä¸åŒï¼Œè¾“å‡ºé‚£ä¸ªä¸²çš„ä½ç½®\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; string s[n+1]; map\u0026lt;string,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;mp; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;s[i]; for(int i=1;i\u0026lt;=n;i++){ int cnt=1; for(int j=0;j\u0026lt;(int)s[i].size();j+=k){ string tmp=s[i].substr(j,k); mp[tmp].push_back({i,cnt}); cnt++; } } for(int i=1;i\u0026lt;=n;i++){ int cnt=1; for(int j=0;j\u0026lt;(int)s[i].size();j+=k){ string tmp=s[i].substr(j,k); if(mp[tmp].size()==1){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; return 0; } cnt++; } } } J. Temperance è¢«é¢˜æ„å“ˆä½äº†ï¼Œå®é™…ä¸Šå…ˆåˆ å€¼å°çš„å¹¶ä¸ä¼šå½±å“åˆ°åé¢çš„ï¼Œå› ä¸ºå¦‚æœä»–å’Œåé¢å€¼æ›´å¤§çš„åœ¨åŒä¸€è¡Œæˆ–åˆ—ï¼Œä»–ä¹Ÿæ˜¯é‚£ä¸ªå¤§å€¼ï¼Œè€Œä¸æ˜¯è¿™ä¸ªå°çš„å€¼\næ‰€ä»¥åªéœ€è¦ç»Ÿè®¡å°äº $i$ çš„å€¼æœ‰å¤šå°‘ä¸ªå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5+7; int a[N],b[N],c[N]; int n; void solve(){ map\u0026lt;int,int\u0026gt;x,y,z; vector\u0026lt;int\u0026gt;s; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i]; x[a[i]]++; y[b[i]]++; z[c[i]]++; } for(int i=1;i\u0026lt;=n;i++){ int tmp=-1; tmp=max({x[a[i]]-1,y[b[i]]-1,z[c[i]]-1}); s.push_back(tmp); } sort(s.begin(),s.end()); s.push_back(N+50); int cnt=0; for(int i=0;i\u0026lt;n;i++){ while(s[cnt]\u0026lt;i\u0026amp;\u0026amp;cnt\u0026lt;(int)s.size())cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. The Magician ä¸€å…± $52$ å¼ ç‰Œï¼Œæ¯ç§ç‰Œæœ€å¤š $13$ å¼ ï¼Œæœ€å¤šå‰©ä¸‹ $3$ å¼ ï¼Œå³ä¸€å…±æœ€å¤šå‰©ä¸‹ $12$ å¼ ï¼Œè¦æ±‚çš„å…¶å®å°±æ˜¯ç”¨è¿™ $12$ å¼ èƒ½å†æ‹¼å‡ºå‡ ä¸ªåŒèŠ±é¡º\né˜Ÿé•¿å¤§æ¨¡æ‹Ÿä¸¤å‘è¿‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+7; int cnt[5],id[1000],flag[5],num=0; bool vis[5]; bool sol() { int sum=0,now[5],tmp=num,ff[5]; for(int i=1;i\u0026lt;=4;++i) { if(!vis[i]) sum+=cnt[i]; now[i]=cnt[i]; ff[i]=flag[i]; } for(int i=1;i\u0026lt;=4;++i) { if(!vis[i]) continue; if(ff[i]){ int x=min(3,5-now[i]); now[i]+=x; sum-=x; ff[i]=0; } if(now[i]==5) continue; int x=min(tmp,5-now[i]); now[i]+=x; tmp-=x;sum-=x; if(now[i]==5) continue; else return 0; } return 1; } bool dfs(int k) { if(k==0) { return sol(); } for(int i=1;i\u0026lt;=4;++i) { if(vis[i]) continue; vis[i]=1; bool x=dfs(k-1); if(x) return 1; vis[i]=0; } return 0; } void solve() { num=0; for(int i=1;i\u0026lt;=4;++i) cnt[i]=flag[i]=0,vis[i]=0; int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;++i) { string s; cin\u0026gt;\u0026gt;s; ++cnt[id[s[1]]]; } for(int i=1;i\u0026lt;=4;++i) { ans+=cnt[i]/5; cnt[i]%=5; } for(int i=1;i\u0026lt;=4;++i) cin\u0026gt;\u0026gt;flag[i]; for(int i=1;i\u0026lt;=2;++i) { int x; cin\u0026gt;\u0026gt;x; num+=x; } int tot=0; for(int i=1;i\u0026lt;=4;++i) { tot+=cnt[i]; } for(int i=tot/5;i\u0026gt;=1;--i) { bool x=dfs(i); if(x) { ans+=i; break; } } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main() { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); id[\u0026#39;D\u0026#39;]=1;id[\u0026#39;C\u0026#39;]=2;id[\u0026#39;H\u0026#39;]=3;id[\u0026#39;S\u0026#39;]=4; int T=1; cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } F. The Hermit åŠ çš„æ€è·¯ å¼€å§‹æˆ‘æƒ³çš„æ˜¯ç»Ÿè®¡æ¯ç§æ•°å¯èƒ½è¢«åˆ çš„æ¬¡æ•°ï¼Œæœ€ååœ¨æ‰€æœ‰çš„ç­”æ¡ˆä¸­å‡å»è¿™éƒ¨åˆ†\nä½†æ˜¯æƒ³é”™äº†ä¸€ç‚¹å°±æ˜¯åªè€ƒè™‘äº†åˆ å‰å‡ ä½ï¼Œæ²¡æœ‰è€ƒè™‘å€å¢æ—¶ï¼Œå‰é¢çš„å‡ ä¸ªéƒ½èƒ½åˆ \né˜Ÿé•¿æƒ³çš„æ˜¯æŒ‰é•¿åº¦åˆ†å¼€ï¼Œå‰é¢çš„éƒ¨åˆ†æ˜¯å€å¢å…³ç³»éœ€è¦åˆ çš„ï¼Œåé¢éƒ¨åˆ†æ˜¯ç•™ä¸‹çš„ï¼ŒåŠ åˆ°ç­”æ¡ˆä¸Šçš„\nå‰é¢çš„ç‰‡æ®µçš„é•¿åº¦åªå¯èƒ½ä¸º $O(\\log n)$ï¼ŒåŒæ—¶ç¡®å®šå‰é¢ç‰‡æ®µçš„æœ€å¤§å€¼ä¹‹åï¼Œåé¢çš„ç‰‡æ®µåªéœ€è¦æŒ‰ç»„åˆæ•°è®¡ç®—å¾—å‡ºæ•°é‡å³å¯\næ¯æ¬¡åŠ å‰é¢ç‰‡æ®µçš„ç§ç±»æ•°é‡ä¹˜ä»¥åé¢ç‰‡æ®µçš„ç§ç±»æ•°é‡å³å¯\nå£èƒ¡å¾—åˆ°è¿™ä¸ªåº”è¯¥æ˜¯ $O(n \\log n \\log n)$ çš„æ¥ç€ï¼Œå®é™…äº¤ä¸Šå»åªè·‘äº† $200$ å¤š $ms$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+7,mod=998244353; ll jc[N],inv[N],f[N][20],n,m,g[N][20],id[N]; ll qpow(ll x,ll k) { ll ans=1,tmp=x; while(k) { if(k\u0026amp;1) ans=ans*tmp%mod; tmp=tmp*tmp%mod; k\u0026gt;\u0026gt;=1; } return ans; } ll C(int x,int y) { if(x\u0026lt;y) return 0; return jc[x]*inv[y]%mod*inv[x-y]%mod; } ll calc(int x,int y) { if(x\u0026lt;y) return 0; if(y==0) return 0; if(g[id[x]][n-y]!=-1) return g[id[x]][n-y]; ll sum=0; for(int i=1;i\u0026lt;=x;++i) { sum=(sum+C(x/i-1,y-1))%mod; } sum=(C(x,y)-sum+mod)%mod; g[id[x]][n-y]=sum; return sum; } void solve() { memset(g,-1,sizeof(g)); int tot=0; cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;n; inv[0]=jc[0]=1; for(int i=1;i\u0026lt;=m;++i) { jc[i]=jc[i-1]*i%mod; inv[i]=inv[i-1]*qpow(i,mod-2)%mod; if(!id[m/i]) id[m/i]=++tot; } ll ans=calc(m,n)*n%mod; for(int i=1;i\u0026lt;=m;++i) { f[i][1]=1; for(int j=1;j\u0026lt;=19\u0026amp;\u0026amp;j\u0026lt;=n;++j) { if(!f[i][j]) break; for(int k=i*2;k\u0026lt;=m;k+=i) f[k][j+1]=(f[k][j+1]+f[i][j])%mod; ll x=calc(m/i,n-j); ans=(ans+f[i][j]*x%mod*(n-j)%mod)%mod; } } printf(\u0026#34;%lld\u0026#34;,ans); } int main() { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } å‡çš„æ€è·¯ é¢˜è§£å’Œæˆ‘å¼€å§‹æƒ³é‚£ç§æœ‰ç‚¹ç±»ä¼¼ï¼Œæ˜¯å‡æ¯ä¸ªæ•°èƒ½è¢«åˆ çš„æ¬¡æ•°\næŠŠé˜Ÿé•¿é‚£ä¸ªå’Œæˆ‘æƒ³çš„ç»“åˆä¸‹å·®ä¸å¤š\næŒ‰é¢˜è§£çš„æ€è·¯ï¼š\nå…ˆå›ºå®šä¸€ä¸ªå…ƒç´  $x$ï¼Œå¦‚æœä»–èƒ½è¢«åˆ æ‰ï¼š æ¯”ä»–å°çš„ï¼Œæ„æˆäº†ä¸€ä¸ªä»¥ $x$ ç»“å°¾çš„å€æ•°é“¾ æ¯”ä»–å¤§çš„ï¼Œéƒ½æ˜¯ $x$ çš„å€æ•° å°çš„éƒ¨åˆ†æšä¸¾å€æ•°é“¾ï¼Œæ±‚å¾—é•¿åº¦ä¸º cï¼Œå½“å‰å€¼ä¸º x çš„é“¾çš„æ•°é‡ å¤§çš„éƒ¨åˆ†ç›´æ¥ç»„åˆæ•°æ±‚ æœ€åå‡å»çš„æ€»æ•°ä¸º $\\sum_{1\\leq c\\leq n,1\\leq x\\leq m}f_{c,x}\\cdot \\begin{pmatrix} \\lfloor m/x\\rfloor-1 \\ n-c \\end{pmatrix}.$\n","permalink":"http://localhost:1313/posts/study/ccpc2024jinan/","summary":"VP å·®å¼ºäººæ„","title":"CCPC2024jinan"},{"content":" å§“å KiritoXD èŒä¸š æŸä¸çŸ¥åå››éå¤§å­¦ç”Ÿ å…´è¶£çˆ±å¥½ ç¾½æ¯›çƒï¼ŒACMï¼ŒVPSç­‰ç­‰ åšå®¢ç†å¿µ è®°å½•è‡ªå·±çš„å­¦ä¹ æ—¥å¸¸å’ŒæŠ˜è…¾è®°å½• ","permalink":"http://localhost:1313/about/","summary":"å§“å KiritoXD èŒä¸š æŸä¸çŸ¥åå››éå¤§å­¦ç”Ÿ å…´è¶£çˆ±å¥½ ç¾½æ¯›çƒï¼ŒACMï¼ŒVPSç­‰ç­‰ åšå®¢ç†å¿µ è®°å½•è‡ªå·±çš„å­¦ä¹ æ—¥å¸¸å’ŒæŠ˜è…¾è®°å½•","title":"ğŸ™‹ğŸ»â€â™‚ï¸ å…³äº"},{"content":"æœç´¢é¡µ æ·»åŠ æ ‡ç­¾ åœ¨ ./layouts/_default/search.html ä¸­æœ«å°¾æ·»åŠ \n{{- if not (.Param \u0026#34;hideTags\u0026#34;) }} {{- $taxonomies := .Site.Taxonomies.tags }} {{- if gt (len $taxonomies) 0 }} \u0026lt;h2 style=\u0026#34;margin-top: 32px\u0026#34;\u0026gt;{{- (.Param \u0026#34;tagsTitle\u0026#34;) | default \u0026#34;tags\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;ul class=\u0026#34;terms-tags\u0026#34;\u0026gt; {{- range $name, $value := $taxonomies }} {{- $count := .Count }} {{- with site.GetPage (printf \u0026#34;/tags/%s\u0026#34; $name) }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Name }} \u0026lt;sup\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;sup\u0026gt;{{ $count }}\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/sup\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{- end }} {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{- end }} åŒæ—¶å» ./content/search.md æ·»åŠ å¦‚ä¸‹\nhideTags: false tagsTitle: Tags Fuse.js å¯ä»¥é€šè¿‡ä¿®æ”¹ config.yml æ¥é…ç½®æœç´¢\nfuseOpts: # æœç´¢é…ç½® isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [ \u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34; ] æ–‡ç« æ¦‚è§ˆ ä½¿ç”¨çš„åº”è¯¥æ˜¯ summary è€Œä¸æ˜¯ description\n","permalink":"http://localhost:1313/posts/tech/papermod/","summary":"è®°å½•ä¼˜åŒ–ä¸»é¢˜çš„è¿‡ç¨‹","title":"Papermod"},{"content":"Hugging Face é¦–å…ˆæ³¨å†Œ æŠ±æŠ±è„¸ è´¦å·ï¼Œæ–°å»ºä¸€ä¸ª space\nå…·ä½“é€‰é¡¹çœ‹å›¾ æ¥ç€åœ¨åº“é‡Œå»ºä¸€ä¸ª Dockerfileï¼ŒæŠŠä»£ç ç²˜è´´è¿‡å»\nFROM ubuntu:22.04 # Install necessary tools RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y software-properties-common \u0026amp;\u0026amp; \\ add-apt-repository ppa:qbittorrent-team/qbittorrent-stable \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; \\ apt-get install -y \\ qbittorrent-nox \\ tar \\ gzip \\ file \\ jq \\ curl \\ sed \\ aria2 \\ locales \\ locales-all \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/ RUN locale-gen zh_CN.UTF-8 ENV LANG=zh_CN.UTF-8 \\ LANGUAGE=zh_CN:zh \\ LC_ALL=zh_CN.UTF-8 # Set up a new user named \u0026#34;user\u0026#34; with user ID 1000 RUN useradd -m -u 1000 user # Switch to the \u0026#34;user\u0026#34; user USER user # Set home to the user\u0026#39;s home directory ENV HOME=/home/user \\ PATH=/home/user/.local/bin:$PATH # Set the working directory to the user\u0026#39;s home directory WORKDIR $HOME/alist # Download the latest alist release using jq for robustness RUN curl -sL https://api.github.com/repos/alist-org/alist/releases/latest | \\ jq -r \u0026#39;.assets[] | select(.name | test(\u0026#34;linux-amd64.tar.gz$\u0026#34;)) | .browser_download_url\u0026#39; | \\ xargs curl -L | tar -zxvf - -C $HOME/alist # Set up the environment RUN chmod +x $HOME/alist/alist \u0026amp;\u0026amp; \\ mkdir -p $HOME/alist/data # Create data/config.json file with database configuration RUN echo \u0026#39;{\\ \u0026#34;force\u0026#34;: false,\\ \u0026#34;address\u0026#34;: \u0026#34;0.0.0.0\u0026#34;,\\ \u0026#34;port\u0026#34;: 5244,\\ \u0026#34;scheme\u0026#34;: {\\ \u0026#34;https\u0026#34;: false,\\ \u0026#34;cert_file\u0026#34;: \u0026#34;\u0026#34;,\\ \u0026#34;key_file\u0026#34;: \u0026#34;\u0026#34;\\ },\\ \u0026#34;cache\u0026#34;: {\\ \u0026#34;expiration\u0026#34;: 60,\\ \u0026#34;cleanup_interval\u0026#34;: 120\\ },\\ \u0026#34;database\u0026#34;: {\\ \u0026#34;type\u0026#34;: \u0026#34;mysql\u0026#34;,\\ \u0026#34;host\u0026#34;: \u0026#34;ENV_MYSQL_HOST\u0026#34;,\\ \u0026#34;port\u0026#34;: ENV_MYSQL_PORT,\\ \u0026#34;user\u0026#34;: \u0026#34;ENV_MYSQL_USER\u0026#34;,\\ \u0026#34;password\u0026#34;: \u0026#34;ENV_MYSQL_PASSWORD\u0026#34;,\\ \u0026#34;name\u0026#34;: \u0026#34;ENV_MYSQL_DATABASE\u0026#34;\\ }\\ }\u0026#39; \u0026gt; $HOME/alist/data/config.json # Create a startup script that runs Alist and Aria2 RUN echo \u0026#39;#!/bin/bash\\n\\ sed -i \u0026#34;s/ENV_MYSQL_HOST/${MYSQL_HOST:-localhost}/g\u0026#34; $HOME/alist/data/config.json\\n\\ sed -i \u0026#34;s/ENV_MYSQL_PORT/${MYSQL_PORT:-3306}/g\u0026#34; $HOME/alist/data/config.json\\n\\ sed -i \u0026#34;s/ENV_MYSQL_USER/${MYSQL_USER:-root}/g\u0026#34; $HOME/alist/data/config.json\\n\\ sed -i \u0026#34;s/ENV_MYSQL_PASSWORD/${MYSQL_PASSWORD:-password}/g\u0026#34; $HOME/alist/data/config.json\\n\\ sed -i \u0026#34;s/ENV_MYSQL_DATABASE/${MYSQL_DATABASE:-alist}/g\u0026#34; $HOME/alist/data/config.json\\n\\ aria2c --enable-rpc --rpc-listen-all --rpc-allow-origin-all --rpc-listen-port=6800 --daemon\\n\\ qbittorrent-nox --webui-port=8080 \u0026amp;\\n\\ $HOME/alist/alist server --data $HOME/alist/data\u0026#39; \u0026gt; $HOME/alist/start.sh \u0026amp;\u0026amp; \\ chmod +x $HOME/alist/start.sh # Set the command to run when the container starts CMD [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;/home/user/alist/start.sh\u0026#34;] # Expose the default Alist port EXPOSE 5244 6800 8080 å†åœ¨ readme.md é‡Œå¢æ·»ä¸€è¡Œ app_port:5244\næ³¨å†Œä¸€ä¸ª mysql æ•°æ®åº“ï¼Œæ–¹ä¾¿æœºå­é‡å¯æ•°æ®ä¸ä¸¢å¤±\næ¨èç”¨ sqlpub æˆ–è€… db4free\nç„¶åæ·»åŠ  variables:\nMYSQL_USER MYSQL_PORT (é»˜è®¤ 3306) MYSQL_PASSWORD MYSQL_HOST (db4free.net æˆ– mysql.sqlpub.com) MYSQL_DATABASE AList ç¬¬ä¸€æ¬¡å¯åŠ¨ (å¯¹ sql æ¥è¯´) ä¼šç”Ÿæˆä¸€ä¸ªå¯†ç ï¼Œè®°å¾—åœ¨ log é‡Œæ‰¾ï¼Œç™»å½•ä¸Šå»ä¹‹åå¯ä»¥å¯¼å…¥ä»¥å‰é…ç½®ä»€ä¹ˆçš„ï¼Œå³å¯æ­£å¸¸ä½¿ç”¨\nCloudflare Worker å…¬å¼€åº“ å‰æ–‡å›¾ä¸Šæ¨èè®¾ç½®ä¸ºç§äººåº“ï¼Œå¯èƒ½èƒ½æ´»æ›´ä¹…ï¼Œä½†æ˜¯æœç´¢å…¬å¼€åº“å‘ç° AList æ³›æ»¥ï¼Œè¿˜ä¸å¦‚æ–¹ä¾¿æ–¹ä¾¿è‡ªå·±ï¼Œå…¬å¼€åº“åä¾¿å¯ä»¥ä½¿ç”¨ Worker åä»£åˆ°è‡ªå·±åŸŸåä¸‹è®¿é—®\nexport default { async fetch(request, env) { const _url = new URL(request.url); const hostname = _url.hostname _url.hostname = \u0026#34;github.com\u0026#34; const req = new Request(_url, request); req.headers.set(\u0026#39;origin\u0026#39;, \u0026#39;https://github.com\u0026#39;); const res = await fetch(req); let newres = new Response(res.body, res); let location = newres.headers.get(\u0026#39;location\u0026#39;); if (location !== null \u0026amp;\u0026amp; location !== \u0026#34;\u0026#34;) { location = location.replace(\u0026#39;://github.com\u0026#39;, \u0026#39;://\u0026#39;+hostname); newres.headers.set(\u0026#39;location\u0026#39;, location); } return newres }, }; æ›¿æ¢ github.com ä¸º ç”¨æˆ·å-spaceå.hf.space å³å¯\nç§åº“ (AList ä¸å¯ç”¨æ­¤æ–¹æ³•) åªé€‚ç”¨äº header ä¸åŒ…å« Authorization\nåˆšå‘ç°ç§äººåº“é€šè¿‡ access token ä¹Ÿå¯ä»¥åä»£è®¿é—®\nè®¿é—®åœ°å€åŒæ ·å¦‚ä¸Š ç”¨æˆ·å-spaceå.hf.space\nåœ¨æŠ±æŠ±è„¸ä¸Šç‚¹å¤´åƒåé€‰æ‹© access token\nåç§°éšæ„\ntoken æƒé™é€‰ Repositories çš„ä¸‰ä¸ªå³å¯\nWorker ä»£ç å¦‚ä¸‹\nåœ¨è®¾ç½®ä¸­æ·»åŠ å˜é‡ HF_TOKEN å€¼ä¸ºä¸Šæ–‡ç”Ÿæˆçš„ access token\nexport default { async fetch(request, env) { const url = new URL(request.url); // å¤„ç†APIè¯·æ±‚å’Œå…¶ä»–è¯·æ±‚ url.host = \u0026#39;xxxx.hf.space\u0026#39;; // æ·»åŠ è®¤è¯å¤´ç”¨äºè®¿é—®ç§æœ‰ç©ºé—´ const headers = new Headers(request.headers); headers.set(\u0026#39;Authorization\u0026#39;, `Bearer ${env.HF_TOKEN}`); const newRequest = new Request(url, { method: request.method, headers: headers, body: request.body }); return fetch(newRequest); } } ","permalink":"http://localhost:1313/posts/tech/hf-alist/","summary":"æˆ‘ TM è–…è–…è–…","title":"åœ¨ Hugging Face ä¸Šéƒ¨ç½² AList (Aria2 å’Œ Qbitorrent å¯ç”¨)"},{"content":"F. Ardent Flames è¯»é¢˜æ˜“æƒ³åˆ°äºŒåˆ†ç­”æ¡ˆ\näºŒåˆ†æ¬¡æ•°ï¼Œå¯¹äºæ¯ä¸ªæ€ªç‰© $i$ï¼Œå·²çŸ¥å½“å‰æ”»å‡»çš„æ¬¡æ•°ï¼Œå°±èƒ½å¾—åˆ°æ¯æ¬¡æ”»å‡»å¿…é¡»é€ æˆçš„ä¼¤å®³\nå¦‚æœè¿™ä¸ªä¼¤å®³å¤§äº $m$ï¼Œé‚£ä¹ˆè·³è¿‡å®ƒï¼Œè¿™ä¸ªæ€ªç‰©ä¸å¯é€‰ åä¹‹å°† $\\begin{bmatrix} x_i-\\left(m-\\left\\lceil\\frac{h_i}{t}\\right\\rceil\\right),x_i+\\left(m-\\left\\lceil\\frac{h_i}{t}\\right\\rceil\\right) \\end{bmatrix}$ å·¦å³ç«¯åˆ†åˆ«å‚¨å­˜ï¼Œé€šè¿‡ç¦»æ•£åŒ–æ¥æŸ¥æ‰¾åŒå¤„äºæŸåŒºé—´å†…æ•°çš„ä¸ªæ•°ï¼Œè®°å½•ä¸ªæ•°çš„æœ€å¤§å€¼ï¼Œå¦‚æœå¤§äº $k$ï¼Œå½“å‰ $check$ å³ä¸º $1$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,k; int x[N],h[N]; bool check(int mid){ deque\u0026lt;int\u0026gt;p,q; int cnt=0,mx=0; for(int i=1;i\u0026lt;=n;i++){ int dmg=ceil(1.0*h[i]/mid); if(dmg\u0026gt;m)continue; int cha=m-dmg; p.push_back(x[i]-cha),q.push_back(x[i]+cha+1); } sort(p.begin(),p.end()); sort(q.begin(),q.end()); while(p.size()\u0026amp;\u0026amp;q.size()){ if(p.front()==q.front())q.pop_front(),p.pop_front(); else if(p.front()\u0026lt;q.front())p.pop_front(),cnt++; else q.pop_front(),cnt--; mx=max(mx,cnt); } return mx\u0026gt;=k; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;h[i]; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;x[i]; int l=1,r=mod,ans=-1; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)){ r=mid-1; ans=mid; } else l=mid+1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G. Natlan Exploring å¯ä»¥æƒ³åˆ°ç”¨ dp æ¥ç»Ÿè®¡ç­”æ¡ˆï¼Œ$f_i = f_i + f_j \\quad (1 \\leq j \u0026lt; i, \\gcd(a_i, a_j) \\neq 1)$\nä½†æ˜¯ç›´æ¥æš´åŠ›ç»Ÿè®¡æ˜¯ $O(n^2)$ çš„ï¼Œæ˜¾ç„¶ä¸è¡Œï¼Œè¦ä¼˜åŒ–ï¼Œ$gcd$ å…·ä½“å€¼æ— æ‰€è°“ï¼Œåªè¦ä¸ä¸º $1$ï¼Œé‚£ä¹ˆåªè¦ä¸¤æ•°äº’è´¨å³å¯ï¼Œå³æ²¡æœ‰ç›¸åŒçš„è´¨å› æ•°å°±è¡Œäº†\nè€ƒè™‘å¯¹ $a[i]$ åˆ†è§£ï¼Œç„¶åæš´åŠ›ç»Ÿè®¡ç¬¦åˆæƒ…å†µçš„ï¼Œä½†è¿™æ ·ä¾ç„¶å®¹æ˜“è¢«å¡æ‰\næ‰€ä»¥è¿˜éœ€è¦ä¼˜åŒ–\nå¯ä»¥å‘ç°ï¼Œå…¶å®çœŸæ­£æœ‰ç”¨çš„æ•°ï¼Œå°±æ˜¯ç”±è´¨å› æ•°å€å¢äº§ç”Ÿå…³ç³»çš„ï¼Œå°† x äº§ç”Ÿçš„æ•°æ”¾åœ¨ä¸€èµ·ï¼Œå†è®¡ç®—è¿™ä¸ª x ä¼šå¯¹ç­”æ¡ˆé€ æˆçš„è´¡çŒ®ï¼Œä½†æ˜¯è¿™æ ·ä¼šé‡å¤è®¡ç®—ï¼Œæ‰€ä»¥è¦è€ƒè™‘å®¹æ–¥ï¼Œåªéœ€è¦åœ¨è®¡ç®—æ—¶çœ‹ è´¨å› å­çš„ä¸ªæ•°ï¼Œå¦‚æœä¸ºå¥‡æ•°ï¼Œå°±åŠ ä¸Šï¼Œåä¹‹ï¼Œåˆ™å‡å»\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=998244353; int n,a[N],b[N],f[N]; vector\u0026lt;int\u0026gt;g[N],h[N]; void fc1(int x,int id){ for(int i=2;1ll*i*i\u0026lt;=x;i++){ if(x%i==0){ h[id].push_back(i); while(x%i==0)x/=i; } } if(x\u0026gt;1)h[id].push_back(x); } void fc2(int id){ int x=1; for(auto t:h[id])x*=t; for(int i=2;1ll*i*i\u0026lt;=x;i++){ if(x%i==0){ g[id].push_back(i); if(x!=i)g[id].push_back(x/i); } } if(x\u0026gt;1)g[id].push_back(x); } void solve(){ cin\u0026gt;\u0026gt;n; int mx=0; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; mx=max(mx,a[i]); } for(int i=2;i\u0026lt;=mx;i++){ fc1(i,i),fc2(i); } f[1]=1; for(int i=1;i\u0026lt;=n;i++){ for(auto x:g[a[i]]){ if(h[x].size()\u0026amp;1)f[i]=(f[i]+b[x])%mod; else f[i]=(f[i]-b[x]+mod)%mod; } for(auto x:g[a[i]])b[x]=(b[x]+f[i])%mod; } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf988fg/","summary":"æ˜¨å¤©å·®çš„ä¸¤é¢˜è¡¥åœ¨è¿™äº†","title":"Codeforces Round 988 (Div. 3) F and G"},{"content":"A. Twice çœ‹ç›¸åŒæ•°å­—å‡ºç°æ¬¡æ•°å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int n; int a[N]; void solve() { map\u0026lt;int,int\u0026gt;vis; int ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; vis[a[i]]++; if(vis[a[i]]\u0026gt;=2)ans++,vis[a[i]]-=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Intercepted Inputs æ˜¾ç„¶æ˜¯æ‰¾ä¸¤ä¸ªæ•°ç›¸ä¹˜ç­‰äº $n-2$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n; int a[N]; void solve() { cin\u0026gt;\u0026gt;n; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; vis[a[i]]++; } int tmp=n-2; for(int i=1;i\u0026lt;=n;i++){ int t=tmp/a[i]; if(t*a[i]==tmp){ if(t==a[i]\u0026amp;\u0026amp;vis[a[i]]\u0026gt;=2){ cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; return; } else if(t=a[i]\u0026amp;\u0026amp;vis[t]){ cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; return; } } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Superultra\u0026rsquo;s Favorite Permutation å¯ä»¥å‘ç°ï¼Œå°äº $5$ çš„éƒ½ä¸è¡Œï¼Œç„¶åå…ˆæŒ‰ ${1,3,5,4,2}$ æ’ï¼Œå¥‡æ•°æ’å·¦è¾¹ï¼Œå¶æ•°æ’å³è¾¹å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; deque\u0026lt;int\u0026gt;q; void solve() { int n; q.clear(); cin\u0026gt;\u0026gt;n; if(n\u0026lt;=4){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } q.push_back(1);q.push_back(3);q.push_back(5);q.push_back(4);q.push_back(2); for(int i=6;i\u0026lt;=n;i++){ if(i\u0026amp;1)q.push_front(i); else q.push_back(i); } for(auto x:q)cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } Sharky Surfing æ˜¾ç„¶ï¼Œå½“å‰æ‰€å¤„ä½ç½®å·¦ä¾§çš„åŠ é€Ÿç‚¹éƒ½èƒ½åƒåˆ°ï¼Œåªéœ€è¦ä¿è¯å½“å‰èƒ½é‡è¶³å¤Ÿè·³è¿‡å½“å‰å³ä¾§çš„éšœç¢å³å¯ï¼Œæ¨¡æ‹Ÿä¸€éå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n,m,L; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;L; deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;block,power; for(int i=1;i\u0026lt;=n;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; block.push_back({a,b}); } for(int i=1;i\u0026lt;=m;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; power.push_back({a,b}); } int pos=1,now=1,ans=0; multiset\u0026lt;int\u0026gt;s; while(block.empty()){ while(block.empty() \u0026amp;\u0026amp; pos \u0026gt;= block.front().second) block.pop_front(); if (block.empty()) break; pos=block.front().first; while(power.size()){ if(power.front().first\u0026lt;pos){ s.insert(power.front().second); power.pop_front(); } else break; } int len=block.front().second-block.front().first+1; while(now\u0026lt;=len\u0026amp;\u0026amp;s.size()){ ans++; now+=*(--s.end()); s.erase((--s.end())); } if(now\u0026lt;=len){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } pos+=now; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E. Kachina\u0026rsquo;s Favorite Binary String é¢˜çœ‹åŠå¤©æ‰çœ‹æ‡‚ $f(l,r)$ æ˜¯è¿™ä¸ªå­ä¸²ä¸­å­˜åœ¨ $01$ å­åºåˆ—çš„æ•°é‡\nIMPOSSIBLE çš„æƒ…å†µå°±æ˜¯ $f(1,n)$ ç­‰äº $0$ï¼Œè¿™æ—¶å€™å¯èƒ½å…¨ $1$ æˆ–å…¨ $0$\næœ‰ $n$ æ¬¡è¯¢é—®æœºä¼šï¼Œé‚£å°±å¯ä»¥å›ºå®šå·¦ç«¯ç‚¹ä¸º $1$ï¼Œå³ç«¯ç‚¹ $2~n$ï¼Œå°†å¯¹åº”ç»“æœå­˜æ”¾èµ·æ¥ å› ä¸ºè¦æ‰¾çš„æ˜¯ $01$ï¼Œç„¶åèµ·å§‹è¿ç»­çš„ $1$ éƒ½ä¸ä¼šå¯¹åé¢é€ æˆå½±å“ï¼Œå³æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ç¬¬ä¸€æ¬¡ $0$ å‡ºç°çš„ä½ç½®\nå¯¹æ¯ä¸ªä½ç½®è¯¢é—®çš„ç»“æœå’Œä»–å‰æ–¹çš„æ¯”è¾ƒï¼Œå¦‚æœå½“å‰ä½ç½®æ¯”å‰æ–¹å¤§ï¼Œé‚£ä¹ˆå½“å‰ä½ç½®ä¸€å®šæ˜¯ $1$ï¼Œæ‰èƒ½ä½¿ $f$ çš„å€¼å¢å¤§ï¼Œåä¹‹å°±æ˜¯ $0$\næ¥ç€æ‰¾åˆ°ç¬¬ä¸€æ¬¡å‡ºç° $0$ çš„ä½ç½®ï¼Œæ­¤ä½ç½®å‰æ–¹æœ‰ä¸€ä¸ªç‰‡æ®µéƒ½æ˜¯ $1$ï¼Œç‰‡æ®µä» $1$ åˆ° $i-1-cnt[i]$ï¼Œè¿™æ ·ä¿è¯å‰æ–¹çš„ $01$ åˆšå¥½ç¬¦åˆé¢˜æ„ï¼Œå‰æ–¹ç¬¦åˆåï¼Œåæ–¹ä¹Ÿä¼šç¬¦åˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 // #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e4+7, mod=1e9+7; int n; int a[N],b[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=n;i++)b[i]=0; for(int i=2;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;? 1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; cin\u0026gt;\u0026gt;a[i]; } if(a[n]==0){ cout\u0026lt;\u0026lt;\u0026#34; IMPOSSIBLE\\n\u0026#34;; cout\u0026lt;\u0026lt;endl; return; } b[1]=0; for(int i=2;i\u0026lt;=n;i++){ if(a[i]\u0026gt;a[i-1])b[i]=1; } for(int i=2;i\u0026lt;=n;i++){ if(b[i]){ for(int j=1;j\u0026lt;=i-1-a[i];j++)b[j]=1; } } cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;b[i]; cout\u0026lt;\u0026lt;endl; } int main(){ // ios::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf988/","summary":"Codeforces Round 988 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 988 (Div. 3)"},{"content":"A. Penchick and Modern Monument å› ä¸º $n$ å¾ˆå°ï¼Œå¯ä»¥ç›´æ¥æš´åŠ›$O(n^2)$ åˆ¤æ–­æ¯ä¸ªä½ç½®ä¸å˜çš„æƒ…å†µä¸‹ï¼Œå·¦å³éœ€è¦å˜å‡ æ¬¡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int h[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;h[i]; int ans=INT_MAX; for(int i=1;i\u0026lt;=n;i++){ int cnt=0; int lst=h[i]; for(int j=i-1;j\u0026gt;0;j--){ if(h[j]\u0026gt;lst)cnt++; else lst=h[j]; } lst=h[i]; for(int j=i+1;j\u0026lt;=n;j++){ if(h[j]\u0026lt;lst)cnt++; else lst=h[j]; } ans=min(ans,cnt); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Penchick and Satay Sticks æ˜“å‘ç°ï¼Œæ¯ä¸ªæ•°å­—æœ€å¤šäº¤æ¢ä¸€æ¬¡åˆ°ä½ï¼Œå³å®ƒåªå¯èƒ½åœ¨æ­£ç¡®ä½ç½®çš„å·¦å³ï¼Œé‚£æˆ‘ä»¬åªéœ€è¦å¯¹æ¯ä¸ªä½ç½®åˆ¤æ–­å³å¯ï¼Œå¦‚æœå·¦å³äº¤æ¢åä¸ºæ­£ç¡®çš„å°±äº¤æ¢ï¼Œåä¹‹å°±è¯´æ˜æ˜¯ No\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; int p[N]; void solve(){ cin\u0026gt;\u0026gt;n; bool flag=0; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;p[i]; for(int i=1;i\u0026lt;n;i++){ if(p[i]==i)continue; else { if(p[i]==i+1\u0026amp;\u0026amp;p[i+1]==i){ swap(p[i],p[i+1]); continue; } else { cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } } } cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Penchick and BBQ Buns é¦–å…ˆå¯ä»¥å‘ç°ï¼Œå¶æ•°æ—¶åªéœ€è¦ä¸¤ä¸ªä¸¤ä¸ªå¡«å³å¯ï¼Œä½†æ˜¯å¥‡æ•°æƒ…å†µä¸ç¡®å®š\nç ”ç©¶å®Œå…¨å¹³æ–¹æ•°åï¼Œå¯ä»¥å‘ç° $9, 16, 25$ ä¸‰ä¸ªæ•°å¯ä»¥æ»¡è¶³ 3 ä¸ªæ•°å¡«ä¸Šåï¼Œç›¸äº’ä¹‹é—´çš„è·ç¦»ä¸ºå®Œå…¨å¹³æ–¹æ•°ï¼Œå³å¯¹åº”ä½ç½® $1, 10, 26$ ä½†æ˜¯è¿™æ ·è¿˜æ˜¯æ— æ³•æ»¡è¶³å…¶ä»–ä½ç½®çš„éœ€æ±‚ï¼Œå› ä¸º $10 \\sim 26$ å’Œ $26 \\sim n$ ä¹‹é—´çš„ä¸ªæ•°éƒ½æ˜¯å¥‡æ•°ä¸ªï¼Œæ²¡æ³•æŒ‰å¶æ•°çš„ç›´æ¥å¡«ï¼Œé‚£ä¹ˆå°±éœ€è¦åœ¨è¿™ä¸¤ä¸ªç‰‡æ®µä¸­å„å¡«ä¸€ä¸ªä½¿å…¶å˜ä¸ºå¶æ•°é•¿åº¦ï¼ŒåŒæ—¶æœ€å¥½ä¸è¦å½±å“åé¢å¡«çš„æ•°ï¼Œå¯ä»¥å‘ç°æ˜¯ $11, 27$ æ˜¯æœ€ä¼˜çš„é‚£ä¹ˆåªè¦æ˜¯å¤§äºç­‰äº $27$ çš„å¥‡æ•°éƒ½æ˜¯æœ‰è§£çš„\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; int a[N]={0, 1,3,3,4,4,5,5,6,6,1,2,7,7,8,8,9,9,10,10,11,11,12,12,13,13,1,2}; void solve(){ cin\u0026gt;\u0026gt;n; if(n\u0026amp;1){ if(n\u0026gt;26){ for(int i=1;i\u0026lt;=27;i++)cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; n-=27; int cnt=14; for(int i=1;i\u0026lt;=n/2;i++){ cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cnt++; } cout\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } else{ for(int i=1;i\u0026lt;=n/2;i++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Penchick and Desert Rabbit æ˜“æƒ³åˆ°ï¼Œæ¯ä¸ªä½ç½®å¯¹åº”çš„æœ€å¤§å€¼å°±æ˜¯å‘åè·³ä¹‹åä½ç½®çš„å‰æ–¹çš„æœ€å¤§ç½®\næ‰€ä»¥è®°å½•æ¯ä¸ªä½ç½®å‰æ–¹çš„æœ€å¤§å€¼ï¼Œåæ–¹çš„æœ€å°å€¼\né—®é¢˜æ˜¯å¦‚ä½•å¤„ç†æ¯ä¸ªä½ç½®ä¸Šçš„è·³è·ƒï¼š\nå¦‚æœ $pre[i] \u0026gt; suf[i+1]$ é‚£ä¹ˆ $i$ ä¸€å®šèƒ½è·³åˆ° $i+1$ å¯¹åº”çš„æœ€å¤§å€¼ $i$ å¯ä»¥å…ˆå‘å‰è·³åˆ° $pre[i]$ å¯¹åº”ä½ç½®ï¼Œå†è·³åˆ° $suf[i+1]$ å¯¹åº”çš„ä½ç½®ï¼Œæ­¤æ—¶å°±èƒ½è·³åˆ° $i+1$ å¯¹åº”çš„æœ€å¤§å€¼ åä¹‹ï¼Œå³è·³ä¸åˆ° $i+1$ å¯¹åº”çš„æœ€å¤§å€¼ï¼Œæ­¤æ—¶çš„ç­”æ¡ˆå°±æ˜¯ $pre[i]$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=5e5+7, mod=1e9+7; int n; int a[N],suf[N],pre[N],ans[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } pre[0]=-1; suf[n+1]=INT_MAX; for(int i=1;i\u0026lt;=n;i++){ pre[i]=max(pre[i-1],a[i]); } for(int i=n;i\u0026gt;0;i--){ suf[i]=min(suf[i+1],a[i]); } for(int i=n;i\u0026gt;0;i--){ if(pre[i]\u0026gt;suf[i+1])ans[i]=ans[i+1]; else ans[i]=pre[i]; } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf987/","summary":"Codeforces Round 987 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 987 (Div. 2)"},{"content":"A. Alice\u0026rsquo;s Adventures in \u0026ldquo;Chess\u0026rdquo; å› ä¸ºå›¾å°ï¼Œå¯ä»¥ç›´æ¥æŒ‰ä¸²è·‘ $100$ éç­‰ï¼Œåæ­£æš´åŠ›å°±è¡Œ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int n,xx,yy; string s; map\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;int\u0026gt;\u0026gt;vis; void bfs(){ deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;q; q.push_back({0,0}); vis[{0,0}].push_back(0); int now=0; while(q.size()){ int x=q.front().first,y=q.front().second; q.pop_front(); if(s[now%n]==\u0026#39;N\u0026#39;){ y++; } else if(s[now%n]==\u0026#39;S\u0026#39;){ y--; } else if(s[now%n]==\u0026#39;E\u0026#39;){ x++; } else x--; if(x==xx \u0026amp;\u0026amp; y==yy){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; return; } q.push_back({x,y}); now++; if(now\u0026gt;1000){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } } } void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;xx\u0026gt;\u0026gt;yy\u0026gt;\u0026gt;s; bfs(); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Alice\u0026rsquo;s Adventures in Permuting è§‚å¯Ÿåˆ° $a$ å…¶å®å°±æ˜¯ä¸€ä¸ªç­‰å·®æ•°åˆ—\nå½“æœ€å°é¡¹å¤§ç­‰äº$n$ æ—¶ï¼Œåªéœ€è¦å†è¿›è¡Œ $n$ æ¬¡æ“ä½œå³å¯\nè‹¥ $b$ ä¸ºé›¶ï¼Œå³æ•°ç»„ä¸­éƒ½ä¸º $c$ æ—¶ï¼Œå¦‚æœè¿™ä¸ª $c$ å°äºä¸€ä¸ªç•Œé™ï¼Œä¼šå¯¼è‡´åé¢çš„æ“ä½œåªä¼šå¯¹æŸä¸ªæ•°ä¸€ç›´è¿›è¡Œï¼Œè¿™æ˜¯å”¯ä¸€çš„æ— è§£æƒ…å†µ\nå¦åˆ™ï¼Œåªéœ€è¦è¿›è¡Œ $n-1$ æ¬¡æ“ä½œï¼Œå¡«æ»¡ç¼ºå°‘çš„å³å¯\nå¦‚æœ $b$ ä¸ä¸º 0ï¼Œé‚£ä¹ˆä¸€å®šå¯è¡Œï¼Œè¿›è¡Œæ¬¡æ•°å³ä¸ºæ•°ç»„ä¸­å¤§äºç­‰äº $n$ çš„æ•°çš„ä¸ªæ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; ll n,b,c; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; if(c\u0026gt;=n)cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else if(b){ if(n-3\u0026gt;=c)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;n-1\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;n-(n-c-1)/b-1\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Alice\u0026rsquo;s Adventures in Cutting Cake å› ä¸ºå¿…é¡»åˆ†æˆ $m-1$ å—ï¼ŒAlice å–çš„ä¸€å®šæ˜¯å…¶ä¸­è¿ç»­çš„ç‰‡æ®µï¼Œå³è¿™ä¸ªç‰‡æ®µå·¦ä¾§å’Œå³ä¾§æ»¡è¶³æ¡ä»¶çš„ç‰‡æ®µè¦æœ‰ $m$ ä¸ª\næˆ‘ä»¬å¯ä»¥å…ˆé¢„å¤„ç†ä»å‰å¾€åï¼Œä»åå¾€å‰çš„ç‰‡æ®µä¸­ç¬¦åˆæ¡ä»¶çš„ä¸ªæ•°ï¼Œè¿™æ ·ç»Ÿè®¡é€‰å–ç‰‡æ®µåå…¶ä»–ç‰‡æ®µç¬¦åˆæ¡ä»¶çš„ä¸ªæ•°åªéœ€è¦ $O(1)$ å³å¯å®Œæˆ\næ¥ç€å°±æ˜¯å¦‚ä½•ç¡®å®šè¿™ä¸ªç‰‡æ®µï¼Œå¯ä»¥ä»¥ $1 \\sim n$ ä¸ºå·¦ç«¯ç‚¹ï¼Œæ¥ç€äºŒåˆ†æ‰¾æ»¡è¶³æ¡ä»¶çš„æœ€å¤§çš„å³ç«¯ç‚¹ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n \\log n)$ å¯ä»¥æ»¡è¶³é¢˜ç›®\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=2e5+7, mod=1e9+7; int n,m,v; ll a[N],s[N],pre[N],suf[N]; bool check(int l,int r){ if(l\u0026gt;r)return 1; int cnt=0,lst=1; cnt+=pre[l-1]+suf[r+1]; return cnt\u0026gt;=m; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;v; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int cnt=0,tmp=0; for(int i=1;i\u0026lt;=n;i++){ s[i]=s[i-1]+a[i]; tmp+=a[i]; if(tmp\u0026gt;=v)tmp=0,cnt++,pre[i]=pre[i-1]+1; else pre[i]=pre[i-1]; } tmp=0,suf[n+1]=0; for(int i=n;i\u0026gt;0;i--){ tmp+=a[i]; if(tmp\u0026gt;=v)suf[i]=suf[i+1]+1,tmp=0; else suf[i]=suf[i+1]; } if(cnt\u0026lt;m){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ll res=0; for(int i=1;i\u0026lt;=n;i++){ int l=i,r=n; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(i,mid)){ if(i\u0026lt;=mid)res=max(res,s[mid]-s[i-1]); l=mid+1; } else r=mid-1; } } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Alice\u0026rsquo;s Adventures in Cards å®¹æ˜“å¾€å›¾é‚£æ–¹é¢æƒ³ï¼Œè™½ç„¶ CF å®˜æ–¹é¢˜è§£è¯´è¿™æ˜¯ DP é¢˜ï¼Œä½†æ˜¯æŒ‰å›¾çš„æ€æƒ³ä¹Ÿèƒ½è¿‡\nå¯ä»¥å…ˆæŒ‰ bfs æ¥è·‘ï¼Œéå†æ‰€æœ‰çš„èƒ½äº¤æ¢çš„å¡ç‰‡ï¼Œè¿™æ ·å°±èƒ½æ‰¾åˆ°é€šå¾€æ‰€æœ‰èƒ½åˆ°è¾¾å¡ç‰‡çš„å¯¹åº”è·¯ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æœ€çŸ­è·¯\nbfs è¿‡ç¨‹ä¸­å¦‚æœèƒ½åˆ°è¾¾ $n$ è¯´æ˜æ˜¯ Yes\nèƒ½åˆ°è¾¾å°±é€šè¿‡ dfs æ¥ä» $1$ éå†æ‰€æœ‰èƒ½åˆ°è¾¾çš„å¡ç‰‡ï¼Œæ¥æ‰¾æœ€çŸ­åˆ°è¾¾ $n$ çš„è·¯ï¼Œæœ€åè¾“å‡ºå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,flag; int a[4][N],b[4][N]; bool vis[4][N],used[N]; vector\u0026lt;pair\u0026lt;char,int\u0026gt;\u0026gt;ans,g[N]; set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;s[4]; void bfs(int x){ set\u0026lt;int\u0026gt;q; q.insert(x); used[x]=1; while(q.size()){ int now=*q.begin(); q.erase(q.begin()); for(int i=a[1][now];i\u0026lt;=n;i++){ if(vis[1][i])break; if(used[b[1][i]]\u0026amp;\u0026amp;b[1][i]\u0026gt;now){ g[now].push_back({\u0026#39;q\u0026#39;,b[1][i]}); if(b[1][i]==n){ flag=1; break; } used[b[1][i]]=1; q.insert(b[1][i]); } vis[1][i]=1; } for(int i=a[2][now];i\u0026lt;=n;i++){ if(vis[2][i])break; if(used[b[2][i]]\u0026amp;\u0026amp;b[2][i]\u0026gt;now){ g[now].push_back({\u0026#39;k\u0026#39;,b[2][i]}); if(b[2][i]==n){ flag=1; break; } used[b[2][i]]=1; q.insert(b[2][i]); } vis[2][i]=1; } for(int i=a[3][now];i\u0026lt;=n;i++){ if(vis[3][i])break; if(used[b[3][i]]\u0026amp;\u0026amp;b[3][i]\u0026gt;now){ g[now].push_back({\u0026#39;j\u0026#39;,b[3][i]}); if(b[3][i]==n){ flag=1; break; } used[b[3][i]]=1; q.insert(b[3][i]); } vis[3][i]=1; } } } void dfs(int x){ used[x]=1; if(x==n){ flag=1; return; } for(auto j:g[x]){ if(used[j.second]){ ans.push_back(j); dfs(j.second); if(flag)return; ans.pop_back(); } } } void solve(){ cin\u0026gt;\u0026gt;n; flag=0; ans.clear(); for(int i=1;i\u0026lt;=3;i++){ s[i].clear(); for(int j=1;j\u0026lt;=n;j++){ int x; cin\u0026gt;\u0026gt;x; g[j].clear(); used[x]=0; vis[i][j]=0; s[i].insert({n-x+1,j}); } int cnt=0; for(auto [x,y]:s[i]){ cnt++; a[i][y]=cnt; b[i][cnt]=y; } } bfs(1); if(flag==0)cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else { flag=0; for(int i=1;i\u0026lt;=n;i++)used[i]=0; dfs(1); cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto [x,y]:ans){ cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Alice\u0026rsquo;s Adventures in the Rabbit Hole æš‚æ—¶æœ‰ç‚¹æ€è·¯ï¼Œåé¢æ¨å‡ºæ¥è¡¥\n","permalink":"http://localhost:1313/posts/study/cf986/","summary":"Codeforces Round 986 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 986 (Div. 2)"},{"content":"å‰è¨€ é“äº†ï¼Œå”‰ï¼Œèµ›æ—¶å‘æŒ¥ä¸€å¨å±\nI. In Search of the Ultimate Artifact èµ›æ—¶ä¸€çœ¼ç›¯çœŸï¼Œé‰´å®šä¸ºçº¯çº¯çš„æš´åŠ›ï¼Œè‡ªå·±å†™äº†ä¼šå‘ç°è€æ˜¯ä¸å¯¹ï¼Œè®©é˜Ÿé•¿ä¸Šæœºè°ƒäº†å‡ åˆ†é’Ÿè¿‡äº†\né¢˜æ„å³æ¯æ¬¡é€‰å½“å‰æœ€å¤§çš„ $k$ ä¸ªæ•°ç›¸ä¹˜ï¼Œæ±‚æœ€åèƒ½å¾—åˆ°çš„æœ€å¤§çš„æ•°æ˜¯å¤šå°‘ï¼Œå¯¹è¿™ä¸ªæœ€å¤§çš„æ•°å–æ¨¡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=998244353; int n,k; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n,greater\u0026lt;ll\u0026gt;()); ll ans=a[1]%mod; deque\u0026lt;int\u0026gt;q; ll tmp=1; for(int i=2;i\u0026lt;=n;i++){ if(a[i]==0)break; q.push_back(a[i]); tmp=(tmp*a[i])%mod; if((int)q.size()%(k-1)==0){ ans=(ans*tmp)%mod; tmp=1; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Conquer the Multiples èµ›æ—¶å±…ç„¶å¡äº† 1 ä¸ªå¤šå°æ—¶\nç®€å•çš„åšå¼ˆè®º\næ˜“å‘ç°ï¼Œå¶æ•°ä¹˜äºä»»ä½•æ•°éƒ½è¿˜æ˜¯å¶æ•°ï¼Œå³ä»å¶æ•°å¼€å§‹çš„äººï¼Œæ˜¯æ— æ³•é˜»ç¢å¦ä¸€ä¸ªäººçš„ï¼Œä½†æ˜¯å¥‡æ•°çš„äººå¯ä»¥å»æ‹¿å¶æ•°ä½ä¸Šçš„ï¼Œå³å¥‡æ•°å¼€å§‹çš„äººå¤„äºä¼˜åŠ¿åœ°ä½\nåŸºç¡€æƒ…å†µä¸ºæ¯ä¸ªäººåªæ‹¿å½“å‰ä½ç½®\næœ€ä¼˜æƒ…å†µï¼Œå¶æ•°ä»ç„¶åªèƒ½æ‹¿å½“å‰ä½ç½®ï¼Œæ‹¿åé¢çš„åªä¼šå¦¨ç¢è‡ªå·±ï¼Œå¥‡æ•°èƒ½æ‹¿å¶æ•°æ—¶ä¼˜å…ˆæ‹¿å¶æ•°\nå¯ä»¥å‘ç°ï¼ŒåŸºç¡€æ­¥æ•°æ˜¯åŒºé—´å†…å¥‡å¶çš„ä¸ªæ•°ï¼Œè€ƒè™‘åˆ°æœ€ä¼˜æƒ…å†µï¼Œå¥‡æ•°ä¼šæ‹¿èµ°å¶æ•°çš„ï¼Œæˆ‘ä»¬åªéœ€è¦çœ‹å¥‡æ•°æŒ‰æœ€ä¼˜çš„æ“ä½œåï¼Œè°çš„æ­¥æ•°å¤šå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=998244353; ll l,r; void solve(){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if(l\u0026amp;1){ if(l*2\u0026lt;=r){cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;;return;} } else { if((l+1)*2\u0026lt;=r){cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;;return;} } cout\u0026lt;\u0026lt;(((r-l+1)\u0026amp;1) ? \u0026#34;Alice\\n\u0026#34; : \u0026#34;Bob\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G. Geometry Task èµ›åœºä¸Šå¤ªæ€¥äº†ï¼Œæ€è·¯åªå¯¹äº†ä¸€éƒ¨åˆ†ï¼Œè¿˜æœ‰éƒ¨åˆ†æ²¡æƒ³åˆ°å°±ä¸Šæœºå¼€å§‹ç¡¬è°ƒäº†\næ˜¾ç„¶æ˜“æƒ³åˆ°äºŒåˆ†ç­”æ¡ˆï¼Œé‡ç‚¹å°±æ˜¯ $check$ çš„è¿‡ç¨‹\nå¼€å§‹æƒ³æ³•æ˜¯å¯¹äºæ¯ä¸ª $çº¢çº¿$ï¼Œç”¨äºŒåˆ†æ‰¾ä»–çš„æœ€ä¼˜çš„ $è“çº¿$ ä¸å…¶åŒ¹é…ï¼Œä½†æ˜¯å¿½è§†äº† $a\u0026lt;0$ $a\u0026gt;0$ å¯¹äºæœ€ä¼˜çš„è¦æ±‚çš„ä¸åŒ ä¾‹å¦‚ $2$ è€…çš„æœ€ä¼˜éƒ½æ˜¯ $1$ æ—¶ï¼Œ$è“çº¿$ æ•°æ®ä¸º ${1,2,3}$ï¼Œå¦‚æœå…ˆåˆ¤æ–­äº†æ­£çš„é‚£ä¸ªï¼Œå®ƒå°±ä¼šå–èµ° $1$ï¼Œé‚£ä¹ˆ è´Ÿçš„å°±å–ä¸äº†äº†\næ‰€ä»¥ï¼Œå°†é—®é¢˜è½¬åŒ–ä¸ºåŒºé—´å–æ•°é—®é¢˜ï¼Œå¯¹äºè´Ÿæ•°ï¼Œæ˜¯åœ¨ $[1,x]$ï¼Œä¸Šå–æ•°ï¼Œå¯¹äºæ­£æ•°ï¼Œæ˜¯åœ¨ $[x,n]$ ä¸Šå–æ•°\nå°†æ­£è´Ÿåˆ†å¼€å¤„ç†ï¼Œåˆ†åˆ«è€ƒè™‘èƒ½å–èµ°å‡ ä¸ªå³å¯ï¼Œæœ€åè¿”å› $cnt\u0026gt;=(mid+1)/2$ å³å¯\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=2e5+7; struct Node{ ll a,b; bool operator\u0026lt;(const Node \u0026amp;tmp){ if(a==tmp.a)return b\u0026lt;tmp.b; return a\u0026lt;tmp.a; } }; Node a[N]; ll c[N]; int cnt[N]; int n,fu,zheng; bool check(ll x){ int res=0; for(int i=1;i\u0026lt;=n;i++)cnt[i]=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i].a\u0026lt;0){ ll l=1,r=fu,ans=0; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if(a[i].a*c[mid]+a[i].b\u0026gt;=x)l=mid+1,ans=mid; else r=mid-1; } cnt[ans]++; } else if(a[i].a==0){ if(a[i].b\u0026gt;=x)res++; } else{ ll l=zheng,r=n,ans=0; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if(a[i].a*c[mid]+a[i].b\u0026gt;=x)r=mid-1,ans=mid; else l=mid+1; } cnt[ans]++; } } int sum=0; for(int i=1;i\u0026lt;=fu;i++){ sum++; if(cnt[i]){ if(sum\u0026gt;=cnt[i])res=res+cnt[i],sum=sum-cnt[i]; else res=res+sum,sum=0; } } sum=0; for(int i=n;i\u0026gt;=zheng;i--){ sum++; if(cnt[i]){ if(sum\u0026gt;=cnt[i])res+=cnt[i],sum-=cnt[i]; else res+=sum,sum=0; } } return res\u0026gt;=(n+1)/2; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].a; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].b; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;c[i]; sort(a+1,a+1+n); sort(c+1,c+1+n); ll l=-2e18,r=2e18,ans=0; fu=0,zheng=n+1; for(int i=n;i\u0026gt;0;i--){ if(a[i].a\u0026lt;0){ fu=i; break; } } for(int i=1;i\u0026lt;=n;i++){ if(a[i].a\u0026gt;0){ zheng=i; break; } } while(l\u0026lt;=r){ ll mid=ll(l+r)\u0026gt;\u0026gt;1; if(check(mid))l=mid+1,ans=mid; else r=mid-1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Basic Graph Algorithm md ä¸‰ä¸ªäººç¡¬æ˜¯æ²¡å¼€å‡ºæ¥\næ˜¾ç„¶æœ€ä¼˜æ˜¯è¿ä¸åˆ°ä¸‹ä¸ªç‚¹æ—¶åŠ è¾¹ï¼Œå‰é¢èƒ½å›æº¯æ—¶åˆ™ä¸åŠ ï¼Œé€‰æ‹©å›æº¯æ¥å®ç°è¿™ä¸ªç‚¹\nåŠ è¾¹ä¸€å®šæ˜¯åŠ åˆ°é å‰çš„ç‚¹æ›´ä¼˜\nä»£ç å®ç°:\né¦–å…ˆå¼€ä¸€ä¸ªè¶…çº§æºç‚¹ $0$ å¯è¿åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶æ‰€æœ‰çš„èŠ‚ç‚¹ä¹Ÿèƒ½å›åˆ°è¿™ä¸ªè¶…çº§æºç‚¹\nç„¶åè®°å½•æ¡è¾¹è¿æ¥çš„ç‚¹\nç”¨ $dfs$ å®ç°ï¼Œæˆ‘ä»¬ä» $0$ ç«¯ç‚¹å¼€å§‹ï¼Œå°†èƒ½åˆ°è¾¾çš„ç‚¹ä¸­å›æ¥çš„è·¯å…¨éƒ¨åˆ æ‰ï¼Œæ¥ç€åˆ¤æ–­æ˜¯å¦å­èŠ‚ç‚¹ä¸­æ˜¯å¦èƒ½å¤Ÿé€šå¾€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœæ²¡æœ‰å¯¹åº”çš„è·¯ï¼Œå°±åŠ ç‚¹ï¼Œæ¥ç€ä»¥ä¸‹ä¸€ä¸ªç‚¹è¿›è¡Œ $dfs$\nå®ç°å›æº¯çš„å…³é”®åœ¨äº $dfs$ ä¸­çš„åˆ¤æ–­é‡‡ç”¨çš„æ˜¯ $while$ï¼Œå¦‚æœå½“å‰è¿™ä¸ªèŠ‚ç‚¹ä»–æ²¡æœ‰è¾¹ï¼Œé‚£æˆ‘ä»¬åº”è¯¥å›å»ï¼Œæ­¤æ—¶ä¹‹å‰çš„èŠ‚ç‚¹ä»ç„¶èƒ½è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦éœ€è¦åŠ è¾¹\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int n,m,k; int p[N]; int vis[N]; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;ans; vector\u0026lt;int\u0026gt;edges[N]; set\u0026lt;int\u0026gt;edge[N]; void dfs(int now){ k++; vis[now]=1; for(int v:edges[now])edge[v].erase(now); while(edge[now].size()\u0026amp;\u0026amp;k\u0026lt;=n){ if(!edge[now].count(p[k]))ans.push_back({now,p[k]}); dfs(p[k]); } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ans.clear(); k=0; for(int i=1;i\u0026lt;=n;i++){ edge[i].insert(0); edge[0].insert(i); edges[i].push_back(0); edges[0].push_back(i); } for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].insert(v); edge[v].insert(u); edges[u].push_back(v); edges[v].push_back(u); } for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;p[i]; dfs(0); cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto [x,y]:ans)cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Decrease and Swap å¼€å§‹é˜Ÿå‹è¯»é”™é¢˜ï¼Œä»¥ä¸ºæ¯ä¸ªç›’å­é‡Œä¸€å—çŸ³å¤´ï¼Œå·®ç‚¹ä¸Šæœºç‰¹åˆ¤ï¼Œè¿˜å¥½å†·é™äº†ï¼Œè™½ç„¶å¯¹ç»“æœä¹Ÿæ²¡ä»€ä¹ˆå½±å“\nå®é™…ä¸Šã€‚æ¯ä¸ªç›’å­å†…éƒ½æ˜¯æ— é™å—çŸ³å¤´ï¼Œé‚£è€ƒè™‘æ—¶ï¼Œå¯ä»¥è€ƒè™‘æŸä¸ªåŒºé—´å†…çš„æ•´ä½“æ“ä½œï¼Œå³æˆ‘ä»¬éå†å‘åæ‰«ï¼Œè®°å½•å½“å‰å„å‡ºç°çš„ $01$ æ¬¡æ•°ï¼Œå¦‚æœ $cnt0\u0026gt;cnt1$ é‚£ä¹ˆï¼Œç»è¿‡ç¥å¥‡çš„å˜æ¢æ“ä½œï¼Œæˆ‘ä»¬ä¸€å®šå¯ä»¥å°†è¿™ä¸ªåŒºé—´å†…æ‰€æœ‰çš„ $1$ å˜ä¸º $0$ï¼Œæœ€åå¦‚æœ $cnt1+cnt0\u0026gt;3 || cnt1+cnt0==0$ é‚£ä¹ˆå°±æ˜¯ Yes\nä¸ºä»€ä¹ˆ $cnt0\u0026gt;cnt1$ å½“å‰åŒºé—´ä¸€å®šèƒ½è½¬åŒ–æˆåŠŸ:\nå› ä¸ºæˆ‘ä»¬çš„æ“ä½œæ¬¡æ•°æ˜¯æ— é™çš„ï¼ŒåŒæ—¶è¿™ä¸ªè§¦å‘æ¡ä»¶ä¸€å®šæœ‰ä¸¤ä¸ª $0$ ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç»è¿‡ä¸€äº›äº¤æ¢åï¼Œæ€»èƒ½ä½¿ä¸¤ä¸ª $0$ åˆ°è¾¾å½“å‰ä¸²çš„æœ«å°¾ï¼Œæ­¤æ—¶å‰é¢çš„ç›’å­ç›´æ¥æ— è„‘æ¶ˆæ‰å³å¯ é‚£ä¹ˆæœ€å $cnt1+cnt0\u0026gt;3$ ä¸ºä»€ä¹ˆæ˜¯ Yes:\næœ€åå‰©ä¸‹çš„æ²¡è½¬åŒ–çš„ä¸²ä¸­ï¼Œ$1$ çš„ä¸ªæ•°å¤§äºç­‰äº $0$ çš„ä¸ªæ•°ï¼ŒåŒæ—¶è¿™ä¸ªä¸²çš„é•¿åº¦å¤§äº $3$ï¼Œå³æˆ‘ä»¬å¯ä»¥å…ˆå¯¹å‡ ä¸ª $1$ æ“ä½œï¼Œè½¬åŒ–å‡ºæ¥ä¸¤ä¸ª $0$ï¼Œå†æ ¹æ®å‰é¢çš„ç†è®ºï¼Œæ­¤æ—¶çš„ä¸²ä¸€å®šèƒ½è½¬æ¢è¿‡å» #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; string s; int cnt[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; int c1=0,c0=0; for(int i=0;i\u0026lt;n;i++){ if(s[i]==\u0026#39;1\u0026#39;)c1++; else c0++; if(c0\u0026gt;c1)c1=c0=0; } if(c1+c0\u0026gt;3||c1+c0==0){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/icpc2024shanghai/","summary":"æ‰“é“çœŸçš„éš¾å—å•Š","title":"ICPC2024shanghai"},{"content":"A. Verify Password å…ˆåˆ¤æ–­å‰ç¼€ä¸­çš„æ•°å­—ç‰‡æ®µï¼Œå¦‚æœæœ‰ç›¸é‚»é€’å‡çš„å°± No\nè¿ç»­çš„çœ‹å®Œä¹‹åçœ‹åé¢çš„å­—æ¯ç‰‡æ®µï¼Œå¦‚æœæœ‰æ•°å­—ï¼Œå°± Noï¼ŒåŒæ—¶ä¹Ÿè¦ä¿æŒéé€’å‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; void solve() { int n; string s,tmp=\u0026#34;\u0026#34;; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;n;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ tmp+=s[i]; } else break; } if (!tmp.empty()) { for (int i = 0; i \u0026lt; tmp.size() - 1; i++) { if (tmp[i] \u0026gt; tmp[i + 1]) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; return; } } } for(int i=tmp.size();i\u0026lt;n-1;i++){ if(s[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;9\u0026#39;){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } if(s[i]\u0026gt;s[i+1]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Increase/Decrease/Copy è¦æŠŠ a å˜æˆ bï¼Œæ¯ä¸€ä½åˆ¤æ–­ï¼Œå…ˆåŠ ä¸Š $abs(a_i-b_i)$ï¼ŒåŒæ—¶åˆ¤æ–­ï¼Œå½“å‰è¿™ä½å˜æ¢åï¼ŒåŠ åˆ° a æœ«å°¾è¡¥å…¨çš„ä»£ä»·ï¼Œæ‰¾åˆ°æœ€å°è¡¥å…¨ä»£ä»·ï¼Œæœ€ååŠ ä¸Šå³ä¸ºç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e5 + 10; void solve() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt;a(n),b(n+1); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=0;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]; ll ans=0,tmp=1e9,t=0; for(int i=0;i\u0026lt;n;i++){ ans+=abs(a[i]-b[i]); if(a[i]\u0026gt;=b[n]\u0026amp;\u0026amp;a[i]\u0026gt;=b[i]\u0026amp;\u0026amp;b[n]\u0026gt;=b[i])t=1; else if(a[i]\u0026lt;=b[n]\u0026amp;\u0026amp;a[i]\u0026lt;=b[i]\u0026amp;\u0026amp;b[n]\u0026lt;=b[i])t=1; else{ int ta=abs(b[n]-min(a[i],b[i]))+1; int tb=abs(b[n]-max(a[i],b[i]))+1; t=min(ta,tb); } tmp=min(tmp,t); } ans+=tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Job Interview æ˜“å‘ç°ï¼Œä¼šæœ‰ä¸€ä¸ªå‰ç¼€ï¼Œé‡Œé¢çš„æ¯ä¸ªäººéƒ½å»è‡ªå·±æœ€æ“…é•¿çš„éƒ¨é—¨ï¼Œè¿™ä¸ªä½ç½®ä¹‹åï¼Œæ‰€æœ‰äººéƒ½å»åŒä¸€ä¸ªéƒ¨é—¨ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹è¿™ä¸ªä½ç½®äºŒåˆ†å³å¯\né€šè¿‡å‰ç¼€å’Œï¼Œåç¼€å’Œå¾—åˆ°è¿™ä¸ªä½ç½®çš„å®é™…å€¼å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) #define int long long typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n, m; int a[N * 2], b[N * 2], pre[N * 2]; ll ans[N * 2], sum[N * 2], sa[N * 2], sb[N * 2]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n + m + 1; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n + m + 1; i++) cin \u0026gt;\u0026gt; b[i]; for (int i = 1; i \u0026lt;= n + m + 1; i++) pre[i] = pre[i - 1] + (a[i] \u0026gt; b[i]); for (int i = 1; i \u0026lt;= n + m + 1; i++) sum[i] = sum[i - 1] + max(a[i], b[i]); sa[n + m + 2] = sb[n + m + 2] = 0; for (int i = n + m + 1; i \u0026gt; 0; i--) { sa[i] = sa[i + 1] + a[i]; sb[i] = sb[i + 1] + b[i]; } for (int i = 1; i \u0026lt;= n + m + 1; i++) { int l = 0, r = n + m + 1, ans = -1; ll NA, NB; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; int na = pre[mid], nb = mid - na; if (mid \u0026gt;= i) (a[i] \u0026gt; b[i] ? na : nb)--; if (na \u0026gt;= n || nb \u0026gt;= m) { NA = na, NB = nb; r = mid - 1, ans = mid; } else l = mid + 1; } int res = sum[ans] - (ans \u0026gt;= i ? max(a[i], b[i]) : 0ll); res += NB == m ? sa[ans + 1] - (ans + 1 \u0026lt;= i ? a[i] : 0) : sb[ans + 1] - (ans + 1 \u0026lt;= i ? b[i] : 0); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe166/","summary":"Educational Codeforces Round 166 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 166 (Rated for Div. 2)"},{"content":"A. Painting the Ribbon æ˜¾ç„¶ï¼ŒAlice çš„ç†æƒ³æ“ä½œæ˜¯æ¯ç§é¢œè‰²å‡åŒ€åˆ†å¸ƒ\nè€Œ Bob çš„ç†æƒ³æ“ä½œæ˜¯é€‰æ‹©å½“å‰æ•°é‡æœ€å¤šçš„é¢œè‰²ï¼Œå°†å…¶ä»–çš„éƒ½å–·ä¸ºè¿™ä¸ªé¢œè‰²\næ‰€ä»¥åªè¦åˆ¤æ–­ k æ˜¯å¦å¤§äº $n-mx$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; if(m==1||k\u0026gt;=n-1){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } int ned=n-ceil(1.0*n/m); if(k\u0026lt;ned)cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Make It Ugly æ³¨æ„åˆ°ï¼Œæ“ä½œåªä¼šä½¿ä¸­é—´çš„å…ƒç´ è¿›è¡Œå˜åŒ–ï¼Œå³ $a_1,a_n$ ä¼šä¿æŒä¸å˜\né‚£ä¹ˆç›®æ ‡å°±æ˜¯æ‰¾åˆ°ä¸¤ä¸ªä¸åŒçš„æ•°ï¼Œåˆ å»ä»–ä»¬ä¹‹å‰çš„ç›¸åŒæ•°çš„ç‰‡æ®µ\næ‰¾åˆ°æœ€çŸ­çš„ç›¸åŒç‰‡æ®µï¼Œå³ä¸ºç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7, inf=1e9; int n,a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int ans=inf,tmp=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i]==a[1])tmp++; else if(tmp)ans=min(ans,tmp),tmp=0; } if(tmp!=n)ans=min(ans,tmp); if(ans==inf)cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Long Multiplication å…¶å®å°±æ˜¯ä½¿ x,y æœ€æ¥è¿‘çš„ï¼Œå³å¯¹æ¯ä¸€ä½åˆ¤æ–­ï¼ŒæŠŠå¤§çš„ç»™å½“å‰å°çš„ï¼Œå°çš„ç»™å½“å‰å¤§çš„\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s,t; bool cmp(string s,string t){ if(s.size()\u0026gt;t.size())return 1; if(t.size()\u0026gt;s.size())return 0; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]-\u0026#39;0\u0026#39;\u0026gt;t[i]-\u0026#39;0\u0026#39;)return 1; if(s[i]-\u0026#39;0\u0026#39;\u0026lt;t[i]-\u0026#39;0\u0026#39;)return 0; } return 1; } void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; string as,at; as=at=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;s.size();i++){ int l=s[i]-\u0026#39;0\u0026#39;,r=t[i]-\u0026#39;0\u0026#39;; if(l\u0026gt;r)swap(l,r); if(cmp(as,at))swap(as,at); as+=(r+\u0026#39;0\u0026#39;),at+=(l+\u0026#39;0\u0026#39;); } cout\u0026lt;\u0026lt;as\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;at\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Colored Balls å‡è®¾å½“å‰çƒçš„æ€»é‡ä¸º $x$ï¼Œå½“å‰æ•°é‡æœ€å¤šçš„çƒçš„æ•°é‡ä¸º $a_i$ï¼Œå¦‚æœ $a_i * 2 \u0026gt; x$ï¼Œé‚£ä¹ˆå½“å‰çš„å€¼å³ä¸º $a_i$ï¼Œåä¹‹ï¼Œå½“å‰çš„å€¼ä¸º $x/2$ã€‚\né¢˜ä¸Šç»™å‡ºæ‰€æœ‰çƒæ•°æ€»å’Œä¸è¶…è¿‡ 5000ï¼Œå³å¯ä»¥å¯¹æ‰€æœ‰çƒçš„æ•°é‡çš„æƒ…å†µè®¡ç®—å½“å‰æ•°é‡ä¸ºæœ€å¤šæ•°é‡æ—¶ï¼Œå„ç§çƒæ€»é‡å¯¹åº”çš„æ–¹æ¡ˆæ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=998244353; int n,a[N]; ll f[N],ans; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); f[0]=1; for(int i=1;i\u0026lt;=n;i++){ int x=a[i]; for(int j=5000;j\u0026gt;x;j--){ ans=(((j+x)/2+(j+x)%2)*f[j]%mod+ans)%mod; if(j+x\u0026lt;=5000)f[j+x]=(f[j+x]+f[j])%mod; } for(int j=x;j\u0026gt;=0;j--){ ans=(ans+f[j]*x%mod)%mod; if(j+x\u0026lt;=5000)f[j+x]=(f[j+x]+f[j])%mod; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe164/","summary":"Educational Codeforces Round 164 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 164 (Rated for Div. 2)"},{"content":"A. Catch the Coin å¯¹æ¯ä¸ªæšç¡¬å¸åˆ†åˆ«åˆ¤æ–­å³å¯\nåªè¦å…¶ y è½´ä¸Šçš„è·ç¦»èƒ½å¤Ÿèµ¶ä¸Šï¼Œä¸€å®šèƒ½å–åˆ°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int mn=-abs(x),mx=abs(x); if(y-abs(x)+1\u0026lt;mn)cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Substring and Subsequence åªèƒ½ $O(n^2)$ å¯¹æ¯ä¸€ä½åˆ¤æ–­å…¶åæ–¹æœ‰å¤šå°‘ä¸ªç›¸åŒçš„å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int ans=s.size()+t.size(); for(int i=0;i\u0026lt;t.size();i++){ int tmp=0; for(int j=0;j\u0026lt;s.size() \u0026amp;\u0026amp; i+tmp\u0026lt;t.size();j++){ if(s[j]==t[i+tmp])tmp++; } ans=min(ans,int(s.size()+t.size())-tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Two Movies æŸäººå¯¹ä¸¤éƒ¨ç”µå½±çš„è¯„ä»·ç›¸åŒæ—¶ï¼Œå°†è¿™ä¸ªè¯„ä»·å­˜ä¸‹ï¼Œä¸åŒæ—¶ï¼Œå–è¯„åˆ†å¤§çš„é‚£é¡¹ï¼Œæœ€åå°†å­˜ä¸‹çš„æ‰€æœ‰è¯„åˆ†åŠ ç»™å½“å‰å°çš„é‚£é¡¹\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,suma,sumb; deque\u0026lt;int\u0026gt;q; void solve(){ suma=sumb=0; q.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(x\u0026gt;y)suma+=x; else if(y\u0026gt;x)sumb+=y; else q.push_back(x); } for(auto x:q){ if(x\u0026gt;0){ if(suma\u0026gt;sumb)sumb++; else suma++; } else{ if(suma\u0026gt;sumb)suma--; else sumb--; } } cout\u0026lt;\u0026lt;min(suma,sumb)\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Smithing Skill é¦–å…ˆæ˜“æƒ³åˆ°è´ªå¿ƒï¼Œå› ä¸ºé”»é€ åï¼Œä¸€å®šç«‹é©¬ç†”é“¸ï¼Œè¿™æ ·ä¸€æ¬¡æ¶ˆè€— $a_i-b_i$ çš„ä»£ä»·\nå½“ $a_i-b_i$ ç›¸ç­‰æ—¶ï¼Œä¸€å®šé€‰å– $a$ å°çš„é‚£ä¸ªæ“ä½œï¼Œè¿™æ ·å¯ä»¥ä¿è¯æ“ä½œæ¬¡æ•°æœ€å¤š\nåŒæ—¶ï¼Œ$a_i-b_i$ å¤§çš„ç‰©å“ï¼Œå…¶ $a_i$ åº”è¯¥å°äºå‰é¢çš„ç‰©å“ï¼Œå› ä¸ºå¦‚æœè¿™ä¸ª $a_i$ æ›´å¤§ï¼Œä¸€å®šæ˜¯é€‰å‰é¢çš„æ›´ä¼˜\næ‰€ä»¥ç‰©å“å…¶å®æ˜¯å•è°ƒæ ˆï¼Œå°†å…¶æŒ‰ç…§ $a_i-b_i$ ä»å°åˆ°å¤§æ¥å­˜ï¼ŒåŒæ—¶ $a_i$ é€æ¸é€’å¢\nå¯¹äºæ ˆä¸­ç‰©å“ï¼Œæˆ‘ä»¬ä¼˜å…ˆä»åå–ï¼Œå› ä¸ºå½“ææ–™æ•°é‡å¤§äºç¬¬ä¸€ä¸ªçš„ $a$ æ—¶ï¼Œæˆ‘ä»¬ä¸€å®šå–çš„æ˜¯ç¬¬ä¸€ä¸ª\nåªæœ‰æ— æ³•å–ç¬¬ä¸€ä¸ªæ—¶ï¼Œæˆ‘ä»¬æ‰ä¼šä»åé¢å–ï¼Œæ¯æ¬¡å–æ—¶ï¼Œè®°å½•å½“å‰ä¹°äº†å‡ ä»¶æ ˆä¸­çš„ç‰©å“ï¼Œdp ä¸­å­˜çš„å°±æ˜¯èƒ½ä¹°å‡ ä»¶åé¢çš„ç‰©å“\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e6+7, mod=1e9+7; int n,m; int a[N],b[N]; map\u0026lt;int,int\u0026gt;vis; int c[N]; ll f[N],g[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]; for(int i=1;i\u0026lt;=n;i++){ int x=a[i]-b[i]; if(vis.find(x)==vis.end())vis[x]=a[i]; else vis[x]=min(vis[x],a[i]); } deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;s; for(auto [x,y]:vis){ if(s.empty())s.push_back({x,y}); else{ if(y\u0026gt;=s.back().second)continue; else s.push_back({x,y}); } } int mx=s.front().second,mn=s.back().second,tmp=0; int ta=s.front().second,tb=s.front().second-s.front().first; for(int i=mn;i\u0026lt;=mx;i++){ if(i==s.back().second){ tmp=s.back().first; s.pop_back(); } f[i]=g[i-tmp]+1; g[i]=max(g[i-1],f[i]); } ll ans=0; for(int i=1;i\u0026lt;=m;i++){ int x; cin\u0026gt;\u0026gt;x; if(x\u0026gt;mx){ int ti=(x-tb)/tmp; x-=ti*tmp; ans+=ti; } ans+=f[x]; } cout\u0026lt;\u0026lt;ans*2\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe167/","summary":"Educational Codeforces Round 167 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 167 (Rated for Div. 2)"},{"content":"A. Quintomania ç…§é¢˜æ„æ¨¡æ‹Ÿä¸‹å»å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ if(abs(a[i+1]-a[i])!=5\u0026amp;\u0026amp;abs(a[i+1]-a[i])!=7){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Startup è®°å½•æ¯ç§ç‰Œå­çš„æ€»ä»·å€¼ï¼Œæ’åºåä»å¤§åˆ°å°å–\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=2e5+7, mod=1e9+7; struct Node{ ll id,val; bool operator\u0026lt;(const Node \u0026amp;a){return val\u0026gt;a.val;} }; int n,k; int b[N],c[N]; map\u0026lt;int,int\u0026gt;vis; void solve(){ cin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;n; vis.clear(); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i]; for(int i=1;i\u0026lt;=n;i++){ vis[b[i]]+=c[i]; } vector\u0026lt;Node\u0026gt;v; for(auto [x,y]:vis){ v.push_back(Node{x,y}); } sort(v.begin(),v.end()); ll ans=0; for(int i=0;i\u0026lt;min(k, (int)v.size());i++){ ans+=v[i].val; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Anya and 1100 æ¯æ¬¡ä¿®æ”¹å…¶å®åªä¼šå¯¹ä¸´è¿‘çš„å‡ ä¸ªä½ç½®é€ æˆå½±å“ï¼Œåªéœ€è¦ç»Ÿè®¡é™„è¿‘æ˜¯å¦å¢åˆ äº† 1100 ç‰‡æ®µå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s; int q; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;q; int n=s.size(); s=\u0026#34; \u0026#34;+s; set\u0026lt;int\u0026gt;st; for(int i=1;i\u0026lt;=n-3;i++){ if(s.substr(i,4)==\u0026#34;1100\u0026#34;)st.insert(i); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(n\u0026lt;4){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; continue; } s[x]=char(\u0026#39;0\u0026#39;+y); // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; for(int i=max(1, x-4); i\u0026lt;=min(n-3, x+4); i++){ if(s.substr(i,4)==\u0026#34;1100\u0026#34;)st.insert(i); else st.erase(i); } if(st.size())cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. I Love 1543 æŠŠå›¾ä¸€å±‚ä¸€å±‚æ‹†åˆ†å¼€ï¼Œå¯¹æ¯ä¸€å±‚å½¢æˆçš„å­—ç¬¦ä¸²è®¡æ•°å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int n,m,ans; char mp[N][N]; bool vis[N][N]; char x; void getString(int x){ string s=\u0026#34;\u0026#34;; for(int i=x;i\u0026lt;=m-x+1;i++){ if(vis[x][i])break; s+=mp[x][i],vis[x][i]=1; } for(int i=x+1;i\u0026lt;=n-x+1;i++){ if(vis[i][m-x+1])break; s+=mp[i][m-x+1],vis[i][m-x+1]=1; } for(int i=m-x;i\u0026gt;x;i--){ if(vis[n-x+1][i])break; s+=mp[n-x+1][i],vis[n-x+1][i]=1; } for(int j=n-x+1;j\u0026gt;x;j--){ if(vis[j][x])break; s+=mp[j][x],vis[j][x]=1; } int len=s.size(); // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; s=s+s; for(int i=0;i\u0026lt;len;i++){ if(s.substr(i,4)==\u0026#34;1543\u0026#34;)ans++; } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; ans=0; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ cin\u0026gt;\u0026gt;x; mp[i][j]=x; vis[i][j]=0; } } for(int i=1;i\u0026lt;=min(n,m);i++){ if(vis[i][i])break; getString(i); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Reverse the Rivers ä¸¤ä¸ªæ•°æŒ‰ä½æˆ–ï¼Œåªå¯èƒ½å˜å¤§ï¼Œé‚£ä¹ˆæ¯ä¸ªä½ç½®éƒ½æ˜¯ä¸€ä¸ªå•è°ƒé€’å¢çš„åºåˆ—ï¼Œæ˜“æƒ³åˆ°é€šè¿‡äºŒåˆ†æ¥æŸ¥æ‰¾ç¬¦åˆçš„å›½å®¶\nè¾“å‡ºç¬¦åˆæ¡ä»¶çš„æœ€å°çš„å›½å®¶åºå·å³å¯\nèµ›æ—¶æ²¡å‘ç° l åˆå§‹è®¾ç½®ä¸º 0 äº†ï¼Œè¿ wa æ•°å‘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e5+7, mod=1e9+7; const ll inf=1e18; int n,k,q,m; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;q; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+10, vector\u0026lt;ll\u0026gt;(k+10)); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=k;j++){ cin\u0026gt;\u0026gt;a[i][j]; a[i][j]|=a[i-1][j]; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; s(k + 1); for(int i=1;i\u0026lt;=k;i++)s[i].push_back(0); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=k;j++){ s[j].push_back(a[i][j]); } } while(q--){ cin\u0026gt;\u0026gt;m; int low=1,up=n; for(int i=1;i\u0026lt;=m;i++){ ll r,c; char x; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x\u0026gt;\u0026gt;c; if(x==\u0026#39;\u0026gt;\u0026#39;){ auto l=upper_bound(s[r].begin(),s[r].end(),c)-s[r].begin(); low = max(low, l); } else{ auto l = lower_bound(s[r].begin(), s[r].end(), c) - s[r].begin(); l--; up = min(up, l); } // cout\u0026lt;\u0026lt;low\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;up\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;low\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;up\u0026lt;\u0026lt;endl; if(low \u0026lt;= up) cout \u0026lt;\u0026lt; low \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } F. XORificator 3000 å¼‚æˆ–å‰ç¼€å’Œæœ‰ä¸€ä¸ªæ€§è´¨\n$f(x)=\\begin{cases}x,x%4=0\\1,x%4=1\\x+1,x%4=2\\0,x%4=3\\end{cases}$\nåŒæ—¶é¢˜ä¸­å¦ä¸€æ€§è´¨çš„æ•°: $xâ‰¡3\\mod2^4$\n$x=0000011,0001011,0010011,0011011$\nå¯ä»¥çœ‹å‡ºï¼Œåå‡ ä½æ˜¯å§‹ç»ˆä¸å˜çš„ï¼Œè€Œå‰é¢çš„ä¼šé€’å¢ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¼‚æˆ–å‰ç¼€å’Œæ±‚å‡º\nå³å¯ä»¥å…ˆå¯¹å‰é¢çš„ä½æ•°æ±‚å¼‚æˆ–å’Œï¼Œå†å¯¹åé¢çš„ä½æ•°æ±‚å¼‚æˆ–å’Œ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; ll l,r,i,k; ll fc(ll n){ if(n%4==0) return n; if(n%4==1) return 1; if(n%4==2) return n+1; return 0; } ll fx(ll n,ll i,ll k){ if(!i){ if(!k)return fc(n); else return 0; } ll x=1ll\u0026lt;\u0026lt;i; if(n\u0026lt;k) return 0; ll t=(n-k)/x; ll cnt=t+1; ll res=fc(t)\u0026lt;\u0026lt;i; if(cnt%2)res^=k; return res; } void solve() { cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;i\u0026gt;\u0026gt;k; ll s=fc(l-1)^fc(r); ll tmp=fx(r,i,k)^fx(l-1,i,k); ll ans=s^tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf984/","summary":"Codeforces Round 984 (Div. 3) è¡¥é¢˜","title":"Codeforces Round 984 (Div. 3)"},{"content":"L. Recover Statistics ç›´æ¥æŒ‰è¦æ±‚è¾“å‡º 100 ä¸ªæ•°å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; cout\u0026lt;\u0026lt;100\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=50;i++){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=45;i++){ cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for(int i=1;i\u0026lt;=4;i++){ cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;c+1; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } J. Grand Prix of Ballance æŒ‰é¢˜æ„æ¨¡æ‹Ÿå³å¯\nèµ›æ—¶æ¦œæ­ªäº†ï¼Œåº”è¯¥ç›´æ¥ä¸Šæœºå†™çš„\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; struct Node{ int id,flag; ll val; bool operator\u0026lt;(const Node \u0026amp;t){ if(val==t.val)return id\u0026lt;t.id; return val\u0026gt;t.val; } }a[N]; int n,m,q,op,x,id,flag,cnt; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; flag=0; cnt=0; for(int i=1;i\u0026lt;=m;i++)a[i].id=i,a[i].val=0,a[i].flag=0; while(q--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x; if(x\u0026gt;n)continue; flag=x; cnt=0; } else if(op==2){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;x; if(a[id].flag==flag||x!=flag)continue; a[id].flag=flag; a[id].val+=(m-cnt); cnt++; } else{ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;x; if(a[id].flag==flag||x!=flag)continue; a[id].flag=flag; } } sort(a+1,a+1+m); for(int i=1;i\u0026lt;=m;i++){ cout\u0026lt;\u0026lt;a[i].id\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[i].val\u0026lt;\u0026lt;endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } A. Arrow a Row é¦–å…ˆå¯ä»¥ç¡®å®š No çš„æƒ…å†µï¼šç¬¬ä¸€ä¸ªä¸º -ï¼›åä¸‰ä¸ªä¸æ˜¯ \u0026gt;\u0026gt;\u0026gt;ï¼›æ²¡æœ‰ - å­˜åœ¨\næ¥ç€åˆ†æå¦‚ä½•æ„é€ åŸä¸²\næˆ‘ä»¬å¯ä»¥æ¯æ¬¡ç¡®å®š 1 ä¸ªä½ç½®\nåç¼€ç¡®å®šååŸºæœ¬ä¸ä¼šå†å˜åŠ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆè€ƒè™‘æ„é€ åç¼€ï¼Œå¯ä»¥å…ˆæ„é€ å‡ºåç¼€è¿ç»­çš„ \u0026gt; ç‰‡æ®µï¼Œå…¨éƒ¨ä» 1 å¼€å§‹ï¼Œé•¿åº¦é€æ¸ä» n é€’å‡\næ¥ç€æ„é€ å‰é¢çš„ç‰‡æ®µï¼Œå…ˆä¿è¯æ„é€ çš„ç‰‡æ®µä¸ä¼šå½±å“åç¼€ï¼Œå³é€‰å–çš„ç®­ä¸² - ä¸èƒ½å½±å“åˆ°åç¼€ï¼Œå³ç¡®å®šäº†å½“å‰æ„é€ çš„é•¿åº¦\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s; deque\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;q; void solve(){ cin\u0026gt;\u0026gt;s; int n=s.size(); q.clear(); s=\u0026#34; \u0026#34;+s; if(s.substr(n-2,3)!=\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026#34;||s[1]==\u0026#39;-\u0026#39;||s.find(\u0026#39;-\u0026#39;)==-1){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; return; } cout\u0026lt;\u0026lt;\u0026#34;Yes \u0026#34;; int cnt=0; for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;)cnt++; else break; } for(int i=n;i\u0026gt;n-cnt+3;i--){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;){ q.push_back({1,i}); } else break; } int r=n-cnt+3; for(int i=1;i\u0026lt;r-2;i++){ if(s[i]==\u0026#39;\u0026gt;\u0026#39;){ q.push_back({i,r-i+1}); } } cout\u0026lt;\u0026lt;q.size()\u0026lt;\u0026lt;endl; for(auto [x,y]:q){ cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G. Expanding Array èµ›æ—¶è¢«å¡å¤ªä¹…äº†ï¼Œä¸ç„¶çœŸæ„Ÿè§‰é“¶æœ‰æœ›\né˜Ÿå‹å·²ç»æ‰‹ç©å‡ºæœ€å¤š 8 ç§å¯èƒ½ï¼Œä½†å½“æ—¶æƒ³å¤æ‚äº†\nå®é™…ä¸Šç¡®å®åªæœ‰è¿™ä¹ˆå¤šå¯èƒ½\næŸä½ä¸Šæœ‰ 0,1 æ—¶ï¼ŒäºŒè€…éƒ½å¯ä»¥å–ï¼Œåªæœ‰ 1 æ—¶åªèƒ½è¿›è¡Œå¼‚æˆ–æ“ä½œï¼Œåªæœ‰ 0 æ—¶æ€ä¹ˆæ“ä½œéƒ½ä¸ä¼šäº§ç”Ÿå˜åŒ–\næ‰€ä»¥å¯ä»¥é€‰å– 011,101 ä¸¤ä¸ªæ•°ï¼Œçœ‹æ€æ ·æ“ä½œæ‰èƒ½å–å¾—æ‰€æœ‰çš„å¯èƒ½\nå‡è®¾äºŒè€…ä¸º x,y\né¦–å…ˆæ˜¯äºŒè€…æœ¬èº« x,y\næ¥ç€æ˜¯ x^y x|y x\u0026amp;y\nç„¶åæ˜¯ x|(x^y) y|(x^y)\næœ€åæ˜¯ (x^y)^(x^y) å³ä¸º 0\nä¾æ¬¡æ’å…¥ä¸€ä¸ª set ä¸­å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int n; set\u0026lt;int\u0026gt;s; int a[N]; void solve() { cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ s.insert(a[i]); s.insert(a[i+1]); s.insert(a[i]^a[i+1]); s.insert((a[i]^a[i+1])\u0026amp;a[i]); s.insert((a[i]^a[i+1])\u0026amp;a[i+1]); s.insert(a[i]|a[i+1]); s.insert(a[i]\u0026amp;a[i+1]); s.insert(0); } cout\u0026lt;\u0026lt;s.size()\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // freopen(\u0026#34;..//..//in_out//in.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;..//..//in_out//out.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } I. Good Partitions æ‰¾åŸæ•°ç»„ä¸­çš„ä¸ä¸‹é™çš„ç‰‡æ®µï¼Œå¯ä»¥å°†æ¯ä¸ªç‰‡æ®µçš„ç»ˆæ­¢ä½ç½®å‚¨å­˜èµ·æ¥ï¼Œæ­¤æ—¶çš„ç­”æ¡ˆå°±æ˜¯æ‰€æœ‰ç‰‡æ®µé•¿åº¦çš„ gcd çš„å› å­ä¸ªæ•°\nå¸¸è§çš„ç»´æŠ¤åŒºé—´ gcd æ˜¯ä½¿ç”¨çº¿æ®µæ ‘ï¼Œç»Ÿè®¡å› å­ä¸ªæ•°é‡‡ç”¨åŸƒæ°ç­›å³å¯\nä¿®æ”¹æ—¶åŒæ­¥ update å³å¯ä½¿ tr[1] ä¸­å§‹ç»ˆå­˜å‚¨ä¸ºæ‰€æœ‰ç‰‡æ®µçš„ gcd\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int tr[N\u0026lt;\u0026lt;2]; int n,q,a[N],x,v,cf[N],phi[N]; void init(int n){ for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ phi[j*i]++; } } } void update(int now){ tr[now]=__gcd(tr[ls],tr[rs]); } void build(int now,int l,int r){ if(l==r){ if(cf[l]\u0026lt;0){ tr[now]=l; } else tr[now]=0; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void modify(int now,int l,int r,int val,int pos){ if(l==r){ if(val\u0026gt;=0){ tr[now]=0; } else tr[now]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid){ modify(ls,l,mid,val,pos); } else modify(rs,mid+1,r,val,pos); update(now); } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++)cf[i]=a[i+1]-a[i]; if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; while(q--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } return; } build(1,1,n-1); int ans=abs(tr[1]); if(n==1||ans==0)cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;phi[ans]\u0026lt;\u0026lt;endl; while(q--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; a[x]=v; if(x\u0026gt;1)modify(1,1,n-1,a[x]-a[x-1],x-1); if(x\u0026lt;n)modify(1,1,n-1,a[x+1]-a[x],x); if(n==1){ cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; continue; } ans=abs(tr[1]); if(!ans){ cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;phi[ans]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(N); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Athlete Welcome Ceremony æ‰¾å‡ºæ‰€æœ‰çš„å¯è¡Œæ–¹æ¡ˆï¼Œå†åˆ©ç”¨å‰ç¼€å’Œæ±‚å‡ºå½“å‰æ‰€ç»™çš„é€‰æ‹©çš„æ€»å’Œå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 3e2 + 5, mod = 1e9 + 7; int n, q, x, y, z; string s; ll dp[2][N][N][4], f[N][N]; map\u0026lt;char, int\u0026gt; tr; int cnt = 0; void init() { if (s[1] == \u0026#39;?\u0026#39;) { dp[1 % 2][1][0][1] = 1; dp[1 % 2][0][1][2] = 1; dp[1 % 2][0][0][3] = 1; cnt++; } else { dp[1 % 2][0][0][tr[s[1]]] = 1; } for (int i = 2; i \u0026lt;= n; i++) { memset(dp[i % 2], 0, sizeof(dp[i % 2])); // æ¸…é›¶å½“å‰ dp å±‚ if (s[i] == \u0026#39;?\u0026#39;) cnt++; for (int j = 0; j \u0026lt;= i; j++) { for (int k = 0; j + k \u0026lt;= i; k++) { if (s[i] == \u0026#39;?\u0026#39;) { // å¯¹äº \u0026#39;?\u0026#39;, æ›´æ–°çŠ¶æ€æ—¶è€ƒè™‘æ‰€æœ‰å­—ç¬¦ for (int l = 1; l \u0026lt;= 3; l++) { int x, y; if (l == 1) x = 2, y = 3; else if (l == 2) x = 1, y = 3; else x = 1, y = 2; if (j - (l == 1) \u0026lt; 0 || k - (l == 2) \u0026lt; 0) continue; dp[i % 2][j][k][l] = (dp[i % 2][j][k][l] + dp[(i + 1) % 2][j - (l == 1)][k - (l == 2)][x] + dp[(i + 1) % 2][j - (l == 1)][k - (l == 2)][y]) % mod; } } else { int x = tr[s[i]]; for (int l = 1; l \u0026lt;= 3; l++) { if (l != x) { dp[i % 2][j][k][x] = (dp[i % 2][j][k][x] + dp[(i + 1) % 2][j][k][l]) % mod; } } } } } } // æ„å»º f æ•°ç»„ï¼ˆåˆæ³•ä¸‰ç»´å‰ç¼€å’Œï¼‰ for (int i = 0; i \u0026lt;= cnt; i++) { for (int j = 0; j + i \u0026lt;= cnt; j++) { f[i][j] = 0; for (int k = 1; k \u0026lt;= 3; k++) { f[i][j] = (f[i][j] + dp[n % 2][i][j][k]) % mod; } } // è®¡ç®—å‰ç¼€å’Œ for (int j = 1; i + j \u0026lt;= cnt; j++) { f[i][j] = (f[i][j] + f[i][j - 1]) % mod; } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; s; s = \u0026#34; \u0026#34; + s; // å­—ç¬¦ä¸²ä¸‹æ ‡ä»1å¼€å§‹ init(); while (q--) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; ll ans = 0; // å¤„ç†æŸ¥è¯¢ï¼Œè®¡ç®—åˆæ³•çš„ä¸‰ç»´å‰ç¼€å’Œ for (int i = 0; i \u0026lt;= x; i++) { int j = cnt - z - i; if (i \u0026gt; cnt) break; if (j \u0026gt; y) continue; j = max(0, j); j = min(j, cnt - i); ans = (ans + f[i][min(y, cnt - i)] - (j \u0026gt; 0 ? f[i][j - 1] : 0) + mod) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; tr[\u0026#39;a\u0026#39;] = 1, tr[\u0026#39;b\u0026#39;] = 2, tr[\u0026#39;c\u0026#39;] = 3; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/icpc2024chengdu/","summary":"ICPC åŒºåŸŸèµ›é¦–æˆ˜ï¼Œå‰æ’é“œï¼Œè¿˜å¯ä»¥","title":"ICPC2024chengdu"},{"content":"ç‰›é­”çš„ vs code åˆšå¼€åœºå°±ç‚¸äº†ï¼Œdebug çº¯é è¾“å‡ºåœ¨è°ƒ\nL - é™„åŠ é¢˜1 è¯»é¢˜å¯å‘ç°ï¼Œåªæœ‰ç›¸é‚»çš„ä¼šæœ‰å¹²æ‰°ï¼Œé‚£ä¹ˆé™¤äº†ç¬¬ä¸€ä¸ªæ˜¯ k ç§å¯èƒ½ï¼Œå…¶ä»–çš„éƒ½æ˜¯ (k-1) ç§é€‰æ‹©\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e5+7, mod=1e9+7; int ans=0,n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; ans=k; for(int i=2;i\u0026lt;=n;i++){ ans*=(k-1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - SYease å¼€å§‹æƒ³ç”¨ dp æš´åŠ›å†™ï¼Œå–œæè¶…æ—¶ï¼Œç„¶åæš´åŠ›é€‰æœ€ä½³é€‰é¡¹ï¼Œå†ç”¨å‰©ä½™é’±æ›¿æ¢ä¸€éƒ¨åˆ†ç‰‡æ®µï¼Œä¹Ÿé”™ï¼Œä½†æ˜¯è¾¾åˆ°äº† 28/30 è¯¯å¯¼äº†å¥½ä¹…ï¼Œä»¥ä¸ºè¿™ä¸ªæ˜¯æ­£è§£\nå®é™…ä¸Šå°±æ˜¯å…ˆç”¨æœ€å°ä»·å€¼ç¡®å®šé•¿åº¦ï¼Œå†ç”¨å‰©ä½™çš„é’±çœ‹ä» 9 åˆ° 0 èƒ½æ¢å‡ ä¸ªæ¯”æœ€å°ä»·å€¼é€‰é¡¹å¤§çš„\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e6+7, mod=1e9+7; int n; void solve(){ cin\u0026gt;\u0026gt;n; int mn=10000000,pos=-1; for(int i=1;i\u0026lt;=9;i++){ cin\u0026gt;\u0026gt;c[i].x; if(mn\u0026gt;=c[i].x){ mn=c[i].x; pos=i; } c[i].id=i; } int len=n/mn; int lft=n-len*mn; if(!len){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return; } int cnt[10]={0}; memset(cnt,0,sizeof(cnt)); cnt[pos]=len; for(int i=9;i\u0026gt;=1;i--){ if(i\u0026lt;=pos)break; int tmp=c[i].x-mn; if(tmp\u0026lt;=lft){ int t=lft/tmp; if(t\u0026gt;cnt[pos])break; cnt[i]=t; cnt[pos]-=t; lft-=t*tmp; } } for(int i=9;i\u0026gt;0;i--){ for(int j=1;j\u0026lt;=cnt[i];j++)cout\u0026lt;\u0026lt;i; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G - dyfhpu è¦ä¿è¯æ“ä½œåæ•°æœ€å°ï¼Œä¸”ä¸èƒ½æœ‰å…ˆå¯¼é›¶ï¼Œå…¶å®å°±æ˜¯åœ¨ k+1 å‰æ‰¾æœ€å°çš„é¦–ä½å³å¯ï¼Œå†åœ¨åé¢å¼€ä¸€ä¸ªå•è°ƒæ ˆå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; string s; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;k; n=s.size(); int st=1e9; for(int i=0;i\u0026lt;=k;i++){ if(s[i]-\u0026#39;0\u0026#39;\u0026gt;0){ st=min(st,s[i]-\u0026#39;0\u0026#39;); } } int pos=-1; for(int i=0;i\u0026lt;n;i++){ if(s[i]-\u0026#39;0\u0026#39;==st){ pos=i; break; } else{ k--; } } deque\u0026lt;int\u0026gt;q; q.push_back(st); for(int i=pos+1;i\u0026lt;n;i++){ int t=s[i]-\u0026#39;0\u0026#39;; while(q.size()\u0026gt;1\u0026amp;\u0026amp;t\u0026lt;q.back()\u0026amp;\u0026amp;k){ k--; q.pop_back(); } q.push_back(t); } while(k){ q.pop_back(); k--; } for(int x:q)cout\u0026lt;\u0026lt;x; cout\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E - LAING2122 æ­£è§£æ¯”é¢˜çŸ­ç³»åˆ—\né¦–å…ˆæ³¨æ„åˆ° w \\lep 10^6 åŒæ—¶å¯ä»¥é€‰ 300 ä¸ªæ•°ï¼Œæœ€å¤šç”¨ 3 ä¸ªæ•°æ¥ç»„åˆ\nä¸€ä¸ªå…­ä½æ•°ï¼Œå¹³å‡åˆ†æˆä¸‰ä»½åï¼Œæ¯ä»½éƒ½æ˜¯ä¸€ä¸ªä¸¤ä½æ•°ï¼Œé‚£ä¹ˆåªè¦æŠŠä» 1 ~ 100 çš„ i i100 i10000 éƒ½åŠ è¿›å»å°±è¡Œäº†\nè¿™æ ·å°±èƒ½ç»„åˆå‡ºæ‰€æœ‰çš„å…­ä½æ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int w; vector\u0026lt;int\u0026gt;ans; void solve(){ cin\u0026gt;\u0026gt;w; cout\u0026lt;\u0026lt;300\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=100;i++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i*100\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i*10000\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D - haowen521 æ‰¾ç»™å‡ºçš„æ•°ç»„ä¸­çš„é€’å¢ç‰‡æ®µæœ‰å‡ ä¸ªï¼Œæ¯ä¸ªç‰‡æ®µéƒ½å¯ä»¥æ¥åˆ°ä¸Šä¸€å±‚çš„ä¸€ä¸ªèŠ‚ç‚¹ä¸Šï¼Œè¿™æ ·æ¥å°±æ˜¯æœ€ä½å±‚æ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; int a[N] = {0}; vector\u0026lt;int\u0026gt;seg; void solve(){ seg.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int k=1; for(int i=3;i\u0026lt;=n;i++){ if(a[i]\u0026lt;a[i-1]){ seg.push_back(k); k=1; } else{ k++; } } seg.push_back(k); int now=1; int tmp=1,nxt=0; for(auto x:seg){ if(!tmp){ tmp=nxt; now++; nxt=0; } tmp--; nxt+=x; } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } K - XingRin èµ›æ—¶å†™äº†ä¸ª O(n^2 \\log n) çš„ï¼Œä½†æ˜¯é‡åˆ°ç›¸åŒçš„æ•°æ—¶ä¼šå˜ O(n^3 \\log n)\nå¯ä»¥è®°å½•æ¯ä¸ªä½ç½®å‰æŸä¸ªæ•°çš„å‡ºç°æ¬¡æ•°\nè¿™æ ·å°±å¯ä»¥æšä¸¾ j,k çš„ä½ç½®ï¼Œç„¶åæ‰¾ j å‰æ–¹ a[k] å‡ºç°äº†å¤šå°‘å’Œ k åæ–¹ a[j] å‡ºç°çš„æ¬¡æ•°\nO(N^2) å³å¯é€šè¿‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e3+7, mod=1e9+7; int n; int s[N][N],a[N]; ll ans=0; void solve(){ ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; for(int j=1;j\u0026lt;=n;j++){ s[i][j]=s[i-1][j]; } s[i][a[i]]++; } for(int i=2;i\u0026lt;=n;i++){ for(int j=i+1;j\u0026lt;n;j++){ ans+=(s[i-1][a[j]])*(s[n][a[i]]-s[j][a[i]]); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } M - é™„åŠ é¢˜2 å¾ˆçœ¼ç†Ÿï¼Œä¹‹å‰åº”è¯¥å†™è¿‡è¿™ç§çš„æ¥ç€ï¼Œè¦åŠ å¼ºè¡¥é¢˜\næ³¨æ„åˆ° k\u0026lt;20 é‚£æˆ‘ä»¬åªéœ€è¦å¯¹æ¯ä¸ªä½ç½®å¼€ä¸€ä¸ª set æœ€å¤šå­˜ 20 ä¸ªå…ƒç´ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,q,a[N]; vector\u0026lt;int\u0026gt;edge[N]; multiset\u0026lt;int\u0026gt;s[N]; void dfs(int now,int fa){ for(auto x:edge[now]){ if(x==fa)continue; s[now].insert(a[x]); if(s[now].size()\u0026gt;20)s[now].erase(s[now].begin()); dfs(x,now); } if (fa != 0) { for(auto x:s[now]){ s[fa].insert(x); if(s[fa].size()\u0026gt;20)s[fa].erase(s[fa].begin()); } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); for(int i=1;i\u0026lt;=n;i++){ s[i].insert(a[i]); } while(q--){ int v,k; cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;k; if (k \u0026gt; s[v].size()) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { auto ans = s[v].rbegin(); advance(ans, k-1); cout \u0026lt;\u0026lt; *ans \u0026lt;\u0026lt; endl; } } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H - guohaonan æ˜“å‘ç°å¯ä»¥å°†ä¸¤ä¸ªæ•°ç»„æ‹¼æ¥èµ·æ¥ï¼Œa åœ¨å‰ï¼Œb åœ¨åï¼Œä¿è¯æ•´ä¸ªæ•°ç»„æ˜¯ä¸é™çš„ï¼Œé‚£ä¹ˆå°±æ˜¯æ±‚ n ç§æ•°æ’åˆ—æˆå•è°ƒä¸é™çš„æ–¹æ¡ˆæ•°ï¼Œç”¨ dp è·‘å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m; ll f[25][N],sum[25][N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)f[1][i]=1,sum[1][i]=i; ll ans=0; m*=2; for(int i=2;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ f[i][j]=sum[i-1][j]; sum[i][j]=((sum[i][j-1]+f[i][j])%mod+mod)%mod; } } for(int i=1;i\u0026lt;=n;i++)ans=((ans+f[m][i])%mod+mod)%mod; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/hpuacm1103/","summary":"åŒºåŸŸèµ›é€‰æ‹”èµ›è¡¥é¢˜","title":"Hpuacm1103"},{"content":"ç‰›é­”çš„æ¸£æœº ChromeBook\nA. Circuit æ¯ç›ç¯å¯¹åº”çš„å¼€å…³æœ‰ä¸€ä¸ªä¸º on æ—¶æ˜¯äº®çš„ï¼Œå…¶ä»–æ—¶å€™éƒ½ä¸ºç†„ç­\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int off,on; void solve(){ cin\u0026gt;\u0026gt;n; on=off=0; for(int i=1;i\u0026lt;=2*n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x==1)on++; else off++; } int ans1=0,ans2=0; if(on\u0026lt;=n)ans2=on; else{ ans2=n-(on-n); } ans1=n-on/2-off/2; cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Medians å¼€å§‹é¢˜æ²¡çœ‹å®Œï¼Œåˆ†çš„åŒºé—´é•¿åº¦ä¹Ÿå¿…é¡»å…¨ä¸ºå¥‡æ•°ï¼Œèƒ½åˆ†çš„éƒ½åˆ†æˆä¸‰ä¸ªå³å¯ï¼Œå†è€ƒè™‘å¦‚æœå·¦å³çš„ä¸ªæ•°ä¸ºå¶æ•°åº”è¯¥å¾€å“ªä¸ªåŒºé—´åŠ ä¸€å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(n==1\u0026amp;\u0026amp;k==1){ cout\u0026lt;\u0026lt;\u0026#34;1\\n1\\n\u0026#34;; return; } if(k==1||k==n){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl; int l=k-1,r=n-k,ans=k,ans2=k+1; if(l%2==0)ans--; if(r%2==0)ans2++; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Trinity å¼€å§‹æš´åŠ›ä¸¤ç«¯ï¼Œæ˜¾ç„¶ä¸å…¨é¢\nåº”è¯¥è€ƒè™‘æ¯ä¸ªä½ç½®ä½œä¸ºä¸­å€¼çš„å¯èƒ½ï¼Œå†å¯¹è¿™ä¸ªå€¼è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾å·¦å³æœ‰å¤šå°‘ä¸ªéœ€è¦æ”¹çš„å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=2e5+8, mod=1e9+7; int n; int a[N]; int bs1(int x,int y){ int l=1,r=n,ans=0; if(x+y\u0026gt;a[n])return n+1; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(x+y\u0026lt;=a[mid])r=mid-1,ans=mid; else l=mid+1; } return ans; } int bs2(int x){ int l=1,r=n,ans=0; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(a[mid]+a[mid+1]\u0026lt;=x)l=mid+1,ans=mid; else r=mid-1; } return ans; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); int ans=1e9; a[0]=a[1]; a[n+1]=a[n]; for(int i=1;i\u0026lt;=n;i++){ int l=bs1(a[i],a[i-1]); int r=bs2(a[l-1]); r=min(i-1,r); l=n-l+1; ans=min(ans,l+r); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Genokraken æ³¨æ„åˆ°ï¼Œåˆ è¾¹ä¹‹åçš„æ£®æ—éƒ½æ˜¯é“¾ï¼Œä¸”è¿™æ¡é“¾çš„æ ¹èŠ‚ç‚¹ä¸èƒ½æ”¹å˜\nåŒæ—¶ï¼Œ$p_i$ æ˜¯å•è°ƒé€’å¢çš„\nå¯ä»¥å‘ç°ï¼Œå¼€ä¸€ä¸ªé˜Ÿåˆ—ï¼Œè®°å½•å½“å‰çš„å¶èŠ‚ç‚¹ï¼Œå¦‚æœæœ€å°çš„å¶èŠ‚ç‚¹å’Œ $i$ çš„è¯¢é—®æ˜¯ $0$ï¼Œé‚£ä¹ˆå°† $i$ æ¥åˆ°è¿™ä¸ªå¶èŠ‚ç‚¹ä¸‹å³å¯\nå¦‚æœè¿™ä¸ªè¯¢é—®ä¸º $1$ï¼Œé‚£ä¹ˆåˆ æ‰æœ€å°çš„è¿™ä¸ªå¶èŠ‚ç‚¹ï¼Œå‘åç»§ç»­è¯¢é—®ï¼Œç›´åˆ°æœ‰è¯¢é—®ä¸º $0$ çš„ï¼Œå°†å…¶æ¥ä¸Šå³å¯\nå®é™…ä¸Šåªå¯¹æ¯ä¸ªèŠ‚ç‚¹è®¿é—®äº†ä¸€æ¬¡ $O(n)$ï¼ŒåŒæ—¶è¯¢é—®é‡åªæœ‰ $O(n)$ æ¬¡ï¼Œå› ä¸ºæˆ‘ä»¬çš„è¯¢é—®æ˜¯é é˜Ÿåˆ—ä¸­çš„å…ƒç´ æ¥è¿›è¡Œçš„ï¼Œæ¯æ¬¡è¯¢é—®ä¼šåˆ æ‰ä¸€ä¸ªï¼Œå®é™…ä¸Šæœ€å¤šæ¯ä¸ªèŠ‚ç‚¹è¢«è¯¢é—®äº†ä¸€æ¬¡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 // #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int ans[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ ans[i]=0; } deque\u0026lt;int\u0026gt;q; q.push_back(1); for(int i=2;i\u0026lt;n;i++){ printf(\u0026#34;? %d %d\\n\u0026#34;,q.front(),i); int x; cin\u0026gt;\u0026gt;x; if(x\u0026amp;\u0026amp;!ans[i-1]){ ans[i]=0; q.push_back(i); continue; } while(x){ q.pop_front(); printf(\u0026#34;? %d %d\\n\u0026#34;,q.front(),i); cin\u0026gt;\u0026gt;x; } ans[i]=q.front(); q.pop_front(); q.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;; for(int i=1;i\u0026lt;n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; fflush(stdout); } int main(){ // ios::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf983/","summary":"Codeforces Round 983 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 983 (Div. 2)"},{"content":"A. Strong Password åªéœ€è¦åœ¨ç›¸é‚»å­—æ¯ç›¸åŒçš„ä½ç½®æ’å…¥ä¸€ä¸ªä¸åŒçš„å³å¯ï¼Œå¦‚æœæ²¡æœ‰è¿™ç§ä½ç½®ï¼Œå°±åœ¨å­—ç¬¦ä¸²æœ«å°¾æ’å…¥ä¸€ä¸ªä¸å½“å‰æœ«å°¾ä¸åŒçš„å­—ç¬¦å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve() { string s, ans; cin \u0026gt;\u0026gt; s; int pos = -1; for (int i = 1; i \u0026lt; s.size(); i++) { if (s[i] == s[i - 1]) { pos = i; break; } } if (pos == -1) { ans = s + (s[s.size() - 1] == \u0026#39;a\u0026#39; ? \u0026#39;b\u0026#39; : \u0026#39;a\u0026#39;); } else { if (s[pos] == \u0026#39;a\u0026#39;) ans = s.substr(0, pos) + \u0026#34;b\u0026#34; + s.substr(pos, s.size() - pos); else ans = s.substr(0, pos) + \u0026#34;a\u0026#34; + s.substr(pos, s.size() - pos); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } B. Make Three Regions åˆå§‹æ—¶åªä¼šæœ‰ä¸€ä¸ªè”é€šå—ï¼Œä¸”åªæœ‰ä¸¤è¡Œï¼Œé‚£ä¹ˆè¦æŠŠå®ƒåˆ†ä¸º 3 å—ï¼Œåªèƒ½æ‰¾\nè¿™ç§å½¢çŠ¶çš„åŒºåŸŸ\nåªéœ€è¦æšä¸¾æ‰¾åˆ°å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; string s; int a[3][N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=2;i++){ cin\u0026gt;\u0026gt;s; for(int j=0;j\u0026lt;n;j++){ a[i][j+1]=(s[j]==\u0026#39;.\u0026#39;?1:-1); } } int ans=0; for(int i=2;i\u0026lt;n;i++){ if(a[1][i-1]==-1\u0026amp;\u0026amp;a[1][i]==1\u0026amp;\u0026amp;a[1][i+1]==-1\u0026amp;\u0026amp;a[2][i-1]==1\u0026amp;\u0026amp;a[2][i]==1\u0026amp;\u0026amp;a[2][i+1]==1)ans++; else if(a[2][i-1]==-1\u0026amp;\u0026amp;a[2][i]==1\u0026amp;\u0026amp;a[2][i+1]==-1\u0026amp;\u0026amp;a[1][i-1]==1\u0026amp;\u0026amp;a[1][i]==1\u0026amp;\u0026amp;a[1][i+1]==1)ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Even Positions å…ˆå¡«å……å³æ‹¬å·ï¼ŒæŠŠå·²æœ‰çš„å·¦æ‹¬å·å…¨å¯¹åº”ä¸Šï¼Œå†å…¨éƒ¨å¡«å……å·¦æ‹¬å·å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; int cnt=0,ans=0; for(int i=1;i\u0026lt;n;i+=2){ if(s[i]==\u0026#39;(\u0026#39;)cnt++; } for(int i=0;i\u0026lt;n;i+=2){ if(i\u0026amp;\u0026amp;s[i-1]==\u0026#39;(\u0026#39;\u0026amp;\u0026amp;cnt)s[i]=\u0026#39;)\u0026#39;; else s[i]=\u0026#39;(\u0026#39;; } // cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; deque\u0026lt;int\u0026gt;q; for(int i=0;i\u0026lt;n;i++){ if(s[i]==\u0026#39;(\u0026#39;)q.push_back(i); else ans+=(i-q.front()),q.pop_front(); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Maximize the Root è¦ä½¿æ ¹èŠ‚ç‚¹æœ€å¤§ï¼Œå°±è¦ä½¿å­èŠ‚ç‚¹éƒ½è¶‹è¿‘ä¸€ä¸ªå€¼ï¼Œä»è€Œä½¿æ ¹èŠ‚ç‚¹åŠ  $1$ çš„æ“ä½œæœ€å¤š\nç”¨ $dfs$ å‘ä¸‹æŸ¥æ‰¾æ¯ä¸ªå­æ ‘ä¸­çš„æœ€å°å€¼ $mn$ï¼Œå½“å‰æ ¹å¦‚æœæ¯” $mn$ å°ï¼Œé‚£å°±éœ€è¦å…ˆå¯¹è¿™ä¸ªæ ¹è¿›è¡Œå‡ æ¬¡æ“ä½œï¼Œå¹³è¡¡ $mn$ ä¹‹åå†å‘ä¸Šï¼Œå¦‚æœå½“å‰æ ¹å¤§äº $mn$ï¼Œå°†å…¶è§†ä½œ $mn$ å³å¯\næœ€åç­”æ¡ˆå³ä¸º $a[1] + mn$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long vector\u0026lt;int\u0026gt;g[300001]; vector\u0026lt;int\u0026gt;a(300001); void dfs(int x){ int mn=1e16; for(auto u:g[x]){ dfs(u); mn=min(mn,a[u]); } if(mn==1e16)return; if(x==1){a[1]+=mn;return;} if(a[x]\u0026lt;mn)a[x]=(a[x]+mn)/2; else a[x]=mn; } void solve(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; g[i].clear(); } for(int i=2;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; g[x].push_back(i); } dfs(1); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;endl; } signed main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Level Up 200+ æµ‹è¯•ç‚¹ï¼Œå“ˆäºº\næ²¡æœ‰ä¿®æ”¹çš„æ“ä½œï¼Œæ‰€ä»¥å¯ä»¥æƒ³åˆ°é¢„å¤„ç†\nå¯¹äºæ¯ä¸€åªæ€ªå…½ï¼Œåœ¨ $k\u0026gt;x$ æ—¶ï¼Œä»–ä¸€å®šä¸é€ƒè·‘ï¼Œè¿™ä¸ª $x$ å³ä¸ºå¯¹åº”çš„é˜€å€¼\nåœ¨æ±‚é˜€å€¼çš„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥é‡‡ç”¨äºŒåˆ†ç­”æ¡ˆæ¥æŸ¥è¯¢å…ˆå‰æœ‰å¤šå°‘ä¸ªä¸‹æ ‡æ»¡è¶³æ¡ä»¶\nå³ç”¨æƒå€¼çº¿æ®µæ ‘ï¼Œçœ‹å½“å‰ $k$ å‡ºç°äº†å¤šå°‘æ¬¡\næ¯æ¬¡è®¡ç®—å¾—åˆ°ä¸€ä¸ªé˜€å€¼ $x$ åï¼Œå°† $x-\u0026gt;n$ æ•´ä½“åŠ ä¸€\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int tr[N\u0026lt;\u0026lt;2]; int a[N],n,k,id,q,b[N]; void build(int now,int l,int r){ if(l==r){ tr[now]=0; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); } void pushdown(int now){ if(tr[now]){ tr[ls]+=tr[now]; tr[rs]+=tr[now]; tr[now]=0; } } void change(int now,int l,int r,int s,int t,int val){ if(s\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=t){ tr[now]+=val; return; } pushdown(now); int mid=(l+r)\u0026gt;\u0026gt;1; if(s\u0026lt;=mid)change(ls,l,mid,s,t,val); if(t\u0026gt;mid)change(rs,mid+1,r,s,t,val); } int query(int now,int l,int r,int id){ if(l==r)return tr[now]; pushdown(now); int mid=(l+r)\u0026gt;\u0026gt;1; if(id\u0026lt;=mid)return query(ls,l,mid,id); else return query(rs,mid+1,r,id); } void solve(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } build(1, 1, n); change(1,1,n,1,n,1); for(int i=2;i\u0026lt;=n;i++){ int l=1,r=n,ans=0; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(query(1,1,n,mid)/mid+1\u0026gt;a[i])l=mid+1; else ans=mid,r=mid-1; } b[i]=ans; change(1,1,n,ans,n,1); } while (q--) { cin \u0026gt;\u0026gt; id \u0026gt;\u0026gt; k; if(b[id]\u0026lt;=k)cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe168/","summary":"Educational Codeforces Round 168 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 168 (Rated for Div. 2)"},{"content":"A. Closest Point å¯ä»¥å‘ç°åªæœ‰ä¸¤ä¸ªç‚¹ä¸”äºŒè€…ä¸ç›¸é‚»çš„æ—¶å€™æ‰æœ‰ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+1+n); if(n\u0026gt;2){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else{ if(a[1]+1==a[2])cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Game with Doors ç›¸äº¤ç‰‡æ®µçš„é—¨ä¸€å®šéƒ½è¦å…³ä¸Šï¼Œå¦‚æœä¸¤ç«¯ä¸é‡åˆå°±å¤šå…³ä¸€æ‰‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x) \u0026amp; (-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int l, r, L, R; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int ans = min(r, R) - max(l, L); if (ans \u0026lt; 0) { ans = 1; } else { ans += (l != L); ans += (r != R); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Splitting Items éƒ½å–æœ€ä¼˜æ‰‹æ®µï¼Œé‚£ä¹ˆéƒ½æ˜¯æ‹¿å½“å‰æœ€å¤§å€¼çš„ç‰©å“ï¼Œé™åºæ’åºåï¼ŒBob åªèƒ½åˆ©ç”¨å½“å‰çš„ k å»å¼¥è¡¥ä¸ Alice ä¸Šä¸€æ¬¡æ‹¿çš„ç‰©å“çš„å·®è·ï¼Œå³æœ€å¤§åªèƒ½å’Œ Alice æ‹¿çš„ç‰©å“ç›¸åŒ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,k; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } sort(a+1,a+1+n,greater\u0026lt;int\u0026gt;()); ll ali,bob; ali=bob=0; for(int i=1;i\u0026lt;=n;i+=2){ ali+=a[i]; if(i+1\u0026lt;=n){ bob+=a[i+1]; int de=a[i]-a[i+1]; if(k\u0026gt;=de)bob+=de,k-=de; else bob+=k,k=0; } } cout\u0026lt;\u0026lt;ali-bob\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Colored Portals å¦‚æœä¸¤ä¸ªåŸå¸‚æœ‰äº¤ç‚¹ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯äºŒè€…çš„è·ç¦»ä¹‹å·®\nå¦‚æœäºŒè€…æ²¡æœ‰äº¤ç‚¹ï¼Œå°±è¦æ‰¾ç‚¹æœ€è¿‘çš„ä¼ é€åŸå¸‚\nä¾‹å¦‚ç”¨ $1, 2, 3, 4$ æ¥ä»£è¡¨é¢œè‰²ï¼Œä¸€åŸå¸‚ä½äº $1, 2$ å¦ä¸€åŸå¸‚ä½äº $3, 4$ï¼Œé‚£ä¹ˆäºŒè€…åªéœ€è¦ä¼ é€åˆ°å¦ä¸€ä¸ªä¸å’Œæœ¬èº«ç›¸åŒçš„åŸå¸‚å³å¯ï¼Œå¦‚ $1$ ä¼ é€åˆ° $1, 3$ æ­¤æ—¶å³å¯å®Œæˆä»»åŠ¡ï¼Œåªéœ€è¦è€ƒè™‘ä»£ä»·æœ€å°çš„ä¼ é€æ–¹æ¡ˆå³å¯\nå¼€ä¸¤ä¸ªæ•°ç»„ $pre,suf$ æ¥ä»£è¡¨æŸä¸ªåŸå¸‚å‘å‰å’Œå‘åä¼ é€çš„æœ€å°ä»£ä»·ï¼Œè®¡ç®—ä»£ä»·æ—¶åªéœ€è¦ç»“åˆè€ƒè™‘å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) const int N=2e5+7, mod=1e9+7; const int inf=1e9; int n,q,l,r; int pre[N],suf[N]; string s[N]; map\u0026lt;string,int\u0026gt;mp; vector\u0026lt;string\u0026gt;v; string rs(string s){ if(s==\u0026#34;BG\u0026#34;)return \u0026#34;RY\u0026#34;; if(s==\u0026#34;BR\u0026#34;)return \u0026#34;GY\u0026#34;; if(s==\u0026#34;GR\u0026#34;)return \u0026#34;BY\u0026#34;; if(s==\u0026#34;RY\u0026#34;)return \u0026#34;BG\u0026#34;; if(s==\u0026#34;GY\u0026#34;)return \u0026#34;BR\u0026#34;; if(s==\u0026#34;BY\u0026#34;)return \u0026#34;GR\u0026#34;; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; pre[i]=0; suf[i]=1e9; } mp.clear(); for(int i=1;i\u0026lt;=n;i++){ for(auto x:v){ if(x!=rs(s[i])\u0026amp;\u0026amp;s[i]!=x)pre[i]=max(pre[i],mp[x]); } mp[s[i]]=i; } mp.clear(); for(int i=n;i\u0026gt;0;i--){ for(auto x:v){ if(x!=rs(s[i])\u0026amp;\u0026amp;s[i]!=x)suf[i]=min(suf[i],(mp[x]==0?inf:mp[x])); } mp[s[i]]=i; } while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if(l\u0026gt;r)swap(l,r); if(rs(s[l])!=s[r])cout\u0026lt;\u0026lt;r-l\u0026lt;\u0026lt;endl; else{ int ans=1e9; if(pre[l]!=0)ans=min(r-pre[l]+l-pre[l],ans); if(suf[r]!=1e9)ans=min(suf[r]-r+suf[r]-l,ans); if(pre[r]!=0){ if(pre[r]\u0026gt;=l)ans=min(r-l,ans); if(pre[r]\u0026lt;=l)ans=min(r-pre[r]+l-pre[r],ans); } if(suf[l]!=1e9){ if(suf[l]\u0026lt;=r)ans=min(r-l,ans); if(suf[l]\u0026gt;=r)ans=min(suf[l]-r+suf[l]-l,ans); } if(ans==1e9)cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); v.push_back(\u0026#34;BG\u0026#34;); v.push_back(\u0026#34;BR\u0026#34;); v.push_back(\u0026#34;GR\u0026#34;); v.push_back(\u0026#34;GY\u0026#34;); v.push_back(\u0026#34;RY\u0026#34;); v.push_back(\u0026#34;BY\u0026#34;); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Not a Nim Problem ä¸€çœ¼é¡¶é’ˆï¼Œé‰´å®šä¸ºæ‰“è¡¨ï¼Œæ‰“è¡¨åå‘ç°å¶æ•°éƒ½ä¸º $0$ï¼ŒåŒæ—¶è´¨æ•°æ˜¯ä¾æ¬¡é€’å¢ï¼Œå¥‡æ•°éè´¨çš„ $sg$ å€¼æ˜¯å®ƒæœ€å°çš„è´¨æ•°å› å­çš„ $sg$ å€¼\nåªéœ€è¦é¢„å¤„ç†æ‰€æœ‰çš„ $sg$ å€¼å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e7+7, mod=1e9+7; bool prime[N]; int sg[N],mn[N]; int n,x; void init(int n){ memset(prime, false, sizeof(prime)); memset(mn, 0, sizeof(mn)); prime[0] = prime[1] = true; for(int i = 2; i \u0026lt;= n; i++){ if(!prime[i]){ for(int j = i * 2; j \u0026lt;= n; j += i){ mn[j]=(mn[j]==0?i:mn[j]); prime[j] = true; } } } } void init2(int n){ int now=2; sg[0]=0,sg[1]=1,sg[2]=0; for(int i=3;i\u0026lt;=n;i++){ if(i\u0026amp;1){ if(!prime[i])sg[i]=now++; else{ sg[i]=sg[mn[i]]; } } else sg[i]=0; } } void solve(){ cin\u0026gt;\u0026gt;n; int ans=0; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=sg[x]; } if(!ans)cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); init(N); init2(N); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe169/","summary":"Educational Codeforces Round 169 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 169 (Rated for Div. 2)"},{"content":"A. Perpendicular Segments ä¸¤æ¡çº¿å–è¾¹é•¿ä¸º $min(x,y)$ çš„æ­£æ–¹å½¢çš„å¯¹è§’çº¿å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int x,y,k; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; x=min(x,y); printf(\u0026#34;0 0 %d %d\\n\u0026#34;,x,x); printf(\u0026#34;%d 0 0 %d\\n\u0026#34;,x,x); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Black Cells æ˜“å‘ç°ï¼Œä¸ªæ•°ä¸ºå¶æ•°æ—¶ï¼Œç­”æ¡ˆå³ä¸ºç›¸é‚»ä¸¤ä¸ªå·®çš„æœ€å¤§å€¼\nä¸ªæ•°ä¸ºå¥‡æ•°æ—¶ï¼Œéœ€è¦å€Ÿç”¨ä¸€ä¸ªæ ¼å­ï¼Œå¯ä»¥åœ¨æ¯ä¸ªå¥‡æ•°ä½åæ’å…¥ä¸€ä¸ªï¼Œè®¡ç®—å½“å‰æ•°ç»„ä¸­çš„ç›¸é‚»å·®çš„æœ€å¤§å€¼\nå› ä¸ºæ•°æ®èŒƒå›´å¾ˆå°ï¼Œå¯ä»¥ç›´æ¥è¿›è¡Œ $O(n^2)$ çš„ç®—æ³•ï¼Œå³\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; set\u0026lt;ll\u0026gt;s; ll a[N]; void solve(){ s.clear(); bool flag=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s.insert(a[i]); } if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; return; } ll ans=-1; for(int i=1;i\u0026lt;n;i+=2){ ans=max(ans,a[i+1]-a[i]); } if(n%2==0){ cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=n;i+=2){ if(a[i+1]==a[i]+1)continue; s.insert(a[i]+1); ll tmp=-1; for(auto it=s.begin(); it!=s.end()\u0026amp;\u0026amp;next(it)!=s.end(); ++it,++it){ // cout\u0026lt;\u0026lt;*next(it)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;endl; tmp = max(tmp, *next(it) - *it); } ans = min(ans, tmp); s.erase(a[i]+1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Action Figures å¯ä»¥æŠŠä¸º 1 çš„ä½ç½®å…¨éƒ¨å¡å…¥ä¸€ä¸ªæ ˆä¸­\nåè¿‡æ¥æŸ¥æ‰¾ï¼Œé‡åˆ° 0 çš„è¯ï¼Œå°±çœ‹å½“å‰æ ˆé¡¶çš„å…ƒç´ æ˜¯å¦æ¯”ä»–å¤§ï¼Œå¦‚æœæ¯”ä»–å¤§ï¼Œè¯´æ˜æ ˆé¡¶è¿™ä¸ªå…ƒç´ å¯ä»¥ free\nç›´åˆ°æ²¡æœ‰ 0 å¼€å§‹å¯¹æ ˆå†…å…ƒç´ è€ƒè™‘ï¼Œå¦‚æœæ ˆå†…å…ƒç´ çš„ä¸ªæ•°å¤§äº 2 é‚£ä¹ˆå°±å¯ä»¥ç”¨æ ˆåº•å…ƒç´ æ¥ä½¿æ ˆé¡¶å…ƒç´  free\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; string s; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; deque\u0026lt;int\u0026gt;q; ll ans=0; s=\u0026#34; \u0026#34;+s; for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;1\u0026#39;)q.push_back(i); } for(int i=n;i\u0026gt;0;i--){ if(s[i]==\u0026#39;0\u0026#39;){ if(!q.empty()\u0026amp;\u0026amp;i\u0026lt;q.front())q.pop_front(); ans+=i; } } while(!q.empty()){ ans+=q.back(); q.pop_back(); if(!q.empty())q.pop_front(); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Sums of Segments è®¾\n$s[i]$ ä¸º $a[i]$ çš„å‰ç¼€å’Œï¼Œ $u[i]$ ä¸º $s[i]$ çš„å‰ç¼€å’Œï¼Œ $t[i]$ ä¸ºåˆ†å—åçš„ç¬¬ $i$ å—çš„å’Œï¼Œ $ts[i]$ ä¸ºåˆ†å—åçš„å‰ç¼€å’Œ æ˜“å¾—å‡º $b$ ä¸­ç¬¬ $k$ å—çš„ä¸ªæ•°ä¸º $n-k+1$\næ‰€ä»¥å‰ $k$ å—çš„æ€»æ•°ä¸º $nk-k(k-1)/2$\næ€»æ•°ä¸ºå•è°ƒé€’å¢ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨äºŒåˆ†æ‰¾åˆ° $l,r$ å¯¹åº”çš„å—æ•°ï¼Œå‡è®¾åˆ†åˆ«ä¸º $x,y$\næ­¤æ—¶ $ans=ts[y]-ts[x]$ï¼Œä½†æ˜¯ä¼šæœ‰äº›å¤šåŠ çš„ç‰‡æ®µ\næ­¤æ—¶å°±éœ€è¦æ‰¾åˆ° $l,r$ åœ¨æ‰€å±å—ä¸­çš„ç¬¬å‡ ä¸ª\nå¯ä»¥å‡è®¾ $l$ å¯¹åº”çš„æ˜¯ $s(x,z)$ï¼Œè¿™ä¸€å—ä¸Šæœ€åçš„å…ƒç´ æ˜¯ $s(x,n)$ï¼Œæ‰€ä»¥ $n-z=xn-\\frac{x(x-1)}2-l$ï¼Œé€šè¿‡æ­¤å¼æ‰¾åˆ° $z$ çš„å€¼ï¼Œåªéœ€è¦å‡æ‰ $s(x,1)$ åˆ° $s(x,z-1)$ çš„å€¼å³å¯\nåŒç†å¯ä»¥æ‰¾åˆ° $r$ å¤šåŠ çš„ç‰‡æ®µ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int n,q,l,r; ll a[N],s[N],u[N],t[N],ts[N]; ll x,y,z,v; ll bs(int x){ ll l=1,r=n,ans=1; while(l\u0026lt;=r){ ll mid=(l+r)\u0026gt;\u0026gt;1; if((n*mid-mid*(mid-1)/2)\u0026lt;x)l=mid+1; else r=mid-1,ans=mid; } return ans; } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i]; u[i]=u[i-1]+s[i]; } for(int i=n;i\u0026gt;0;i--){ t[i]=t[i+1]+(n-i+1)*a[i]; } for(int i=1;i\u0026lt;=n;i++){ ts[i]=ts[i-1]+t[i]; } cin\u0026gt;\u0026gt;q; while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; x=bs(l),y=bs(r); ll ans=ts[y]-ts[x-1]; z=n-(x*n-x*(x-1)/2-l); v=n-(y*n-y*(y-1)/2-r); ans-=u[z-1]-u[x-1]-(z-x)*s[x-1]; ans-=u[n]-u[v]-s[y-1]*(n-v); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe171/","summary":"Educational Codeforces Round 171 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 171"},{"content":"A. Rectangle Arrangement æœ€é•¿å’Œæœ€é«˜ç›¸åŠ ä¹˜äºŒå³ä¸ºç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; int mx,my; mx=my=-1; for(int i=1;i\u0026lt;=n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; mx=max(mx,x); my=max(my,y); } cout\u0026lt;\u0026lt;(mx+my)*2\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Stalin Sort $n\\leq2000$ ç›´æ¥ $O(n^2)$ æŸ¥æ‰¾å½“å‰ä½åæœ‰å‡ ä¸ªæ¯”ä»–å¤§çš„ï¼Œéƒ½åˆ å»\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; int a[N]; void solve(){ int ans=INT_MAX; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } for(int i=1;i\u0026lt;=n;i++){ int tmp=i-1; for(int j=i+1;j\u0026lt;=n;j++){ if(a[j]\u0026gt;a[i])tmp++; } ans=min(tmp,ans); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Add Zeros è§‚å¯Ÿé¢˜ç›®å‘ç° $a_i = |a| + 1 - i$ ä¸­çš„ $|a|$ å¹¶ä¸ä¼šæ”¹å˜ï¼Œé‚£ä¹ˆåªéœ€è¦è€ƒè™‘å½“å‰æ•°ç»„é•¿åº¦å³å¯ï¼Œå°†æ‰€æœ‰ $i$ å¯¹åº”çš„ $|a|$ æ‰¾åˆ°ï¼Œç›¸åŒçš„å­˜å…¥åŒä¸€æ•°ç»„ï¼Œç”¨ $dfs$ æš´åŠ›æŸ¥æ‰¾å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; ll n; ll a[N]; ll ans; map\u0026lt;ll,vector\u0026lt;ll\u0026gt;\u0026gt;vis; set\u0026lt;ll\u0026gt; visited; void dfs(ll now){ if (visited.count(now)) return; visited.insert(now); ans=max(ans,now); if(vis.find(now) != vis.end()){ for(ll x:vis[now]){ dfs(now+x-1); } } } void solve(){ ans=-1; vis.clear(); visited.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++){ vis[a[i] + i - 1].push_back(i); } dfs(n); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D1. The Endspeaker (Easy Version) å¤šç§æ“ä½œå®ŒæˆæŸä¸ªç›®æ ‡çš„æœ€å°ä»£ä»·ï¼Œå¯ä»¥è€ƒè™‘ DP\nè®¾ $dp_{i,j}$ ä¸ºå¯¹äºå‰ $i$ ä¸ªæ•°ç»„ï¼Œä½¿ç”¨ç¬¬ $j$ æ€»æ“ä½œçš„æœ€å°ä»£ä»·\næ˜“å¾—è½¬ç§»æ–¹ç¨‹ $dp[i][j]= \\text{min}{dp[p][k]}+m-j,\\text{sum}[p,i]\\le b[j],1\\le k\\le j,1\\le p\\le i$\næ˜¾ç„¶å¯ä»¥å°†ç¬¬ä¸€ç»´ä¼˜åŒ–æ‰ï¼Œæˆ‘ä»¬åªéœ€è¦é€šè¿‡å½“å‰æ“ä½œèƒ½åˆ°è¾¾ $n$ å³å¯ï¼Œå¯ä»¥ç”¨åé¢çš„æ“ä½œè¦†ç›–å‰é¢çš„\nç°åœ¨çš„ä¼˜åŒ–éš¾ç‚¹åœ¨äº $p$ å¦‚ä½•ç¡®å®š\nå…¶å®è½¬ç§»è¿‡ç¨‹å°±æ˜¯é€šè¿‡ä¸€ä¸ªæ»‘åŠ¨çª—å£æ¥è¿›è¡Œå®æ—¶æ›´æ–°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨åŒæŒ‡é’ˆæ¥å®Œæˆè¿™ä¸ªæ“ä½œ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; const int inf=1e9; int n,m; ll a[N],b[N],s[N],mx; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; mx=-1; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i]; mx=max(mx,a[i]); } for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;b[i]; if(mx\u0026gt;b[1]){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } vector\u0026lt;int\u0026gt; dp(n+10,inf); dp[0]=0; for(int i=1;i\u0026lt;=m;i++){ int l=0,r=1; while(r\u0026lt;=n){ while(l\u0026lt;r\u0026amp;\u0026amp;s[r]-s[l]\u0026gt;b[i])l++; if(l\u0026lt;r)dp[r]=min(dp[r],dp[l]+m-i); r++; } } cout\u0026lt;\u0026lt;dp[n]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf982/","summary":"Codeforces Round 982 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 982 (Div. 2)"},{"content":"C. A TRUE Battle å¦‚æœå¼€å¤´å’Œç»“å°¾æœ‰ $1$ï¼Œé‚£ä¹ˆä¸€å®š Alice èƒœ\nå¦‚æœä¸­é—´æœ‰ç›¸é‚»çš„ä¸¤ä¸ª $1$ï¼Œé‚£ä¹ˆ Alice å¯ä»¥å…ˆé€‰è¿™ä¿©ä¸­é—´ Or å†ä»»é€‰ä¸€è¾¹ Or æœ€åä¸€å®šèƒœ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; string s; cin\u0026gt;\u0026gt;s; if(s[0]==\u0026#39;1\u0026#39;||s[n-1]==\u0026#39;1\u0026#39;)cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for(int i=0;i\u0026lt;n;i++){ if((s[i]-\u0026#39;0\u0026#39;)\u0026amp;\u0026amp;(s[i+1]-\u0026#39;0\u0026#39;)==1){ cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } D. QED\u0026rsquo;s Favorite Permutation è§‚å¯Ÿé¢˜ç›®å‘ç°ï¼Œé™¤éå‡ºç° $LR$ è¿™æ ·çš„ç‰‡æ®µï¼Œä¸ç„¶å°±ä¼šå½¢æˆä¸€ä¸ªç‰‡æ®µï¼Œè¿™ä¸ªç‰‡æ®µä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å¯ä»¥äº’æ¢ä½ç½®ã€‚\né‚£ä¹ˆå°±å¯ä»¥åˆ¤æ–­æ¯ä¸ªç‰‡æ®µä¸­æ˜¯å¦æœ‰ä¸å±äºè¿™ä¸ªç‰‡æ®µçš„å…ƒç´ å­˜åœ¨ï¼Œå¦‚æœæœ‰å³ä¸º NOï¼Œåä¹‹ä¸º YES\nå¼€ä¸€ $cnt$ æ•°ç»„æ¥è®°å½•ä½ç½®é”™ä¹±çš„å€¼ï¼Œå¦‚æœå‰ç¼€å’Œ $cnt=0$ é‚£ä¹ˆå½“å‰ç‰‡æ®µå³ä¸ºå¯è¡Œç‰‡æ®µ\nå¦‚æœå‡ºç°äº† $LR$ åŒæ—¶ $cnt!=0$ é‚£ä¹ˆç­”æ¡ˆå°±ä¸º NO\nåªéœ€è¦å®æ—¶æ›´æ–°ä¸åˆæ³•çš„ä½ç½®å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,q; int p[N],cnt[N]; string s; set\u0026lt;int\u0026gt;st; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;p[i]; for(int i=1;i\u0026lt;=n;i++){ cnt[min(i,p[i])]++; cnt[max(i,p[i])]--; } for(int i=2;i\u0026lt;=n;i++)cnt[i]+=cnt[i-1]; cin\u0026gt;\u0026gt;s; s=\u0026#34; \u0026#34;+s; for(int i=1;i\u0026lt;n;i++){ if(s[i]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[i+1]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[i])st.insert(i); } while(q--){ int x; cin\u0026gt;\u0026gt;x; s[x]=(s[x]==\u0026#39;L\u0026#39;?\u0026#39;R\u0026#39;:\u0026#39;L\u0026#39;); if(s[x-1]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[x]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[x-1])st.insert(x-1); else st.erase(x-1); if(s[x]==\u0026#39;L\u0026#39;\u0026amp;\u0026amp;s[x+1]==\u0026#39;R\u0026#39;\u0026amp;\u0026amp;cnt[x])st.insert(x); else st.erase(x); if(!st.empty())cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } st.clear(); memset(cnt,0,sizeof(cnt)); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æœ‰ç‚¹ç±»ä¼¼çš„ä¸¤é“é¢˜\nCF Round 977 C1. Adjust The Presentation (Easy Version) åˆå§‹åºåˆ—çš„æŸä¸ªæˆå‘˜ï¼Œä»–åœ¨æ’­æ”¾åºåˆ—ä¸­å‡ºç°çš„é¡ºåºä¸€å®šæ¯”ä»–åé¢çš„äººå‰ï¼Œä¸å¯èƒ½åœ¨æ’­æ”¾åºåˆ—ä¸­å‡ºç°å€’åºçš„æƒ…å†µ\nç›¸å½“ä¸åªè€ƒè™‘å®é™…åˆå§‹åºåˆ—ä¸­çš„ç›¸é‚»ä½ç½®ï¼Œå¦‚æœä¸Šä¸€ä¸ªäººæ²¡æœ‰æ’­æ”¾è¿‡ï¼Œæˆ–è€…ä»–æ’­æ”¾çš„é¡ºåºæ¯”åé¢é‚£ä¸ªæ™šï¼Œé‚£ä¸€å®šä¸å¯èƒ½è¾¾æˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,m,q; int a[N],b[N],c[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;b[i]; memset(c,0x3f3f3f,sizeof(c)); for(int i=1;i\u0026lt;=m;i++){ if(c[b[i]]\u0026gt;N)c[b[i]]=i; } for(int i=2;i\u0026lt;=n;i++){ int now=a[i],lst=a[i-1]; if(c[now]\u0026lt;N\u0026amp;\u0026amp;c[lst]\u0026gt;N||c[now]\u0026lt;c[lst]){ cout\u0026lt;\u0026lt;\u0026#34;TIDAK\\n\u0026#34;; return; } } cout\u0026lt;\u0026lt;\u0026#34;YA\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C2. Adjust The Presentation (Hard Version) ä¸ C1 ç›¸æ¯”ï¼ŒåŠ äº† Q æ¬¡å¯æŒä¹…åŒ–æ›´æ”¹å’Œè¯¢é—®\nå®é™…æ€è·¯ä»å’Œä¸Šé¢˜ç›¸ä¼¼\næˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸åˆæ³•çš„æ‰€æœ‰ä½ç½®ï¼Œå³åˆå§‹åºåˆ—ä¸­é‚£äº›ç›¸é‚»çš„å‰è€…æœªæ’­æ”¾ï¼Œæˆ–åè€…å…ˆäºå‰è€…åœ¨æ’­æ”¾åºåˆ—å‡ºç°çš„ç»„åˆ\nå°†æ‰€æœ‰çš„ä¸åˆæ³•ç»„åˆå‚¨å­˜èµ·æ¥ï¼Œæ¯æ¬¡æ›´æ–°æ£€æŸ¥å‰©ä¸‹çš„ç»„åˆæ˜¯å¦ä¸º 0ï¼Œå¦‚æœä¸º 0 å³æ€»åºåˆ—ä¸ºåˆæ³•\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; const ll inf=1e16; int n,m,q; int a[N],b[N],c[N],d[N]; set\u0026lt;int\u0026gt;s[N]; int check(int x){ int cnt=0,l=a[x-1],r=a[x+1],now=a[x]; if(x\u0026lt;n\u0026amp;\u0026amp;d[now]\u0026gt;d[r])cnt++; if(x\u0026gt;1\u0026amp;\u0026amp;d[l]\u0026gt;d[now])cnt++; return cnt; } void solve(){ memset(c, 0, sizeof(c)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; a[i]; s[i].clear(); c[a[i]] = i; d[i] = inf; } for(int i = 1; i \u0026lt;= m; i++){ cin \u0026gt;\u0026gt; b[i]; s[b[i]].insert(i); } for(int i = m; i \u0026gt; 0; i--) d[b[i]] = i; int cnt = 0; for(int i = 1; i \u0026lt; n; i++){ if(d[a[i]] \u0026gt; d[a[i + 1]]) cnt++; } if(!cnt) cout \u0026lt;\u0026lt; \u0026#34;YA\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;TIDAK\\n\u0026#34;; while(q--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; s[b[x]].erase(x); s[y].insert(x); for(int i:{b[x],y}){ cnt-=check(c[i]); if(s[i].empty())d[i]=inf; else d[i]=*s[i].begin(); cnt+=check(c[i]); } b[x]=y; if(!cnt)cout\u0026lt;\u0026lt;\u0026#34;YA\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;TIDAK\\n\u0026#34;; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf979/","summary":"Codeforces Round 979 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 979 (Div. 2)"},{"content":"C. Swiss Stage å››ç›® TES æ‰“çš„åƒæµ“ shitï¼ŒçœŸçš„æ¶è‡­\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) #define lson (now\u0026lt;\u0026lt;1) #define rson (now\u0026lt;\u0026lt;1|1) using namespace std; typedef long long ll; const int N=2e5+7,inf=1e9+7; const ll mod=2097152; void solve() { int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ans[10][10]; ans[0][0]=4; ans[0][1]=4; ans[0][2]=6; ans[1][0]=3; ans[1][1]=3; ans[1][2]=4; ans[2][0]=2; ans[2][1]=2; ans[2][2]=2; cout\u0026lt;\u0026lt;ans[x][y]; } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } J. Graft and Transplant æ¯æ¬¡åªèƒ½é€‰åº¦æ•°ä¸ä¸º $1$ çš„ç‚¹ï¼Œçœ‹ä¸€å…±æœ‰å¤šå°‘ä¸ªèƒ½é€‰çš„ç‚¹å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,u,v; int deg[55]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; deg[u]++; deg[v]++; } int cnt=0; for(int i=1;i\u0026lt;=n;i++){ if(deg[i]\u0026gt;1)cnt++; } if((cnt\u0026amp;1)||(!cnt))cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E. Sheep Eat Wolves å¼€å§‹æƒ³çš„æ˜¯æ¨¡æ‹Ÿï¼Œä½†æ˜¯æ¨¡æ‹Ÿä¸€ç›´è°ƒä¸å‡ºæ¥ï¼Œæœ€åç”¨ $dp$ è°ƒå‡ºæ¥äº†\nç”¨ $f_{i,j}$ è®°å½•æœ€ä½³æ–¹æ¡ˆçš„ä»£ä»·ï¼Œ$i,j$ åˆ†åˆ«å¯¹åº”å½“å‰å·¦ä¾§çš„ç¾Šå’Œç‹¼çš„æ•°é‡\nèˆ¹æ¯æ¬¡éƒ½æ˜¯åæ»¡æœ€ä¼˜ï¼Œä½¿æŸäº›ç‹¼ä¸€ç›´åœ¨èˆ¹ä¸Šï¼Œæ¯”èˆ¹ä¸Šç•™ç©ºä½æ›´ä¼˜\nåŒæ—¶ç¾Šé€åˆ°å¯¹å²¸ï¼Œç»å¯¹ä¸å¯èƒ½å†è¿”å›ï¼Œä½†æ˜¯ç‹¼å¯èƒ½æ¥å›æºå¸¦ï¼Œå¦‚æ ·ä¾‹2ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æšä¸¾å¸¦å›ç‹¼çš„æ•°é‡\né€’æ¨å…¬å¼å¦‚ä¸‹\n$f_{i,j}=\\begin{cases}0,\u0026amp;i=0\\\\1,\u0026amp;i\\leq p\\\\min{f_{ij}+f_{i-x,j-y}+2}\\end{cases}$\næœ€åè¾“å‡º $f_{x,y}$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+10, mod=1e9+7; int f[N][N],x,y,q,p; bool check(int x,int y){ return (x\u0026amp;\u0026amp;y-x\u0026gt;q); } void solve(){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q; memset(f,-1,sizeof(f)); for(int i=0;i\u0026lt;=x;i++){ for(int j=0;j\u0026lt;=y;j++){ if(check(x-i,y-j))continue; if(i==0){ f[i][j]=0; continue; } if(i\u0026lt;=p){ f[i][j]=1; continue; } for(int k=0;k\u0026lt;=i\u0026amp;\u0026amp;k\u0026lt;=p;k++){ int l=p-k; if(check(i-k,j-l))continue; for(int m=0;m\u0026lt;=p\u0026amp;\u0026amp;m\u0026lt;=y-j+l;m++){ if(k==0\u0026amp;\u0026amp;m==p)continue; if(f[i-k][j-l+m]==-1)continue; if(f[i][j]==-1)f[i][j]=2+f[i-k][j-l+m]; else f[i][j]=min(f[i][j],2+f[i-k][j-l+m]); } } } } cout\u0026lt;\u0026lt;f[x][y]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } K. Maximum Rating é˜Ÿé•¿ä¸€çœ¼é¡¶é’ˆå‡ºç»“è®ºï¼Œ$k$ æ˜¯è¿ç»­çš„ï¼Œæ‰¾ä¸Šä¸‹é™å³å¯\næ˜¾ç„¶ä¸Šé™ä¸ºå…ˆè¿›è¡Œæ‰€æœ‰ä¸ºæ­£æ•°çš„æ¯”èµ›ï¼Œä¸‹é™ä¸ºå…ˆè¿›è¡Œæ‰€æœ‰ä¸ºè´Ÿæ•°çš„æ¯”èµ›ï¼ŒåŒæ—¶æ­£æ•°çš„æ¯”èµ›ä»å°åˆ°å¤§æ’\nç°åœ¨çš„é—®é¢˜å°±è½¬åŒ–åˆ°å¦‚ä½•ç»´æŠ¤è¿™ä¸ª $k$ çš„èŒƒå›´\néœ€è¦ç”¨çº¿æ®µæ ‘ç»´æŠ¤ï¼ŒåŒæ—¶æ ¹æ® $a$ çš„èŒƒå›´å‘ç°éœ€è¦åŠ¨æ€å¼€ç‚¹\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; struct Node{ int l,r,cnt; ll sum; }tr[N*2*32]; int tot=0,rt=0; ll a[N]; void add(int\u0026amp; now,int l,int r,int x,int v){ if(!now)now=++tot; tr[now].sum+=x*v; tr[now].cnt+=v; if(l==r)return; ll mid=(l+r)\u0026gt;\u0026gt;1; if(x\u0026lt;=mid)add(tr[now].l,l,mid,x,v); else add(tr[now].r,mid+1,r,x,v); } int ask(int now,int l,int r,ll x){ if(!now)return 0; if(tr[now].sum\u0026lt;=x)return 0; if(l==r)return tr[now].cnt-(x/l); ll mid=(l+r)\u0026gt;\u0026gt;1; if(tr[tr[now].l].sum\u0026gt;x)return tr[tr[now].r].cnt+ask(tr[now].l,l,mid,x); else return ask(tr[now].r,mid+1,r,x-tr[tr[now].l].sum); } void solve(){ int n,q,cnt=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026gt;0)++cnt; add(rt,-1e9,1e9,a[i],1); } while(q--){ ll x,v; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;v; if(a[x]\u0026gt;0)--cnt; add(rt,-1e9,1e9,a[x],-1); a[x]=v; add(rt,-1e9,1e9,a[x],1); if(a[x]\u0026gt;0)++cnt; int tmp=ask(rt,-1e9,1e9,0); cout\u0026lt;\u0026lt;cnt-tmp+1\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/icpc2023shenyang/","summary":"LPL ä½ è¿™é‡Œæ¬ æˆ‘çš„ç”¨ä»€ä¹ˆè¿˜","title":"ICPC 2023 æ²ˆé˜³ VP"},{"content":"æ¦‚è¿° ç½‘ç»œæ˜¯æŒ‡ä¸€ä¸ªç‰¹æ®Šçš„æœ‰å‘å›¾ $G=(V,E)$ï¼Œä¸ä¸€èˆ¬å›¾ä¸åŒçš„æ˜¯æœ‰å®¹é‡å’Œæºæ±‡ç‚¹\n$E$ ä¸­çš„æ¯æ¡è¾¹ $(u,v)$ éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå®¹é‡çš„æƒå€¼ï¼Œå¦‚æœæŸæ¡è¾¹ $(u,v)\\not\\in E$ï¼Œå¯ä»¥å‡å®š $c(u,v)=0$ $V$ ä¸­æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„ç‚¹ï¼Œæºç‚¹ $s$ å’Œæ±‡ç‚¹ $t$ å¯¹äºç½‘ç»œ $G=(V,E)$ï¼Œæµæ˜¯ä¸€ä¸ªä»è¾¹é›† $E$ åˆ°æ•´æ•°é›†æˆ–å®æ•°é›†çš„å‡½æ•°ï¼Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨\nå®¹é‡é™åˆ¶ï¼šå¯¹äºæ¯æ¡è¾¹ï¼Œæµç»è¯¥è¾¹çš„æµé‡ä¸å¾—è¶…è¿‡è¯¥è¾¹çš„å®¹é‡ï¼Œå³ $0\\leq f(u,v)\\leq c(u,v)$ æµå®ˆæ’æ€§ï¼šé™¤æºæ±‡ç‚¹å¤–ï¼Œä»»æ„ç»“ç‚¹ $u$ çš„å‡€æµé‡ä¸º $0$ã€‚å…¶ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰ $u$ çš„å‡€æµé‡ä¸º $f(u)=\\sum_{x\\in V}f(u,x)-\\sum_{x\\in V}f(x,u)$ å¯¹äºç½‘ç»œ $G=(V,E)$ å’Œå…¶ä¸Šçš„æµ $f$ï¼Œæˆ‘ä»¬å®šä¹‰ $f$ çš„æµé‡ $|f|$ ä¸º $s$ çš„å‡€æµé‡ $f(s)$ï¼Œæ ¹æ®æµå®ˆæ’æ€§ $f(s)=-f(t)$\nå¯¹äºç½‘ç»œ $G=(V,E)$ï¼Œå¦‚æœ ${S,T}$ æ˜¯ $V$ çš„åˆ’åˆ†ï¼ˆå³ $S\\cup T=V$ ä¸” $S\\cap T=\\emptyset$ï¼‰ï¼Œä¸”æ»¡è¶³ $s\\in S,t\\in T$ï¼Œé‚£æˆ‘ä»¬å°±ç§° ${S,T}$ æ˜¯ $G$ çš„ä¸€ä¸ª $s-t$ å‰²ã€‚å®šä¹‰ $s-t$ å‰² ${S,T}$ çš„å®¹é‡ä¸º $||S,T||=\\sum_{u\\in S}\\sum_{v\\in T}c(u,v)$\nå¸¸è§é—®é¢˜åˆ†ç±» æœ€å¤§æµé—®é¢˜ï¼šå¯¹äºç½‘ç»œ $G=(V,E)$ï¼Œç»™æ¯æ¡è¾¹æŒ‡å®šæµé‡ï¼Œå¾—åˆ°åˆé€‚çš„æµ $f$ï¼Œä½¿å¾— $f$ çš„æµé‡å°½å¯èƒ½å¤§ï¼Œæ­¤æ—¶ç§° $f$ ä¸º $g$ çš„æœ€å¤§æµ\næœ€å°å‰²é—®é¢˜ï¼šå¯¹äºç½‘ç»œ $G=(V,E)$ï¼Œæ‰¾åˆ°åˆé€‚çš„ $s-t$ å‰² ${S,T}$ï¼Œä½¿å¾—å…¶å®¹é‡å°½å¯èƒ½å°ï¼Œæ­¤æ—¶ç§° ${S,T}$ ä¸º $G$ çš„æœ€å°å‰²\næœ€å°è´¹ç”¨æœ€å¤§æµé—®é¢˜ï¼šåœ¨ç½‘ç»œ $G=(V,E)$ï¼Œå¯¹äºæ¯æ¡è¾¹ç»™å®šä¸€ä¸ªæƒå€¼ $w(u,v)$ï¼Œç§°ä¸ºè´¹ç”¨ï¼Œå«ä¹‰æ˜¯å•ä½æµé‡é€šè¿‡ $(u,v)$ èŠ±è´¹çš„ä»£ä»·ï¼Œå¯¹äº $G$ æ‰€æœ‰å¯èƒ½çš„æœ€å¤§æµï¼Œæˆ‘ä»¬ç§°æ€»è´¹ç”¨æœ€å°çš„ä¸€è€…ä¸ºæœ€å°è´¹ç”¨æœ€å¤§æµ\næœ€å¤§æµ æœ€å¤§æµé—®é¢˜çš„å­¦ä¹ \næ¦‚è¿° ä»¤ $G=(V,E)$ æ˜¯ä¸€ä¸ªæœ‰æºæ±‡ç‚¹çš„ç½‘ç»œï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ $G$ ä¸ŠæŒ‡å®šåˆé€‚çš„æµ $f$ï¼Œä»¥æœ€å¤§åŒ–æ•´ä¸ªç½‘ç»œçš„æµé‡ $|f|$ï¼ˆå³ $\\sum_{x \\in V} f(s, x) - \\sum_{x \\in V} f(x, s)$ï¼‰ï¼Œè¿™ä¸€é—®é¢˜è¢«ç§°ä½œæœ€å¤§æµé—®é¢˜\nFordâ€“Fulkerson å¢å¹¿ Fordâ€“Fulkerson å¢å¹¿æ˜¯è®¡ç®—æœ€å¤§æµçš„ä¸€ç±»ç®—æ³•çš„æ€»ç§°ã€‚è¯¥æ–¹æ³•è¿ç”¨ è´ªå¿ƒ çš„æ€æƒ³ï¼Œé€šè¿‡å¯»æ‰¾ å¢å¹¿è·¯ æ¥æ›´æ–°å¹¶æ±‚è§£æœ€å¤§æµã€‚\næ¦‚è¿° ç»™å®šç½‘ç»œ $G$ å’Œ ç½‘ç»œä¸Šçš„æµ $f$ï¼Œåšå¦‚ä¸‹å®šä¹‰\nå¯¹äºè¾¹ $(u,v)$ï¼Œæˆ‘ä»¬å°†å…¶å®¹é‡ä¸æµé‡ä¹‹å·®ç§°ä¸ºå‰©ä½™å®¹é‡ $c_f(u,v)$ï¼Œå³ $c_f(u,v)=c(u,v)-f(u,v)$\næˆ‘ä»¬å°† $G$ ä¸­æ‰€æœ‰çš„ç»“ç‚¹å’Œå‰©ä½™å®¹é‡å¤§äº $0$ çš„è¾¹æ„æˆçš„å­å›¾ç§°ä¸ºæ®‹é‡ç½‘ç»œ $G_f$ï¼Œå³ $G_f=(V,E_f)$ï¼Œå…¶ä¸­ $E_f={(u,v)\\mid c_f(u,v)\u0026gt;0}$\n","permalink":"http://localhost:1313/posts/study/flow/","summary":"å¤Ÿè‰çš„ç½‘ç»œæµæˆ‘å¡Œå—æ¥å•¦","title":"ç½‘ç»œæµå­¦ä¹ è®°å½•"},{"content":"J. Strange Sum æœ€å¤šé€‰ä¸¤ä¸ªï¼Œæ¯é€‰å½“å‰è¿™ä¸ªä¼šé™åˆ¶é€‰çš„èŒƒå›´ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±ä¸€å®šæ˜¯å‰é¢æœ€å¤§çš„åŠ ä¸Šç°åœ¨è¿™ä¸ªçš„æœ€å¤§å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n; cin\u0026gt;\u0026gt;n; ll mx=0,ans=0; for(int i=1;i\u0026lt;=n;i++){ ll x; cin\u0026gt;\u0026gt;x; ans=max(ans,x+mx); mx=max(mx,x); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Clone Ranran å¦‚æœè¦å…‹éš†å¢åŠ äººæ•°ï¼Œä¸€å®šæ˜¯å…ˆåœ¨å‡ºé¢˜æ“ä½œå‰å¢åŠ çš„ï¼Œé‚£ä¹ˆå°±éå†å¯èƒ½çš„å…‹éš†æ¬¡æ•°ï¼Œæ‰¾åˆ°æ€»å…±çš„æœ€å°ä»£ä»·\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=3e2+7,inf=1e9+7; const ll mod=2097152; ll a,b,c; void solve() { ll ans=1e18,now=0,peo=1; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; while(peo\u0026lt;=c*2){ ans=min(ans,(int)ceil(1.0*c/peo)*b+now); now+=a; peo*=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } F. Hotel å› ä¸ºåŒäººæˆ¿åªèƒ½åŒé˜Ÿçš„åŒæ€§åˆ«ä½ï¼Œé‚£åªç”¨å¯¹æ¯é˜Ÿè€ƒè™‘å³å¯\nå¦‚æœåŒä¸€é˜Ÿå†…æœ‰åŒæ€§çš„ï¼Œé‚£å°±å¯ä»¥è€ƒè™‘ç”¨åŒäººæˆ¿ï¼Œå¦åˆ™å…¨ç”¨å•ä»·ä½çš„æˆ¿é—´\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=3e2+7,inf=1e9+7; const ll mod=2097152; void solve() { int n,c1,c2,sum=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c1\u0026gt;\u0026gt;c2; for(int i=1;i\u0026lt;=n;++i) { string s; cin\u0026gt;\u0026gt;s; bool flag=0; if(s[0]==s[1]||s[0]==s[2]||s[1]==s[2]) flag=1; int mi=min(c1,c2),ans=3*mi; if(flag) ans=min(ans,mi+c2); sum+=ans; } printf(\u0026#34;%d\\n\u0026#34;,sum); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } G. Perfect Word æ‰€æœ‰ $t$ æŒ‰é•¿åº¦æ’åºï¼Œä¾æ¬¡åœ¨åé¢çš„ä¸²æ˜¯å¦æ»¡è¶³ä»–çš„å­ä¸²åœ¨å‰é¢éƒ½å‡ºç°è¿‡å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=1e5+7,inf=1e9+7; const ll mod=2097152; string s[N]; map\u0026lt;string,bool\u0026gt; mp; bool cmp(string x,string y) { return x.length()\u0026lt;y.length(); } void solve() { int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;s[i]; sort(s+1,s+1+n,cmp); for(int i=1;i\u0026lt;=n;++i) { if(s[i].length()==1) mp[s[i]]=1,ans=1; else { string tmp=s[i].substr(0,s[i].length()-1); if(mp.find(tmp)==mp.end()) continue; tmp=s[i].substr(1,s[i].length()-1); if(mp.find(tmp)==mp.end()) continue; mp[s[i]]=1; ans=s[i].length(); } } printf(\u0026#34;%d\u0026#34;,ans); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; // cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } E. Find Maximum æ‰“è¡¨åå‘ç°ï¼Œé‡åˆ° $3$ çš„å€æ•°å°±ä¼šå˜å°ä¸€æ¬¡ï¼Œæ¯ä¸‰æ¬¡æ˜¯ä¸€ä¸ªå°ç‰‡æ®µï¼Œæ ¹æ®è¿™ä¸ªæ€§è´¨ç”¨ $dfs$ æš´åŠ›æ‰¾å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; #define max(x,y) ((x)\u0026lt;(y)?(y):(x)) #define min(x,y) ((x)\u0026gt;(y)?(y):(x)) #define mk(x,y) make_pair(x,y) using namespace std; typedef long long ll; const int N=1e5+7,inf=1e9+7; const ll mod=2097152; ll F(ll x) { if(x\u0026lt;3) return 1+x; int y=x%3; return y+1+F(x/3); } ll sol(ll l,ll r) { ll ans=0; while(l\u0026lt;=r\u0026amp;\u0026amp;l%3!=0) { ll x=F(l); ans=max(ans,x); ++l; } if(l\u0026gt;r) return ans; while(l\u0026lt;=r\u0026amp;\u0026amp;r%3!=2) { ll x=F(r); ans=max(ans,x); --r; } if(l\u0026gt;r) return ans; ll tmp=sol(l/3,r/3)+3; return max(ans,tmp); } void solve() { ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; printf(\u0026#34;%lld\\n\u0026#34;,sol(l,r)); } int main() { std::ios::sync_with_stdio(0); std::cin.tie(0); int T=1; cin\u0026gt;\u0026gt;T; while(T--) { solve(); } return 0; } L. Tree è§‚å¯Ÿé¢˜ç›®ï¼Œå‘ç°é›†åˆè¦ä¹ˆæ˜¯ä¸€æ¡é“¾ï¼Œè¦ä¹ˆæ˜¯å½“å‰æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹ï¼Œè¿™ä»£è¡¨äº†ä¸¤ç§æ“ä½œï¼Œè¦æ‰¾åˆ°æœ€å°‘çš„æ“ä½œæ¬¡æ•°\nè®°å½•å½“å‰çš„å¶å­èŠ‚ç‚¹ï¼Œå¾€ä¸ŠæŸ¥æ‰¾ä¸€å±‚ï¼Œç”¨å‡ºåº¦åˆ¤æ–­æ˜¯å¦ä¸ºåˆ†å‰æƒ…å†µï¼Œæ‰¾åˆ°å½“å‰çš„é“¾æ•°ï¼Œç”¨è¿™ä¸ªé“¾æ•°åŠ ä¸Šå–å¶å­èŠ‚ç‚¹çš„æ¬¡æ•°ï¼Œå³ä¸ºå½“å‰ç­”æ¡ˆï¼Œä¸€ç›´æ‰¾åˆ°å¾€ä¸Šæ²¡æœ‰é“¾ä¸ºæ­¢\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; vector\u0026lt;int\u0026gt;nxt[N]; int fa[N],deg[N]; deque\u0026lt;int\u0026gt;leaf; bool vis[N]; void dfs(int x,int f,int len){ fa[x]=f; for(auto y:nxt[x]){ if(y!=f)dfs(y,x,len+1),++deg[x]; } if(!deg[x])leaf.push_back(x); } void solve(){ leaf.clear(); cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; nxt[x].push_back(i); nxt[i].push_back(x); } dfs(1,0,1); int ans=leaf.size(); for(int i=1;!leaf.empty();i++){ int cnt=leaf.size(); while(cnt--){ int x=fa[leaf.front()]; leaf.pop_front(); if(!x)continue; --deg[x]; if(!deg[x])leaf.push_back(x); } ans=min(ans,i+(int)leaf.size()); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;i++)nxt[i].clear(),vis[i]=0,deg[i]=0; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Cells Coloring ç½‘ç»œæµï¼Œå¥½åƒæŒºæ¿çš„ï¼Œåé¢å­¦äº†è¡¥\nA. Bridge LCTï¼Œåé¢å­¦äº†è¡¥\n","permalink":"http://localhost:1313/posts/study/icpc2022xian/","summary":"è¡¨ç°è¿˜è¡Œ","title":"ICPC 2022 è¥¿å®‰ VP"},{"content":"A. Two Screens æ‰¾ä¸¤ä¸²ç›¸åŒå‰ç¼€é•¿åº¦ï¼Œå†åŠ ä¸Šå„è‡ªä¹‹åçš„é•¿åº¦\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; string s,t; int ans; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; ans=0; for(int i=0;i\u0026lt;min(s.size(),t.size());i++){ if(s[i]==t[i]){ ans++; if(i==min(s.size(),t.size())-1){ ans++; ans+=(s.size()-i)+(t.size()-i)-2; } } else{ if(i!=0){ ans++; ans+=(s.size()-i)+(t.size()-i); } else{ ans+=(s.size()-i)+(t.size()-i); } break; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Binomial Coefficients, Kind Of é€šè¿‡æ‰“è¡¨å‘ç°ç›®æ ‡è¾“å‡ºå…¶å®å°±æ˜¯ $2^{k[i]}$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; #define int long long const int N=1e5+7, mod=1e9+7; ll qpow(int x,int y){ ll res=1; while(x){ if(x\u0026amp;1){ res=(res*y)%mod; } y=(y*y)%mod; x/=2; } return res; } void solve(){ int t; int n[N],k[N]; cin\u0026gt;\u0026gt;t; for(int i=1;i\u0026lt;=t;i++)cin\u0026gt;\u0026gt;n[i]; for(int i=1;i\u0026lt;=t;i++)cin\u0026gt;\u0026gt;k[i]; for(int i=1;i\u0026lt;=t;i++){ if(n[i]\u0026gt;=k[i]) cout\u0026lt;\u0026lt;qpow(k[i],2)\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. New Game å¯ä»¥å‘ç°å–ç‰Œåªèƒ½å–ä¸€æ®µè¿ç»­ç‰‡æ®µå†…çš„æ‰€æœ‰ç‰Œï¼Œé‚£æˆ‘ä»¬åªéœ€è¦éå†æ‰€æœ‰çš„ç‰Œçš„ç§ç±»å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,k; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; map\u0026lt;int,int\u0026gt;vis; set\u0026lt;int\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; s.insert(x); vis[x]++; } int lst=-100,len=1; ll tmp=0,ans=0; for(int x:s){ if(x==lst+1){ tmp+=vis[x]; len++; lst=x; if(len\u0026gt;k){ len--; tmp-=vis[x-k]; } } else{ len=1; tmp=vis[x]; lst=x; } ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D. Attribute Checks å› ä¸º $m$ å’Œ $|a[i]|$ çš„å€¼å¾ˆå°ï¼Œå¯ä»¥è€ƒè™‘ $DP$ (å¼€å§‹å°è¯•ç”¨ $set$ å®ç°ï¼Œä½†æ˜¯æ’å…¥æ“ä½œçš„ $nlogn$ ä¼šä½¿å¤æ‚åº¦è¿‡é«˜)\nè®°å½•æ¯ç§ä»»åŠ¡çš„éœ€æ±‚ï¼Œå½“é‡åˆ° $r[i]==0$ æ—¶ï¼Œå³å¯è¿›è¡Œdpï¼Œå¯ä»¥éå†æ‰€æœ‰å½“å‰æ€»èƒ½åŠ›å€¼å‰æ–¹çš„ä»»åŠ¡æ•°é‡ï¼Œå–å¾—å‰ç¼€å’Œï¼Œç„¶åç”¨ $dp$ è®°å½•æ™ºåŠ›å– $i$ æ—¶çš„æœ€å¤§ $dp$ å€¼\nç„¶åæŠŠç”¨è¿‡çš„æ•°ç»„è¿˜åŸï¼Œå°† $now+1$ ç»§ç»­å‘ä¸‹è¿›è¡Œ\næœ€åéå†æ‰€æœ‰çš„ $dp$ æ‰¾åˆ°æœ€å¤§çš„å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e6+7, mod=1e9+7, M=5e4+10; int n,m; int r[N],dp[M],st[N],in[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;r[i]; } int now=0; int ans=0; memset(st,0,sizeof(st)); memset(in,0,sizeof(in)); memset(dp,0,sizeof(dp)); for(int i=1;i\u0026lt;=n;i++){ if(r[i]\u0026gt;0)in[r[i]]++; if(r[i]\u0026lt;0)st[-r[i]]++; if(r[i]==0||i==n){ for(int j=1;j\u0026lt;=now;j++){ in[j]+=in[j-1]; st[j]+=st[j-1]; } for(int j=0;j\u0026lt;=now;j++){ dp[j]+=in[j]+st[now-j]; } for(int j=now+1;j\u0026gt;0;j--){ dp[j]=max(dp[j],dp[j-1]); } now++; for(int j=1;j\u0026lt;=now;j++){ in[j]=0; st[j]=0; } } } for(int i=1;i\u0026lt;=now;i++)ans=max(ans,dp[i]); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cfe170/","summary":"Educational Codeforces Round 170 (Rated for Div. 2) è¡¥é¢˜","title":"Educational Codeforces Round 170"},{"content":"A. Bus to PÃ©njamo æ¯ä¸ªå®¶æ—ä¼˜å…ˆæŒ‰æ’åº§ï¼Œç»Ÿè®¡æ‰€æœ‰å®¶æ—å¤šå‡ºæ¥çš„é‚£ä¸€ä¸ªäººçš„æ€»å’Œï¼Œçœ‹æœ€åå‰©å‡ æ’å¯ä»¥è®©ä»–ä»¬å•ç‹¬åº§ï¼Œå…¶ä½™äººç»§ç»­åæ»¡ä¸€æ’\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,r; int a[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;r; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a+1,a+1+n); int ans=0,lft=0; for(int i=n;i\u0026gt;0;i--){ ans+=(a[i]/2)*2; r-=a[i]/2; lft+=a[i]%2; } ans+=min(lft,r); ans-=max(0,(lft-r)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Kar Salesman ç»“è®ºé¢˜ï¼Œæœ€å°‘æˆ‘ä»¬éœ€è¦æ•°é‡æœ€å¤§çš„é‚£ä¸ªè½¦å‹çš„äººæ•°ï¼Œå¦‚æœè¿™ä¸ªå€¼ä¸å¤Ÿä¹°ä¸‹å…¶ä»–æ‰€æœ‰çš„ï¼Œé‚£å°±æ˜¯æ‰€æœ‰çš„æ€»å’Œé™¤ä»¥ $x$ çš„å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=5e5+7, mod=1e9+7; int n,x; int ans,a[N],sum; void solve(){ ans=sum=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; sum+=a[i]; ans=max(ans,a[i]); } if(ans*x\u0026gt;sum)cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;(int)ceil(1.0*sum/x)\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Gerrymandering $DP$\næ‰€æœ‰çš„é€‰åŒºå¦‚ä¸‹\næŒ‰åˆ—å‘å‰æ¨è¿›\nå½“ $i%3==0$ æ—¶ï¼Œè€ƒè™‘ä¸¤è¡Œæ•´é½åˆ†å¼€æ’ï¼Œä¸Šä¸‹ç»„åˆæ’ å½“ $i%3==1$ æ—¶ï¼Œè€ƒè™‘æœ‰é”™å¼€çš„æƒ…å†µ å…·ä½“å¯ä»¥çœ‹ä»£ç çš„è½¬ç§»\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; bool check(char a,char b,char c){ int res=(a==\u0026#39;A\u0026#39;)+(b==\u0026#39;A\u0026#39;)+(c==\u0026#39;A\u0026#39;); return res\u0026gt;=2; } int n; char mp[3][N]; int dp[5][N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;2;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; memset(dp,0,sizeof(dp)); dp[0][1]=0; for(int i=1;i\u0026lt;=n;i++){ if(i%3==1){ dp[0][i+3]=max(dp[0][i+3],dp[0][i]+check(mp[0][i],mp[0][i+1],mp[0][i+2])+check(mp[1][i],mp[1][i+1],mp[1][i+2])); dp[0][i+1]=max(dp[0][i+1],dp[0][i]+check(mp[0][i],mp[1][i],mp[0][i+1])); dp[1][i+1]=max(dp[1][i+1],dp[0][i]+check(mp[1][i],mp[0][i],mp[1][i+1])); } else if(i%3==2){ if(i\u0026lt;=n-3){ dp[0][i+3]=max(dp[0][i+3],dp[0][i]+check(mp[0][i+1],mp[0][i+2],mp[0][i+3])+check(mp[1][i],mp[1][i+1],mp[1][i+2])); dp[1][i+3]=max(dp[1][i+3],dp[1][i]+check(mp[0][i],mp[0][i+1],mp[0][i+2])+check(mp[1][i+1],mp[1][i+2],mp[1][i+3])); } dp[0][i+2]=max(dp[0][i+2],dp[0][i]+check(mp[1][i],mp[1][i+1],mp[0][i+1])); dp[0][i+2]=max(dp[0][i+2],dp[1][i]+check(mp[0][i+1],mp[0][i],mp[1][i+1])); } } cout\u0026lt;\u0026lt;dp[0][n+1]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D1. Asesino (Easy Version) äº¤äº’é¢˜\nå¯ä»¥å‘ç°ï¼Œå¦‚æœä¸¤ä¸ªäººçš„èº«ä»½æ˜¯çœŸçš„ï¼Œé‚£ä¹ˆä»–ä»¬å¯¹å¯¹æ–¹çš„å›ç­”æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥ä¸¤ä¸¤åˆ¤æ–­ï¼Œå¦‚æœæœ‰ä¸€å¯¹ä¸ç”¨ï¼Œä¼ªè£…è€…å°±åœ¨è¿™ä¸€å¯¹ä¸­ï¼Œåªéœ€è¦å†å–ä¸€ä¸ªæ¯”å¯¹ä¸€æ¬¡å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n; bool query(int x,int y){ cout\u0026lt;\u0026lt;\u0026#34;? \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; int fx,fy; cin\u0026gt;\u0026gt;fx; cout\u0026lt;\u0026lt;\u0026#34;? \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;fy; return fx!=fy; } void solve(){ cin\u0026gt;\u0026gt;n; int pos=-1; for(int i=1;i\u0026lt;n;i+=2){ bool flag=query(i,i+1); if(flag){ pos=i; break; } } if(pos==-1)cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else if(query(pos,pos\u0026gt;1?pos-1:pos+2)) cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;pos\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;! \u0026#34;\u0026lt;\u0026lt;pos+1\u0026lt;\u0026lt;endl; } int main(){ // ios::sync_with_stdio(0); // cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf978/","summary":"Codeforces Round 978 (Div. 2) è¡¥é¢˜","title":"Codeforces Round 978 (Div. 2)"},{"content":"I. Counter æ“ä½œå¯ä»¥éƒ½æƒ³æˆè¿ç»­çš„ï¼Œé‚£ä¹ˆè¾“å…¥ $a,b$ï¼Œæ„ä¸ºåœ¨ $a-b$ å¤„è¿›è¡Œäº†ä¸€æ¬¡å½’é›¶ï¼Œä¹‹åè¿ç€è¿›è¡Œäº† $b$ æ¬¡æ“ä½œï¼Œå¦‚æœä¸­é—´æœ‰å†²çªï¼Œå³ä¸º NO\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,m,flag=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=m;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(b\u0026gt;a)flag=1; int l = a - b; if(vis.find(l) != vis.end()){ vis[l] = max(vis[l], a); } else { vis[l] = a; } } int now=-1; for(auto \u0026amp;x:vis){ if(now\u0026gt;=x.first){ flag=1; break; } now=x.second; } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C. Primitive Root é€šè¿‡é¢˜ä¸Šå…¬å¼å¯ä»¥å¾—åˆ° $g=(kP+1)\\oplus(P-1)$\næ˜¾ç„¶ $g$ çš„æ•°é‡å°±æ˜¯ $k$ çš„ä¸ªæ•°\nå¼‚æˆ–æ€§è´¨ï¼š $a-b\\leq a\\oplus b\\leq a+b$\né‚£ä¹ˆ $0\\leq k\\leq\\left\\lfloor\\frac mP\\right\\rfloor-1$ æ—¶ï¼Œæ‰€æœ‰çš„ $k$ éƒ½æˆç«‹ï¼Œ$k\\geq\\lceil\\frac mP\\rceil+1$ æ—¶ï¼Œæ‰€æœ‰çš„ $k$ éƒ½ä¸æˆç«‹ï¼Œé‚£ä¹ˆåªéœ€è¦ç‰¹æ®Šåˆ¤æ–­ä¸¤è¾¹ç•Œä¹‹é—´çš„å€¼å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; ll p,m,ans; void solve(){ cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;m; ans=m/p; for(ll i=m/p;i\u0026lt;=ceil(1.0*m/p);i++){ if(((i*p+1)^(p-1))\u0026lt;=m)ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } G - Knapsack æ˜¾ç„¶ï¼Œå…è´¹è·å–çš„æœºä¼šè¦ç”¨åœ¨ $w$ å¤§çš„ç‰©å“ä¸Š\nå°†æ‰€æœ‰ç‰©å“æ’åºï¼Œå…ˆè¿›è¡Œä¸€éèƒŒåŒ…ï¼Œå¾—åˆ°å¯¹å‰ $i$ ä¸ªç‰©å“èƒŒåŒ…æ—¶çš„æœ€å¤§å€¼\nå†ç”¨è¿™ä¸ªå€¼åŠ ä¸Šæœªé€‰çš„ç‰©å“ä¸­ $v$ æœ€å¤§çš„ $k$ ä¸ªç‰©å“ï¼Œæœ€å¤§å€¼å³ä¸ºç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e4+7, mod=1e9+7; struct Node{ int w,v; bool operator\u0026lt;(const Node \u0026amp;t){ if(w==t.w)return v\u0026lt;t.v; return w\u0026lt;t.w; } }a[N]; ll n,m,k; ll dp[N][N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i].w\u0026gt;\u0026gt;a[i].v; sort(a+1,a+1+n); for(int i=1;i\u0026lt;=n;i++){ for(int j=m;j\u0026gt;=0;j--){ if(j\u0026gt;=a[i].w){ dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[i].w]+a[i].v); } else dp[i][j]=dp[i-1][j]; } } ll ans=0,sum=0; multiset\u0026lt;int\u0026gt;s; if(k){ for(int i=n-k+1;i\u0026lt;=n;i++){ sum+=a[i].v; s.insert(a[i].v); } ans=dp[n-k][m]+sum; for(int i=n-k;i\u0026gt;0;i--){ if(a[i].v\u0026gt;*s.begin()){ sum-=*s.begin(); sum+=a[i].v;; s.erase(s.begin()); s.insert(a[i].v); } ans=max(ans,dp[i-1][m]+sum); } }else ans=dp[n][m]; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } F - Equivalent Rewriting æ¯ä¸€ä½çš„å€¼å®é™…æ˜¯ç”±æœ€åä¸€æ¬¡æ“ä½œä»–çš„æ“ä½œå†³å®šçš„ï¼Œ$n$ ä¸ªæ“ä½œæœ¬èº«æ„æˆäº† $1~n$ çš„æ‹“æ‰‘åº\nåªéœ€æ£€æŸ¥æ¯ä¸€ä½çš„æ‰€æœ‰æ“ä½œï¼Œçœ‹æ˜¯å¦æœ‰ç›¸é‚»çš„æ“ä½œå¤„äºé‡Œé¢ï¼Œå¦‚æœæœ‰ï¼Œé‚£ä¹ˆè¿™ä¸ª $i \\rightarrow i+1$ è¿™ä¸ªåºåˆ—å°±æ˜¯ä¸å¯è¢«æ›´æ”¹çš„ï¼Œæ£€æŸ¥å®Œä¹‹åå¦‚æœæœ‰æ²¡è¢«æ ‡è®°è¿‡çš„å³å¯äº¤æ¢ä»–ä»¬çš„ä½ç½®ï¼Œè¾“å‡ºå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+7; vector\u0026lt;int\u0026gt; a[N]; int ans[N]; bool vis[N]; void solve(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;++i) { ans[i]=i; int k; cin\u0026gt;\u0026gt;k; for(int j=1;j\u0026lt;=k;++j) { int x; cin\u0026gt;\u0026gt;x; a[x].push_back(i); } } for(int i=1;i\u0026lt;=m;++i) { if(a[i].empty()) continue; int x=a[i].back(); for(auto y:a[i]) { if(y==x-1) vis[y]=1; } } bool flag=0; for(int i=1;i\u0026lt;n;++i) { if(!vis[i]) {swap(ans[i],ans[i+1]);flag=1;break;} } if(!flag) cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; else { cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; for(int i=1;i\u0026lt;=n;++i) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } for(int i=1;i\u0026lt;=n;++i) vis[i]=0; for(int i=1;i\u0026lt;=m;++i) a[i].clear(); } int main(){ ios::sync_with_stdio(0); cin.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } A - Cool, Itâ€™s Yesterday Four Times More å› ä¸º $n*m$ çš„æ•°é‡çº§å¾ˆå°ï¼Œå¯ä»¥è€ƒè™‘å¾ˆæš´åŠ›çš„åšæ³•\næˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª $(x,y,i,j)$ è®°å½•ä½äº $(x,y)$ çš„è¢‹é¼ èƒ½å¦è¸¢æ‰ä½äº $(i,j)$ çš„è¢‹é¼ ï¼ŒåŒæ—¶æ˜“æƒ³åˆ°ä½äºåŒä¸€ä¸ªè”é€šå—çš„è¢‹é¼ ï¼Œèƒ½å¦è·èƒœæ˜¯ä¸€æ ·çš„\nè¦è®°å½• $(x,y,i,j)$ ä¸èƒ½ç›´æ¥ä½¿ç”¨ $map$ æ¥å­˜å–ï¼Œè¿™æ ·ä¼šä½¿æ—¶é—´å¤æ‚åº¦é™¡å‡ï¼Œè¦å°†è¿™ $4$ ä¸ªæ•°è½¬æ¢ä¸ºä¸€ä¸ªæ•°ï¼Œä»è€Œè¾¾åˆ° $O(1)$ çš„æŸ¥è¯¢\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#39;\\n\u0026#39; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int n,m; char mp[N][N]; int vis[N*N]; bool flag[N*N]; int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0}; int gao(int i, int j, int r, int c) { //æ­¤å¤„å³ä¸ºè½¬æ¢å‡½æ•° return i * m * n * m + j * n * m + r * m + c; } void ungao(int msk, int \u0026amp;i, int \u0026amp;j, int \u0026amp;r, int \u0026amp;c) { //æ­¤å¤„ä¸ºè¿˜åŸå‡½æ•° i = msk / (m * n * m); j = msk / (n * m) % m; r = msk / m % n; c = msk % m; } bool die(int x,int y){ return (x\u0026lt;0||y\u0026lt;0||x\u0026gt;=n||y\u0026gt;=m||mp[x][y]==\u0026#39;O\u0026#39;); } void bfs(int s){ queue\u0026lt;int\u0026gt;q; q.push(s); vis[s]=s; flag[s]=0; while(q.size()){ int now=q.front(); q.pop(); int x,y,a,b; ungao(now, x, y, a, b); for(int i=0;i\u0026lt;4;i++){ int xx=x+dx[i],yy=y+dy[i]; int aa=a+dx[i],bb=b+dy[i]; if(die(xx,yy))continue; if(die(aa,bb)){ flag[s]=1; continue; } int nxt = gao(xx, yy, aa, bb); if(vis[nxt]\u0026gt;=0)continue; q.push(nxt); vis[nxt]=s; } } } bool check(int x,int y){ for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ if(mp[i][j]==\u0026#39;.\u0026#39;){ if(i==x\u0026amp;\u0026amp;j==y)continue; int state = gao(x, y, i, j); if(vis[state]==-1)bfs(state); if(!flag[vis[state]])return 0; } } } return 1; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++)cin\u0026gt;\u0026gt;mp[i][j]; memset(vis,-1,sizeof(vis)); memset(flag,0,sizeof(flag)); int ans=0; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) if(mp[i][j]==\u0026#39;.\u0026#39;)ans+=check(i,j); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } L - Elevator åæ€ç»´ï¼Œè´§ç‰©ä½“ç§¯åªæœ‰ $1$ å’Œ $2$ è¿™ä¸¤ç§æƒ…å†µï¼Œå¯ä»¥å°†ä½“ç§¯ä¸º $2$ çš„è½¬åŒ–ä¸ºä¸¤ä¸ªä½“ç§¯ä¸º $1$ çš„æ¥è¿›è¡Œå¤„ç†\nè¯æ˜å¦‚ä¸‹\nå¦‚æœæ¯ä¸€è¶Ÿéƒ½èƒ½å¡«æ»¡ $k$ï¼Œé‚£ä¹ˆè½¬åŒ–å‰å’Œè½¬åŒ–åçš„ç»“æœç›¸åŒ å¦‚æœå‡ºç°äº†å‰©ä¸‹ä½“ç§¯ä¸º $1$ï¼Œä½†æ˜¯ä¸‹ä¸€ä¸ªç‰©å“ä½“ç§¯ä¸º $2$ï¼Œæˆ‘ä»¬ä¼šè·³è¿‡å½“å‰ç‰©å“ï¼Œå‘ä¸‹å¯»æ‰¾ä½“ç§¯ä¸º $1$ çš„ç‰©å“ ç”±å›¾å¯çŸ¥ï¼Œè¿™æ ·çš„å¡«å……å¹¶ä¸ä¼šå¯¹ç­”æ¡ˆé€ æˆå½±å“\næ‰€ä»¥åªéœ€å°†æ‰€æœ‰çš„ç‰©å“æŒ‰æ¥¼å±‚é«˜åº¦é™åºæ’ï¼Œä»é«˜åˆ°ä½æ¯æ¬¡é€‰å¤Ÿ $k$ ä¸ªç‰©å“ï¼Œç­”æ¡ˆæ¯æ¬¡åŠ å½“å‰æœ€é«˜æ¥¼å±‚å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; ll n,k; vector\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;w; void solve(){ w.clear(); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ ll x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; w.push_back({z,x*y}); } sort(w.begin(),w.end(),greater\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;()); ll ans=0,now=w[0].first,lst=0; for(auto [x,y]:w){ if(lst){ if(k\u0026gt;lst+y){ lst+=y; continue; } y-=(k-lst); ans+=now; now=x; ll t=y/k; ans+=now*t; lst=y%k; } else{ now=x; ll t=y/k; ans+=t*now; lst=y%k; } } if(lst)ans+=now; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } M - Trapping Rain Water æ ¹æ®é¢˜ç›®ç»™å‡ºçš„å…¬å¼æ ¼å¼å¯ä»¥å¾—åˆ° $\\sum_{i=1}^nf_i+\\sum_{i=1}^ng_i-n\\times\\max a_i-\\sum_{i=1}^na_i$\néš¾ç‚¹åœ¨äºå¦‚ä½•ç»´æŠ¤ $\\sum_{i=1}^nf_i$ å’Œ $\\sum_{i=1}^ng_i$\n$f,g$ éƒ½æ˜¯å•è°ƒçš„åºåˆ—ï¼Œå¯ä»¥å‘ç°ï¼ŒäºŒè€…éƒ½æ˜¯è¿ç»­ç›¸åŒçš„ç‰‡æ®µï¼Œå³ç‰‡æ®µä¼šä»¥å½“å‰ç‰‡æ®µå¼€å¤´ä¸ºæœ€å¤§å€¼å­˜åœ¨\nè¿™æ ·ï¼Œæˆ‘ä»¬ç»´æŠ¤è¿™äº›ç‰‡æ®µå°±åªéœ€è¦ç”¨ $set$ æ¥æ“ä½œå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define pil pair\u0026lt;int,long long\u0026gt; typedef long long ll; const int N=1e5+7, mod=1e9+7; const ll inf=1e18; int n, q; ll A[N]; ll fA[N], fsm; set\u0026lt;pil\u0026gt; fst; ll gA[N], gsm; set\u0026lt;pil\u0026gt; gst; void clear(ll A[], ll \u0026amp;sm, set\u0026lt;pil\u0026gt; \u0026amp;st) { memset(A, 0, sizeof(ll) * (n + 3)); sm = 0; st.clear(); st.insert(pil(1, 0)); st.insert(pil(n + 1, inf)); } void update(ll A[], ll \u0026amp;sm, set\u0026lt;pil\u0026gt; \u0026amp;st, int x, ll v) { A[x] += v; auto it = prev(st.upper_bound(pil(x, inf))); if (it-\u0026gt;second \u0026gt;= A[x]) return; sm -= (next(it)-\u0026gt;first - it-\u0026gt;first) * it-\u0026gt;second; sm += (x - it-\u0026gt;first) * it-\u0026gt;second + (next(it)-\u0026gt;first - x) * A[x]; it = st.insert(pil(x, A[x])).first; while (next(it)-\u0026gt;second \u0026lt;= A[x]) { sm -= (next(it)-\u0026gt;first - x) * A[x] + (next(next(it))-\u0026gt;first - next(it)-\u0026gt;first) * next(it)-\u0026gt;second; st.erase(next(it)); sm += (next(it)-\u0026gt;first - x) * A[x]; } } void solve() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); ll mx = 0, sm = 0; for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;A[i]); mx = max(mx, A[i]); sm += A[i]; } clear(fA, fsm, fst); clear(gA, gsm, gst); for (int i = 1; i \u0026lt;= n; i++) { update(fA, fsm, fst, i, A[i]); update(gA, gsm, gst, n + 1 - i, A[i]); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;q); while (q--) { int x, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;v); A[x] += v; mx = max(mx, A[x]); sm += v; update(fA, fsm, fst, x, v); update(gA, gsm, gst, n + 1 - x, v); printf(\u0026#34;%lld\\n\u0026#34;, fsm + gsm - n * mx - sm); } } int main() { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/icpc2023nanjing/","summary":"ä¸å°‘æ„Ÿè§‰èƒ½å†™çš„ï¼Œå¯æƒœäº†","title":"ICPC 2023 å—äº¬ VP"},{"content":"æ ‘ä¸Š DP é¡¾åæ€ä¹‰ï¼Œåœ¨æ ‘ä¸Šè¿›è¡Œçš„ DPï¼Œä¸€èˆ¬é€šè¿‡é€’å½’è¿›è¡Œ\nä¸€èˆ¬å¼€ $f_{i,j}$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹çš„å­æ ‘çš„æœ€ä¼˜è§£ï¼Œç¬¬äºŒç»´è¡¨ç¤ºé€‰ä¸é€‰ $i$\næ´›è°· æ²¡æœ‰ä¸Šå¸çš„èˆä¼š P1352 é¢˜ç›® æŸå¤§å­¦æœ‰ $n$ ä¸ªèŒå‘˜ï¼Œç¼–å·ä¸º $1\\ldots n$ã€‚\nä»–ä»¬ä¹‹é—´æœ‰ä»å±å…³ç³»ï¼Œä¹Ÿå°±æ˜¯è¯´ä»–ä»¬çš„å…³ç³»å°±åƒä¸€æ£µä»¥æ ¡é•¿ä¸ºæ ¹çš„æ ‘ï¼Œçˆ¶ç»“ç‚¹å°±æ˜¯å­ç»“ç‚¹çš„ç›´æ¥ä¸Šå¸ã€‚\nç°åœ¨æœ‰ä¸ªå‘¨å¹´åº†å®´ä¼šï¼Œå®´ä¼šæ¯é‚€è¯·æ¥ä¸€ä¸ªèŒå‘˜éƒ½ä¼šå¢åŠ ä¸€å®šçš„å¿«ä¹æŒ‡æ•° $r_i$ï¼Œä½†æ˜¯å‘¢ï¼Œå¦‚æœæŸä¸ªèŒå‘˜çš„ç›´æ¥ä¸Šå¸æ¥å‚åŠ èˆä¼šäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªèŒå‘˜å°±æ— è®ºå¦‚ä½•ä¹Ÿä¸è‚¯æ¥å‚åŠ èˆä¼šäº†ã€‚\næ‰€ä»¥ï¼Œè¯·ä½ ç¼–ç¨‹è®¡ç®—ï¼Œé‚€è¯·å“ªäº›èŒå‘˜å¯ä»¥ä½¿å¿«ä¹æŒ‡æ•°æœ€å¤§ï¼Œæ±‚æœ€å¤§çš„å¿«ä¹æŒ‡æ•°ã€‚\nè§£å†³ è®¾ $f_{i,j}$ ä»£è¡¨ä»¥ $i$ ä¸ºæ ¹çš„å­æ ‘çš„æœ€ä¼˜è§£ï¼Œ$j$ ç”¨ $0,1$ æ¥è¡¨ç¤ºå–ä¸å– $i$ è¿™ä¸ªäºº\nå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œéƒ½æœ‰ä¸¤ç§å†³ç­–\nä¸å–å½“å‰èŠ‚ç‚¹ï¼Œä»–çš„å­èŠ‚ç‚¹éƒ½å¯ä»¥å–ï¼Œæˆ–ä¸å–ï¼Œ$f_{i,0} = \\sum_{x \\in \\text{child}(i)} \\max(f_{x,0}, f_{x,1})$\nå–å½“å‰èŠ‚ç‚¹ï¼Œä»–çš„å­èŠ‚ç‚¹éƒ½ä¸èƒ½å–ï¼Œ$f_{i,0} = \\sum_{x \\in \\text{child}(i)}f_{x,0}+a_i$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; vector\u0026lt;int\u0026gt; edge[N]; int a[N],n,cnt,f[N][2],ans; bool vis[N]; void dfs(int now) { f[now][0] = 0; f[now][1] = a[now]; for (int i = 0; i \u0026lt; (int)edge[now].size(); i++) { int to = edge[now][i]; dfs(to); f[now][0] += max(f[to][0], f[to][1]); f[now][1] += f[to][0]; } } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; edge[y].push_back(x); vis[x]=1; } int root=0; for(int i=1;i\u0026lt;=n;i++){ if(!vis[i]){ root=i; break; } } dfs(root); cout\u0026lt;\u0026lt;max(f[root][0],f[root][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } CF Sheriff\u0026rsquo;s Defense 2014F é¢˜ç›® ç»™å®šä¸€å¼  $n$ ç»“ç‚¹ $n - 1$ æ¡è¾¹çš„æœ‰ç‚¹æƒçš„æ ‘ã€‚åˆå§‹æ¯ä¸ªç»“ç‚¹éƒ½æ˜¯é»‘è‰²ã€‚\nä½ å¯ä»¥æ‰§è¡Œä»»æ„æ¬¡ä»¥ä¸‹æ“ä½œï¼šå°†ä¸€ä¸ªé»‘ç‚¹æŸ“æˆç™½è‰²ï¼Œå¹¶å°†æ‰€æœ‰ä¸å®ƒç›¸é‚»çš„ç»“ç‚¹çš„æƒå€¼å‡å» $c$ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰ã€‚\næœ€å¤§åŒ–å…¨éƒ¨ç™½ç‚¹çš„æƒå€¼ä¹‹å’Œã€‚\nè§£å†³ ç”¨ $f_{u,j}$ è®°å½•ï¼ŒåŒä¸Šä¸€é¢˜\nè®¾è®¡çŠ¶æ€ $f_{u,0}$ è¡¨ç¤ºåœ¨ä»¥ $u$ ä¸ºæ ¹çš„å­æ ‘ä¸‹ï¼Œä¸é€‰æ‹© $u$ æ‰€èƒ½è·å¾—çš„æœ€å¤§ä»·å€¼ï¼Œåˆå§‹å€¼ä¸º $0$ï¼›\n$f_{u,1}$ è¡¨ç¤ºåœ¨ä»¥ $u$ ä¸ºæ ¹çš„å­æ ‘ä¸‹ï¼Œé€‰æ‹© $u$ æ‰€èƒ½è·å¾—çš„æœ€å¤§ä»·å€¼ï¼Œåˆå§‹å€¼ä¸º $a_u$ã€‚\nå¦‚æœæŸä¸ªç‚¹ä¸é€‰ï¼Œé‚£å®ƒä¸ä¼šå¯¹ç»“æœé€ æˆå½±å“\nè‹¥ä¸é€‰ $u$ åˆ™ $$ f_{u,0} = f_{u,0} + \\max(f_{v,0}, f_{v,1}) $$ è‹¥é€‰ $u$ åˆ™ $$ f_{u,1} = f_{u,1} + \\max(f_{v,0}, f_{v,1} - c \\times 2) $$ å¦‚æœé€‰ $v$ é‚£ä»–ä¼šå¯¹ $u-\u0026gt;v$ å’Œ $v-\u0026gt;u$ è¿™ä¸¤æ¡è·¯å¾„é€ æˆæ¶ˆè€—æ‰€ä»¥è¦å‡ä¸¤ä¸ª $c$ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,c,s,ans; ll dp[N][2]; vector\u0026lt;int\u0026gt;edge[N]; bool vis[N]; void dfs(int now,int fa){ for(auto i:edge[now]){ if(i!=fa){ dfs(i,now); dp[now][0]+=max(dp[i][0],dp[i][1]); dp[now][1]+=max(dp[i][0],dp[i][1]-(c\u0026lt;\u0026lt;1)); } } } void solve(){ ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c; for(int i=1;i\u0026lt;=n;i++){ edge[i].clear(); cin\u0026gt;\u0026gt;dp[i][1]; dp[i][0]=0; vis[i]=0; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); cout\u0026lt;\u0026lt;max(dp[1][0],dp[1][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æ ‘ä¸ŠèƒŒåŒ… å³èƒŒåŒ…é—®é¢˜å’Œæ ‘ä¸Š DP çš„ç»“åˆ\næ´›è°· CTSC1997 é€‰è¯¾ P2014 é¢˜ç›® åœ¨å¤§å­¦é‡Œæ¯ä¸ªå­¦ç”Ÿï¼Œä¸ºäº†è¾¾åˆ°ä¸€å®šçš„å­¦åˆ†ï¼Œå¿…é¡»ä»å¾ˆå¤šè¯¾ç¨‹é‡Œé€‰æ‹©ä¸€äº›è¯¾ç¨‹æ¥å­¦ä¹ ï¼Œåœ¨è¯¾ç¨‹é‡Œæœ‰äº›è¯¾ç¨‹å¿…é¡»åœ¨æŸäº›è¯¾ç¨‹ä¹‹å‰å­¦ä¹ ï¼Œå¦‚é«˜ç­‰æ•°å­¦æ€»æ˜¯åœ¨å…¶å®ƒè¯¾ç¨‹ä¹‹å‰å­¦ä¹ ã€‚ç°åœ¨æœ‰ $N$ é—¨åŠŸè¯¾ï¼Œæ¯é—¨è¯¾æœ‰ä¸ªå­¦åˆ†ï¼Œæ¯é—¨è¯¾æœ‰ä¸€é—¨æˆ–æ²¡æœ‰ç›´æ¥å…ˆä¿®è¯¾ï¼ˆè‹¥è¯¾ç¨‹ $a$ æ˜¯è¯¾ç¨‹ $b$ çš„å…ˆä¿®è¯¾å³åªæœ‰å­¦å®Œäº†è¯¾ç¨‹ $a$ï¼Œæ‰èƒ½å­¦ä¹ è¯¾ç¨‹ $b$ï¼‰ã€‚ä¸€ä¸ªå­¦ç”Ÿè¦ä»è¿™äº›è¯¾ç¨‹é‡Œé€‰æ‹© $M$ é—¨è¯¾ç¨‹å­¦ä¹ ï¼Œé—®ä»–èƒ½è·å¾—çš„æœ€å¤§å­¦åˆ†æ˜¯å¤šå°‘ï¼Ÿ\nè§£å†³ æ–°å¢ä¸€ä¸ª $0$ å­¦åˆ†çš„å¿…ä¿®è¯¾ï¼Œä½œä¸ºæ‰€æœ‰æ— å‰é€‰è¯¾çš„è¯¾çš„å‰é€‰è¯¾ï¼Œè¿™æ ·å°±èƒ½æ„å»ºå‡ºä¸€é¢—ä»¥æ–°å¢èŠ‚ç‚¹ä¸ºæ ¹çš„æ ‘\nè®¾ $f_{i,j}$ ä¸ºç¬¬ $i$ ä¸ªèŠ‚ç‚¹ï¼Œ$j$ ä¸ºèƒŒåŒ…å®¹é‡\nåˆå§‹å€¼ä¸º $f_{i,0} = s_{i}$\né€’å½’æ¯é¢—å­æ ‘\næ¯æ¬¡é€’å½’è®°å½•å½“å‰èƒŒåŒ…å®¹é‡ï¼Œå’Œå½“å‰æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e4 + 7, mod = 1e9 + 7; int n, m, f[N][N]; vector\u0026lt;int\u0026gt; edge[N]; int s[N]; int dfs(int x) { if (edge[x].empty()) return 0; int sum = 0; for (int i : edge[x]) { int t = dfs(i); sum += t + 1; for (int j = sum; j \u0026gt;= 0; j--) { for (int k = 0; k \u0026lt;= t; k++) { if (j - k - 1 \u0026gt;= 0) f[x][j] = max(f[x][j], f[x][j - k - 1] + f[i][k]); } } } return sum; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { int k; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; s[i]; edge[k].push_back(i); } for (int i = 1; i \u0026lt;= n; i++) f[i][0] = s[i]; f[0][0] = 0; dfs(0); cout \u0026lt;\u0026lt; f[0][m] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } æ¢æ ¹ DP åˆè¢«ç§°ä¸ºäºŒæ¬¡æ‰«æï¼Œé€šå¸¸ä¸æŒ‡å®šæ ¹èŠ‚ç‚¹ï¼ŒåŒæ—¶æ ¹èŠ‚ç‚¹çš„å˜åŒ–ä¼šä½¿ä¸€äº›å€¼å‘ç”Ÿå˜åŒ–ï¼Œä¾‹å¦‚å­èŠ‚ç‚¹æ·±åº¦å’Œï¼Œç‚¹æƒå’Œç­‰\né€šå¸¸ä¸¤æ¬¡ DFSï¼Œç¬¬ä¸€æ¬¡é¢„å¤„ç†æ·±åº¦ï¼Œç‚¹æƒå’Œç­‰ä¿¡æ¯ï¼Œç¬¬äºŒæ¬¡ DFS è¿›è¡Œ DP\næ´›è°· STA-Station P3478 é¢˜ç›® ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹çš„æ ‘ï¼Œè¯·æ±‚å‡ºä¸€ä¸ªç»“ç‚¹ï¼Œä½¿å¾—ä»¥è¿™ä¸ªç»“ç‚¹ä¸ºæ ¹æ—¶ï¼Œæ‰€æœ‰ç»“ç‚¹çš„æ·±åº¦ä¹‹å’Œæœ€å¤§ã€‚\nä¸€ä¸ªç»“ç‚¹çš„æ·±åº¦ä¹‹å®šä¹‰ä¸ºè¯¥èŠ‚ç‚¹åˆ°æ ¹çš„ç®€å•è·¯å¾„ä¸Šè¾¹çš„æ•°é‡ã€‚\nè§£å†³ ä¸å¦¨ä»¤ $u$ ä¸ºå½“å‰ç»“ç‚¹ï¼Œ$v$ ä¸ºå½“å‰ç»“ç‚¹çš„å­ç»“ç‚¹ã€‚é¦–å…ˆéœ€è¦ç”¨ $s_i$ æ¥è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹çš„å­æ ‘ä¸­çš„ç»“ç‚¹ä¸ªæ•°ï¼Œå¹¶ä¸”æœ‰ $s_u = 1 + \\sum s_v$ã€‚æ˜¾ç„¶éœ€è¦ä¸€æ¬¡ DFS æ¥è®¡ç®—æ‰€æœ‰çš„ $s_i$ï¼Œè¿™æ¬¡çš„ DFS å°±æ˜¯é¢„å¤„ç†ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä»¥æŸä¸ªç»“ç‚¹ä¸ºæ ¹æ—¶å…¶å­æ ‘ä¸­çš„ç»“ç‚¹æ€»æ•°ã€‚\nè€ƒè™‘çŠ¶æ€è½¬ç§»ï¼Œè¿™é‡Œå°±æ˜¯ä½“ç°â€œæ¢æ ¹â€çš„åœ°æ–¹äº†ã€‚ä»¤ $f_u$ ä¸ºä»¥ $u$ ä¸ºæ ¹æ—¶ï¼Œæ‰€æœ‰ç»“ç‚¹çš„æ·±åº¦ä¹‹å’Œã€‚\n$f_v \\leftarrow f_u$ å¯ä»¥ä½“ç°æ¢æ ¹ï¼Œå³ä»¥ $u$ ä¸ºæ ¹è½¬ç§»åˆ°ä»¥ $v$ ä¸ºæ ¹ã€‚æ˜¾ç„¶åœ¨æ¢æ ¹çš„è½¬ç§»è¿‡ç¨‹ä¸­ï¼Œä»¥ $v$ ä¸ºæ ¹æˆ–ä»¥ $u$ ä¸ºæ ¹ä¼šå¯¼è‡´å…¶å­æ ‘ä¸­çš„ç»“ç‚¹çš„æ·±åº¦äº§ç”Ÿæ”¹å˜ã€‚å…·ä½“è¡¨ç°ä¸ºï¼š\næ‰€æœ‰åœ¨ $v$ çš„å­æ ‘ä¸Šçš„ç»“ç‚¹æ·±åº¦éƒ½å‡å°‘äº† $1$ï¼Œé‚£ä¹ˆæ€»æ·±åº¦å’Œå°±å‡å°‘äº† $s_v$ï¼› æ‰€æœ‰ä¸åœ¨ $v$ çš„å­æ ‘ä¸Šçš„ç»“ç‚¹æ·±åº¦éƒ½å¢åŠ äº† $1$ï¼Œé‚£ä¹ˆæ€»æ·±åº¦å’Œå°±å¢åŠ äº† $n - s_v$ï¼› æ ¹æ®è¿™ä¸¤ä¸ªæ¡ä»¶å°±å¯ä»¥æ¨å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\n$$ f_v = f_u - s_v + n - s_v = f_u + n - 2 \\times s_v $$\näºæ˜¯åœ¨ç¬¬äºŒæ¬¡ DFS éå†æ•´æ£µæ ‘å¹¶çŠ¶æ€è½¬ç§» $f_v = f_u + n - 2 \\times s_v$ï¼Œé‚£ä¹ˆå°±èƒ½æ±‚å‡ºä»¥æ¯ä¸ªç»“ç‚¹ä¸ºæ ¹æ—¶çš„æ·±åº¦å’Œäº†ã€‚æœ€ååªéœ€è¦éå†ä¸€æ¬¡æ‰€æœ‰æ ¹ç»“ç‚¹æ·±åº¦å’Œå°±å¯ä»¥æ±‚å‡ºç­”æ¡ˆã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e6+7, mod=1e9+7; vector\u0026lt;int\u0026gt;edge[N]; ll n; ll f[N],sz[N],dep[N]; void dfs(int u,int fa){ sz[u]=1; dep[u]=dep[fa]+1; for(auto v:edge[u]){ if(v==fa)continue; dfs(v,u); sz[u]+=sz[v]; } } void ans(int u,int fa){ f[u]=f[fa]+n-sz[u]-sz[u]; for(auto v:edge[u]){ if(v==fa)continue; ans(v,u); } } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,1); for(int i=1;i\u0026lt;=n;i++){ f[1]+=dep[i]; } ans(1,1); ll res=-1; int now; for(int i=1;i\u0026lt;=n;i++){ if(f[i]\u0026gt;res){ res=f[i]; now=i; } } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/treedp/","summary":"æ ‘å½¢ DP å­¦ä¹ è®°å½•","title":"æ ‘å½¢DP"},{"content":"A Robin Helps æŒ‰é¢˜æ„æ¨¡æ‹Ÿ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,ans,a[N],cnt,k; void solve(){ cnt=ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026gt;=k)cnt+=a[i]; if(!a[i]\u0026amp;\u0026amp;cnt)cnt--,ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B. Robin Hood and the Major Oak æ˜¾ç„¶åªæœ‰æœ€å $k$ ä¸ªç‚¹æœ‰æ•ˆï¼Œ$i^i$ çš„å¥‡å¶æ€§åªå’Œ $i$ æœ‰å…³ï¼Œå…¬å¼åŠ å’Œå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#39;\\n\u0026#39; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; ll n, k; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; ll s = (n - k + 1 + n) * k / 2; if (s % 2 == 1) cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } C. Robin Hood in Town äºŒåˆ†ç­”æ¡ˆï¼Œæ¯æ¬¡éƒ½æŠŠåŠ çš„é‡‘é’±ç»™åˆ°å½“å‰é’±æœ€å¤šçš„äººï¼Œä¸€å®šæ˜¯æœ€å°ç­”æ¡ˆï¼Œå†äºŒåˆ†æŸ¥æ‰¾æ•°ç»„ä¸­å¤§äºç­‰äºå½“å‰å¹³å‡å€¼çš„ä½ç½®ï¼Œçœ‹æ˜¯å¦åœ¨ä¸­é—´å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e5 + 7; int n, a[N]; bool check(ll f,ll sum) { a[n]+=f; if(lower_bound(a+1,a+1+n,(sum+f)/2.0/n)-a-1\u0026gt;(n\u0026gt;\u0026gt;1)){ a[n]-=f; return true; } a[n]-=f; return false; } void solve() { ll sum = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum += a[i]; } if (n \u0026lt; 3) { cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; return; } sort(a + 1, a + 1 + n); ll l = 0, r = 1e18, ans = 0; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid, sum)) { ans = mid; r = mid - 1; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D. Robert Hood and Mrs Hood å·¨çœ¼ç†Ÿé¢˜ï¼Œä½†è¿˜æ˜¯æƒ³äº†åŠå¤©\nå…ˆæ’åº $l,r$ï¼Œä¼˜å…ˆæ’ $l$ï¼Œç„¶åå¼€ä¸€ä¸ª $vis$ ç”¨äºè®°å½•åœ¨ $i$ å¤©ç»“æŸçš„å·¥ä½œæœ‰å‡ ä¸ª\nä»ç¬¬ä¸€å¤©å¼€å§‹ï¼Œçœ‹æœ‰å‡ ä¸ªåœ¨å‘¨æœŸå†…çš„ä»»åŠ¡ï¼Œå½“å‰åˆ°è®¿æ—¶é—´çš„ç­”æ¡ˆå³ä¸ºè¿™ä¸ªä»»åŠ¡æ•°\nå‘ä¸‹è¿›è¡Œï¼Œè¦å…ˆå‡å»å‰ä¸€å¤©ç»“æŸçš„ä»»åŠ¡æ•°ï¼Œå†ç»§ç»­å‘ä¸‹æ‰¾ç¬¦åˆæ¡ä»¶çš„ä»»åŠ¡\næ—¶é—´å¤æ‚åº¦æ˜¯ $O(n+k)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; struct Node { int l, r; bool operator\u0026lt;(const Node \u0026amp;a) const { return (l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l); } }; int n, d, k, mx, mn; Node a[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= k; i++) { cin \u0026gt;\u0026gt; a[i].l \u0026gt;\u0026gt; a[i].r; } int ans[N] = {0}; int vis[N] = {0}; int now = 1, tmp = 0; sort(a + 1, a + 1 + k); for (int i = 1; i \u0026lt;= n - d + 1; i++) { if (i \u0026gt; 1 \u0026amp;\u0026amp; vis[i - 1]) tmp -= vis[i - 1]; while (now \u0026lt;= k \u0026amp;\u0026amp; i + d - 1 \u0026gt;= a[now].l \u0026amp;\u0026amp; i \u0026lt;= a[now].r) { tmp++; vis[a[now].r]++; now++; } ans[i] = tmp; } mx = mn = 1; for (int i = 2; i \u0026lt;= n - d + 1; i++) { if (ans[mx] \u0026lt; ans[i]) mx = i; if (ans[mn] \u0026gt; ans[i]) mn = i; } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; mn \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E. Rendez-vous de Marian et Robin æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œå¯ä»¥æƒ³åˆ°ç”¨ $dijkstra$ è§£å†³\nå¯ä»¥çœ‹å‡ºåˆ†ä¸ºä¸¤ç§çŠ¶æ€ï¼Œéª‘é©¬å’Œæ­¥è¡Œ\nå¼€ä¸¤ä¸ª $dist$ æ•°ç»„ï¼Œåˆ†åˆ«è®°å½•ä» $1,n$ ä¸ºèµ·ç‚¹çš„ $dijkstra$\n$dist$ è¦åˆ†åˆ«è®°å½•æœ‰é©¬ï¼Œæ²¡é©¬çŠ¶æ€ä¸‹çš„å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=4e5+7, mod=1e9+7; int n, m, h, dist1[N], dist2[N], inf=1e18; bool vis[N], p[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; edge[N]; void dijkstra(int s, int dist[]) { for (int i = 1; i \u0026lt;= n * 2; i++) dist[i] = inf; for (int i = 1; i \u0026lt;= n * 2; i++) vis[i] = 0; dist[s] = 0; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.insert({0, s}); if (p[s]) { dist[n + s] = 0; q.insert({0, n + s}); } while (!q.empty()) { int u = q.begin()-\u0026gt;second; q.erase(q.begin()); if (vis[u]) continue; vis[u] = 1; int t = (u \u0026gt; n ? u - n : u); for (auto [v, w] : edge[t]) { if (u \u0026gt; n) { if (dist[v + n] \u0026gt; dist[u] + w / 2) { dist[v + n] = dist[u] + w / 2; if (!vis[v + n]) q.insert({dist[v + n], v + n}); } } else { if (p[v]) { if (dist[v + n] \u0026gt; dist[u] + w) { dist[v + n] = dist[u] + w; if (!vis[v + n]) q.insert({dist[v + n], v + n}); } } else { if (dist[v] \u0026gt; dist[u] + w) { dist[v] = dist[u] + w; if (!vis[v]) q.insert({dist[v], v}); } } } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; h; for (int i = 1; i \u0026lt;= n; i++) p[i] = 0, edge[i].clear(); for (int i = 1; i \u0026lt;= h; i++) { int x; cin \u0026gt;\u0026gt; x; p[x] = 1; } for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; edge[u].push_back({v, w}); edge[v].push_back({u, w}); } int ans = inf; dijkstra(1, dist1); dijkstra(n, dist2); for (int i = 1; i \u0026lt;= n; i++) { ans = min(ans, max(min(dist1[i], dist1[i + n]), min(dist2[i], dist2[i + n]))); } if (ans == inf) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } F. Sheriff\u0026rsquo;s Defense æ ‘å½¢ dp, çŠ¶æ€ $dp[i][j]$ è¡¨ç¤ºé€‰ä¸é€‰ $i$ å·èŠ‚ç‚¹\nç±»ä¼¼æ²¡æœ‰ä¸Šå¸çš„èˆä¼š\næ˜å¤©å†™ç¯‡æ ‘å½¢ dp çš„å­¦ä¹ è®°å½•\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,c,s,ans; ll dp[N][2]; vector\u0026lt;int\u0026gt;edge[N]; bool vis[N]; void dfs(int now,int fa){ for(auto i:edge[now]){ if(i!=fa){ dfs(i,now); dp[now][0]+=max(dp[i][0],dp[i][1]); dp[now][1]+=max(dp[i][0],dp[i][1]-(c\u0026lt;\u0026lt;1)); } } } void solve(){ ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c; for(int i=1;i\u0026lt;=n;i++){ edge[i].clear(); cin\u0026gt;\u0026gt;dp[i][1]; dp[i][0]=0; vis[i]=0; } for(int i=1;i\u0026lt;n;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; edge[u].push_back(v); edge[v].push_back(u); } dfs(1,0); cout\u0026lt;\u0026lt;max(dp[1][0],dp[1][1])\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } åä¸¤é¢˜æ„Ÿè§‰æœ‰ç‚¹å¯å†™ï¼Œåé¢å†è¡¥ã€‚ã€‚ã€‚\nH. Robin Hood Archery è¿™é¢˜å‡­ä»€ä¹ˆå½“ H\næ˜¾ç„¶åæ‰‹è€…ä¸å¯èƒ½èƒœï¼Œå› ä¸ºæ¯æ¬¡éƒ½æ˜¯å–å½“å‰æœ€å¤§å€¼ï¼Œé‚£ä¹ˆåæ‰‹ä¸è¾“çš„å”¯ä¸€æœºä¼šå°±æ˜¯å¹³å±€\nå¥‡æ•°ä¸ªæ•°çš„æ—¶å€™ï¼Œä¸€å®šä¼šè¾“ã€‚\nå¶æ•°ä¸ªæ•°çš„æ—¶å€™ï¼Œå¦‚æœå‡ºç°çš„æ•°éƒ½å‡ºç°äº†å¶æ•°æ¬¡ï¼Œé‚£ä¹ˆå°±èƒ½æ‰“æˆå¹³å±€\nç›´æ¥å¼‚æˆ–çš„è¯ï¼Œå¯èƒ½è¢«æŸäº›æ•°æ® hack æ‰ï¼Œæ‰€ä»¥è¦åŠ ä¸Šå“ˆå¸Œ\néšæœºæ•°ç”Ÿæˆå°½é‡ä¸è¦ç”¨ time(0) è¿™äº›ä¸å¤Ÿéšæœºçš„æ•°\nä½¿ç”¨ random_device æˆ– chrono::system_clock::now().time_since_epoch().count() æ¥ç”Ÿæˆé«˜è´¨é‡çš„éšæœºæ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e6+7, mod=1e9+7; int n,q,x; int a[N],s[N]; int l,r; random_device rnd; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; s[i]=s[i-1]^a[x]; } while(q--){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; if((r-l+1)\u0026amp;1)cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; else if(s[r]==s[l-1])cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); for(int i=1;i\u0026lt;=1e6;i++){ a[i]=rnd(); } int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf974/","summary":"Codeforces Round 974 (Div. 3) è¡¥é¢˜","title":"Codeforces Round 974 (Div. 3)"},{"content":"ABC374 C - Separated Lunch å°† $n$ ä¸ªæ•°å°½é‡å‡åˆ†ï¼Œå› ä¸ºæœ€å¤šåªæœ‰ 20 ä¸ªæ•°æ®ï¼Œå¯ä»¥ç›´æ¥æš´æœ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e5+7, mod=1e9+7; int n,s,ans=INT_MAX; int a[N]; void dfs(int cnt,int sum){ if(cnt==n){ ans=min(ans,max(sum,s-sum)); return; } dfs(cnt+1,sum); dfs(cnt+1,sum+a[cnt+1]); } void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s+=a[i]; } dfs(0,0); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC374 E - Sensor Optimization Dilemma 2 æ˜“æƒ³åˆ°äºŒåˆ†ç­”æ¡ˆï¼Œä½†æ˜¯åœ¨ $check$ è¿‡ç¨‹ä¸­ï¼Œå¯¹æ¯ä¸ªè¿›ç¨‹æœºå™¨çš„é€‰æ‹©éœ€è¦è€ƒè™‘\nå¦‚æœç›´æ¥æš´åŠ›ä» $0$ åˆ° $mid/a[i]$ ä¸€å®šä¼šè¶…æ—¶\nè€ƒè™‘å¦‚æœéœ€è¦ç”Ÿäº§ $ab$ ä¸ªå•ä½çš„ç‰©å“ï¼Œé‚£ä¹ˆç¬¬ä¸€ç§æœºå™¨ä¼šæ¶ˆè€— $bp$ï¼Œç¬¬äºŒç§æœºå™¨åˆ™ä¼šæ¶ˆè€— $ap$ï¼Œä½†åœ¨æœ€ä¼˜æ–¹æ¡ˆä¸­ï¼Œä¸¤ç§æœºå™¨ä¸å¯èƒ½åŒæ—¶åˆ°è¾¾è¿™ä¹ˆå¤šéœ€æ±‚ï¼Œå› ä¸ºè¿™æ ·å°±å¯ä»¥ç”¨æ€§ä»·æ¯”é«˜çš„æ›¿ä»£ä½çš„äº†\nå‡å¦‚ $ab=10,a=5,p=10,b=2,q=5$ï¼Œæˆ‘ä»¬ä¼šä¼˜å…ˆé€‰ $a$ å› ä¸ºä»–çš„æ€§ä»·æ¯”æ›´é«˜ï¼Œåœ¨å‰©ä¸‹å¤§äºç­‰äº $ab$ ä¸ªéœ€æ±‚æ—¶ï¼Œæˆ‘ä»¬åªä¼šé€‰ $a$ æ¥æ»¡è¶³éœ€æ±‚ï¼Œåœ¨å°äº $ab$ æ—¶ï¼Œæ‰ä¼šæ¥æ‰¾éœ€è¦å‡ ä¸ª $b$\næ‰€ä»¥ $check$ åªéœ€è¦æ‰¾ $max(a[i],b[i])$ æ¬¡å°±å¤Ÿäº†\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define int long long const int N = 1e5 + 7, mod = 1e9 + 7; int n, x; int a[N], b[N], c[N], d[N]; bool check(int f) { int lst = x; for (int i = 1; i \u0026lt;= n; i++) { int cost = INT_MAX; for (int j = 0; j \u0026lt;= 100; j++) { int remaining = f - j * a[i]; cost = min(cost, j * b[i] + max(0LL, (int)ceil(1.0 * remaining / c[i])) * d[i]); } for (int j = 0; j \u0026lt;= 100; j++) { int remaining = f - j * c[i]; cost = min(cost, j * d[i] + max(0LL, (int)ceil(1.0 * remaining / a[i])) * b[i]); } lst -= cost; if (lst \u0026lt; 0) return false; } return lst \u0026gt;= 0; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i] \u0026gt;\u0026gt; c[i] \u0026gt;\u0026gt; d[i]; } int l = 0, r = 1e9, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { ans = mid; l = mid + 1; } else { r = mid - 1; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC374 F - Shipping æ˜“æƒ³åˆ°ç”¨ $dp$ è§£å†³\nå¼€ä¸€ä¸ª $dp[i][t]$ ç¬¬ä¸€ç»´ä»£è¡¨å·²å‘äº† $i$ ä»¶ï¼Œç¬¬äºŒç»´ä»£è¡¨æœ€åä¸€æ¬¡å‘å¿«é€’åœ¨ä»€ä¹ˆæ—¶åˆ»å‘çš„\nå¯ä»¥æƒ³åˆ°å‘å¿«é€’çš„æ—¶é—´ä¸€å®šæ˜¯ $t_{i}+k x, k \\in \\mathbb{Z}$\nå› ä¸ºæ¯æ¬¡å‘å¿«é€’çš„æ—¶é—´ï¼Œå°±æ˜¯æ­¤å¿«é€’åˆšåˆ°ï¼Œæˆ–æ˜¯å…ˆå †ç§¯ä¸å‘ï¼Œç­‰åˆ°åé¢çš„å¿«é€’åˆ°äº†ä¸€èµ·å‘ï¼Œåªæœ‰è¿™ä¸¤ç§çŠ¶æ€\nä¸­é—´çš„ç­‰å¾…éƒ½æ˜¯æ— æ„ä¹‰çš„ï¼Œæ‰€ä»¥éœ€è¦è€ƒè™‘çš„æ—¶é—´ç‚¹å…¶å®å¹¶ä¸å¤š\nåˆå§‹çŠ¶æ€å³ä¸º $dp[1][t[1]]$ æ„ä¸ºç¬¬ä¸€ä»¶ï¼Œæ—¶é—´ä¸º $t[1]$ï¼Œæ­¤æ—¶æ€»èŠ±è´¹å€¼ä¸º $0$\nç„¶åä»ç¬¬äºŒä¸ªè¿›å…¥ $dp$ è¿‡ç¨‹\nå½“ $i\u0026lt;=k$ æ—¶ï¼Œæ­¤æ—¶éƒ½å¯ä»¥ä¸€æ¬¡æ€§å‘å‡ºï¼Œè®¡ç®—åœ¨ $t[i]$ æ—¶å‘å‡ºæ€»èŠ±è´¹å€¼ï¼Œæ›´æ–° $dp[i][t[i]]$ çš„å€¼\nä»ä¸Šä¸€æ¬¡å‘ $k$ ä»¶çš„æ—¶é—´æ—¶åˆ»ï¼Œåˆ°ä¸Šä¸€ä»¶çš„æ—¶åˆ»ï¼Œä¾æ¬¡è€ƒè™‘åœ¨æ­¤æ—¶å‘å¿«é€’çš„èŠ±è´¹ï¼ŒæŒ‰ç…§ä¸Šé¢çš„æ›´æ–°è¿‡ç¨‹å†æ¥ä¸€é\næœ€ååœ¨ $dp[n]$ é‡Œæ‰¾æœ€å°å€¼å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e3+7, mod=1e9+7; int k,n,x; ll t[N]; map\u0026lt;ll,ll\u0026gt;dp[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;t[i]; dp[1][t[1]]=0; for(int i=2;i\u0026lt;=n;i++){ if(i\u0026lt;=k){ ll res=0; for(int j=1;j\u0026lt;=i;j++)res+=t[i]-t[j]; if(!dp[i].count(t[i]))dp[i][t[i]]=res; else dp[i][t[i]]=min(dp[i][t[i]],res); } for(int j=i-k;j\u0026lt;=i-1;j++){ if(j\u0026gt;0){ for(auto [key,val]:dp[j]){ ll tmp=max(key+x,t[i]); ll res=val; for(int k=j+1;k\u0026lt;=i;k++)res+=tmp-t[k]; if(!dp[i].count(tmp))dp[i][tmp]=res; else dp[i][tmp]=min(dp[i][tmp],res); } } } } ll ans=1e18; for(auto [key,val]:dp[n])ans=min(ans,val); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [NOIP2017]å¥¶é…ª dfs æŸ¥è¯¢ï¼Œä»¥å½“å‰ç©ºæ´ä¸ºåŸç‚¹ï¼Œè®¡ç®—å…¶ä»–ç©ºæ´åˆ°è¿™ä¸ªåœ†å¿ƒçš„è·ç¦»ï¼Œå¦‚æœå°äº 2*r å°±è¿›è¡Œ dfsï¼Œå¦‚æœèƒ½ç¢°åˆ° h å°±å¯ä»¥å®Œæˆä»»åŠ¡\nè¦å…ˆæ‰¾åˆ°æ¥åœ°çš„ç©ºæ´ï¼Œå¯¹ä»–ä»¬éƒ½è¿›è¡Œ dfs\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7; const int MOD = 1e9 + 7; int n, h, r; ll x[N], y[N], z[N]; bool vis[N]; bool flag = false; ll dis(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2) { return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2); } void dfs(int pos) { vis[pos] = true; if (z[pos] + r \u0026gt;= h) { flag = true; return; } for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i] \u0026amp;\u0026amp; dis(x[pos], y[pos], z[pos], x[i], y[i], z[i]) \u0026lt;= 4 * r * r) { if (flag) return; dfs(i); } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h \u0026gt;\u0026gt; r; memset(vis, 0, sizeof(vis)); for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; z[i]; } flag = false; for (int i = 1; i \u0026lt;= n; ++i) { if (z[i] - r \u0026lt;= 0 \u0026amp;\u0026amp; !vis[i]) { dfs(i); } } cout \u0026lt;\u0026lt; (flag ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","permalink":"http://localhost:1313/posts/study/2024102222/","summary":"ä¹…è¿çš„å­¦ä¹ è®°å½• 3","title":"è¿‘æ—¥åˆ·é¢˜è®°å½• 3"},{"content":"AtCoder ABC372 D - Buildings å•è°ƒæ ˆï¼Œé€†å‘è¿›è¡Œï¼Œæ‰¾å·¦ä¾§æ¯”ä»–å¤§çš„æ•°ï¼Œæ­¤æ—¶æ ˆçš„å¤§å°å³ä¸ºå½“å‰ä½çš„ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n,h[N],ans[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;h[i]; } for(int i=n;i\u0026gt;=1;i--){ ans[i]=s.size(); while(s.size()\u0026amp;\u0026amp;s.top()\u0026lt;h[i])s.pop(); s.push(h[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC372 E - K-th Largest Connected Components å¹¶æŸ¥é›†ï¼Œæˆ‘ä»¬å¯ä»¥å¼€ $n$ ä¸ªå †ï¼ŒæŠŠæ¯ä¸ªè”é€šå—éƒ½å­˜åˆ°åŒä¸€ä¸ªæ ˆå½“ä¸­ï¼ŒæŸ¥è¯¢æ—¶æ ˆçš„å¤§å°å°äº $k$ å°±è¾“å‡º -1ï¼Œåä¹‹è¾“å‡ºç›¸åº”å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; int n, q, u, v, op; set\u0026lt;int\u0026gt; s[N]; int fa[N]; int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { if (s[fx].size() \u0026lt; s[fy].size()) swap(fx, fy); fa[fy] = fx; for (int elem : s[fy]) { s[fx].insert(elem); } s[fy].clear(); } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { fa[i] = i; s[i].insert(i); } while (q--) { cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (op == 1) { unite(u, v); } else { int x = find(u); if (s[x].size() \u0026lt; v) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { auto it = s[x].rbegin(); advance(it, v - 1); cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC372 F - Teleporting Takahashi 2 æ ¹æ®é¢˜æ„ï¼Œå¯ä»¥æ¨æ–­å‡ºæ˜¯ç”¨ $dp$ è§£å†³\nçœ‹é¢˜ï¼Œå¯ä»¥å‘ç°ä¸€å®šæ˜¯ä¸ªä» $1$ åˆ° $n$ çš„ç¯ï¼Œç„¶åæœ‰ $m$ æ¡è¾¹æ˜¯å¤šå‡ºæ¥çš„ï¼Œé‚£ä¹ˆå¤šçš„æ–¹æ¡ˆæ•°ä¸€å®šæ˜¯ç”±è¿™ $m$ æ¡è¾¹å†³å®šçš„\nå¼€ä¸€ä¸ª $f[i][k]$ æ•°ç»„ï¼Œ$i$ æŒ‡ä»£å½“å‰æ˜¯å“ªä¸ªèŠ‚ç‚¹ï¼Œ$k$ æŒ‡ä»£å½“å‰æ˜¯ç¬¬å‡ æ­¥\nå¯ä»¥æ¨æ–­å‡ºæ¯ä¸ªç‚¹çš„ç¬¬ $k$ æ­¥çš„æ–¹æ¡ˆæ•°\n$f_{v,k}=f_{v-1,k-1}+\\sum_{(u,v)\\in edge}f_{u,k-1}$\n$v$ æ˜¯å½“å‰ç‚¹ï¼Œ$u$ æ˜¯ $m$ æ¡è¾¹ä¸­æŒ‡å‘ $v$ çš„ç‚¹\nä½†å¦‚æœè¿™ä¹ˆå¼€çš„è¯ï¼Œæ—¶é—´ç©ºé—´éƒ½ä¼šè¿‡å¤§ï¼Œæ˜¾ç„¶ä¸èƒ½é€šè¿‡\nç»§ç»­è§‚å¯Ÿé¢˜ç›®ï¼Œå‘ç°æˆ‘ä»¬å¯ä»¥å°†ç¬¬äºŒç»´æ»šåŠ¨ä¼˜åŒ–ï¼Œå˜ä¸ºä¸€ç»´æ•°ç»„\næ¯æ¬¡å‘å‰ä¸€æ­¥ï¼Œè¿™ä¸ªç¯çš„èµ·ç‚¹å°±ä» $st$ å˜æ›´ä¸º $st-1+n$\nå¯ä»¥çœ‹å‡ºï¼Œèµ·å§‹æ—¶ï¼Œæ˜¯ä»¥ 1 ä¸ºèµ·ç‚¹çš„ä¸€ä¸ªç¯ï¼Œè¿›è¡Œäº†ä¸€æ¬¡ç§»åŠ¨åï¼Œæ¯ä¸ªç‚¹éƒ½å‘åç§»åŠ¨ï¼Œ8 è¿™ä¸ªç‚¹å°±ç§»åŠ¨åˆ°ç¬¬ä¸€ä½äº†\næ‰€ä»¥ $f[8]\u0026rsquo;$ çš„å€¼å°±æ˜¯ $f[1]$ï¼Œ$f[1]\u0026rsquo;$ çš„å€¼å°±æ˜¯ $f[2]$\næŒ‰ç…§å¹³ç§»åçš„ç‚¹çš„åç§°æ¥è®¡ç®— $f$ æ•°ç»„çš„å€¼ï¼ŒæŒ‰ç…§å¹³ç§»åçš„ç‚¹æ¥æ›´æ–°\nå…ˆç”¨ä¸€ä¸ª $lst$ æ•°ç»„æ¥è®°å½•å½“å‰çš„ $f$ æ•°ç»„ä¸­çš„å€¼ï¼Œé¿å…æ›´æ–°è¿‡ç¨‹ä¸­è¢«è¦†ç›–\næ¥ç€ï¼Œæˆ‘ä»¬éå† $edge$ æ•°ç»„ä¸­å­˜çš„è¾¹ï¼Œ $f_{v}=f_{v}+\\sum_{{u,v}\\in edge}lst_{u}$\nç­”æ¡ˆå³ä¸º $\\sum_{i=1}^{n}f_{i}$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+70, mod=998244353; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;edge; int n,m,k; ll f[N],lst[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; u--,v--; edge.push_back({u,v}); } f[0]=1; int st=0; for(int i=1;i\u0026lt;=k;i++){ st=(st-1+n)%n; for(auto x:edge){ int u=x.first,v=x.second; u=(st+1+u)%n,v=(st+v)%n; lst[v]=f[v]; lst[u]=f[u]; } for(auto x:edge){ int u=x.first,v=x.second; u=(st+1+u)%n,v=(st+v)%n; f[v]=(f[v]+lst[u])%mod; } } ll ans=0; for(int i=0;i\u0026lt;n;i++){ ans=(ans+f[i])%mod; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } NowCoder é£Ÿç‰©é“¾ å¼€ä¸‰å€ç©ºé—´ï¼Œå‚¨å­˜ç‰©ç§ä¹‹é—´ç›¸é£Ÿçš„å…³ç³»ï¼Œç›¸é‚»å±‚çº§ä¹‹é—´å¦‚æœæ˜¯åŒä¸€çˆ¶èŠ‚ç‚¹ï¼Œå³æœ‰ç›¸é£Ÿå…³ç³»\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 2e5 + 7; const int mod = 1e9 + 7; int n, k; int d, x, y; int ans = 0; int fa[N]; int find(int x) { if (fa[x] != x) { fa[x] = find(fa[x]); } return fa[x]; } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) { fa[fx] = fy; } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= 3 * n; i++) { fa[i] = i; } while (k--) { cin \u0026gt;\u0026gt; d \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (x \u0026gt; n || y \u0026gt; n) { ans++; continue; } if (d == 1) { if (find(x) == find(y + n) || find(x) == find(y + 2 * n)) { ans++; continue; } unite(x, y); unite(x + n, y + n); unite(x + 2 * n, y + 2 * n); } else { if (find(x) == find(y) || find(x) == find(y + 2 * n)) { ans++; continue; } unite(x, y + n); unite(x + n, y + 2 * n); unite(x + 2 * n, y); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } [NOIP2010]å…³æŠ¼ç½ªçŠ¯ æŒ‰å†²çªå€¼ä»å¤§åˆ°å°æ’åºï¼Œå†²çªå€¼å¤§çš„ï¼Œå…ˆåˆ†å¼€ï¼ŒåŒæ—¶æ ‡è®°åˆ†å¼€çš„ä¸¤ä¸ªäººï¼Œè¿™ä¸¤äººç°åœ¨ä¸ä¼šäº§ç”Ÿå†²çªï¼Œç»§ç»­å‘ä¸‹çœ‹ï¼Œå¦‚æœé‡åˆ°æ ‡è®°è¿‡çš„äººï¼Œæˆ‘ä»¬è‚¯å®šå°†å¦ä¸€äººæ”¾åˆ°ä¹‹å‰å’Œè¿™ä¸ªæ ‡è®°è¿‡çš„äººå†²çªè¿‡çš„äººæ‰€åœ¨çš„ç›‘ç‹±ï¼Œè¿™æ ·ä¸‰ä¸ªäººéƒ½ä¸ä¼šäº§ç”Ÿå†²çªï¼Œå†å¾€ä¸‹å¦‚æœç»§ç»­åœ¨è¿™ä¸‰äººä¸­äº§ç”Ÿå†²çªï¼Œé‚£ä¹ˆå°±æ˜¯ä¸å¯é¿å…çš„äº†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N=1e5+7, mod=1e9+7; struct Node{ int a,b,c; bool operator\u0026lt;(const Node \u0026amp;t){return c\u0026gt;t.c;} }a[N]; int fa[N],fr[N]; int n,m; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ fa[find(x)]=fa[find(y)]; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ fa[i]=i; } for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;a[i].a\u0026gt;\u0026gt;a[i].b\u0026gt;\u0026gt;a[i].c; } sort(a+1,a+1+m); for(int i=1;i\u0026lt;=m;i++){ if(find(a[i].a)==find(a[i].b)){ cout\u0026lt;\u0026lt;a[i].c\u0026lt;\u0026lt;endl; return; } if(!fr[a[i].a])fr[a[i].a]=a[i].b; else unite(a[i].b,fr[a[i].a]); if(!fr[a[i].b])fr[a[i].b]=a[i].a; else unite(a[i].a,fr[a[i].b]); } cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; } signed main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } Parity game æ‹“å±•åŸŸå¹¶æŸ¥é›†\n$n$ ä¸ªç‚¹ï¼Œæ¯ä¸ªç‚¹æ‹“å±•ä¸ºä¸¤ä¸ªç‚¹ï¼Œæ­£ç‚¹å’Œåç‚¹ï¼Œå¦‚æœ $a$ å’Œ $b$ ä¸èƒ½åœ¨åŒä¸€ä¸ªé›†åˆå†…ï¼Œå°±æŠŠ $a$ å’Œ $b$ çš„åèŠ‚ç‚¹æ”¾åœ¨ä¸€èµ·ï¼Œå¦‚æœå‘ç° $a$ å’Œ $b$ çš„æ­£èŠ‚ç‚¹å·²ç»åœ¨ä¸€èµ·äº†ï¼Œè¯´æ˜ä¹‹å‰çš„å…³ç³»ä¸ç°åœ¨çš„å…³ç³»å†²çªï¼Œå³ä¸èƒ½åŒæ—¶æ»¡è¶³\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m; unordered_map\u0026lt;int,int\u0026gt;fa; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ fa[find(x)]=find(y); } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; n++; for(int i=0;i\u0026lt;m;i++){ int x,y; string op; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;op; x--; if(fa.count(x)==0)fa[x]=x,fa[x+n]=x+n; if(fa.count(y)==0)fa[y]=y,fa[y+n]=y+n; if(op==\u0026#34;even\u0026#34;){ if(find(x)==find(y+n)){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } unite(x,y); unite(x+n,y+n); } else{ if(find(x)==find(y)){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } unite(x,y+n); unite(x+n,y); } } cout\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æ‹†è·¯ å¹¶æŸ¥é›†æœ¬èº«ä¸æ”¯æŒæ’¤é”€æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬è½¬ä¸ºç¦»çº¿æ“ä½œï¼Œæ‰€æœ‰æ•°æ®è®°å½•åå»ºå›¾ï¼Œå…ˆä¸åŠ è¢«åˆ æ‰çš„è¾¹ï¼Œåœ¨è¿›è¡Œæ“ä½œæ—¶ï¼Œå€’åºè¿›è¡Œï¼Œå°†ååˆ çš„åŠ å›æ¥å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,m,q,a,b; int fa[N],w[N],u[N],v[N],du[N],dv[N],ans[N]; char op; set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;s; int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); } void unite(int x,int y){ int fx=find(x),fy=find(y); if(w[fx]\u0026gt;w[fy])fa[fy]=fx; else fa[fx]=fy; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;w[i]; fa[i]=i; } for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;u[i]\u0026gt;\u0026gt;v[i]; cin\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=q;i++){ cin\u0026gt;\u0026gt;op; if(op==\u0026#39;Q\u0026#39;)cin\u0026gt;\u0026gt;du[i]; else { cin\u0026gt;\u0026gt;du[i]\u0026gt;\u0026gt;dv[i]; s.insert({du[i],dv[i]}); s.insert({dv[i],du[i]}); } } for(int i=1;i\u0026lt;=m;i++){ if(s.find({u[i],v[i]})==s.end())unite(u[i],v[i]); } for(int i=q;i\u0026gt;0;i--){ if(dv[i])unite(du[i],dv[i]); else ans[i]=w[find(du[i])]; } for(int i=1;i\u0026lt;=q;i++){ if(ans[i])cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } è€å­çš„å…¨æ’åˆ—å‘¢ è¾“å‡º 1~8 çš„å…¨æ’åˆ—\nä¸»è¦æ˜¯å­¦ä¹  next_permutation å’Œ prev_permutation\nå‰è€…æ˜¯æ•°ç»„çš„ä¸‹ä¸€ä¸ªå­—å…¸åºæ›´å¤§çš„æ’åºï¼Œåè€…æ˜¯å­—å…¸åºæ›´å°çš„æ’åº\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; void solve() { int n = 8; int a[8]; for (int i = 0; i \u0026lt; n; i++) { a[i] = i + 1; } do { for (int i = 0; i \u0026lt; 8; i++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; (i != 7 ? \u0026#34; \u0026#34; : \u0026#34;\u0026#34;); } cout \u0026lt;\u0026lt; endl; } while (next_permutation(a, a + 8)); } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ä¹Ÿå¯ä»¥ dfs ç¡¬æœ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; bool vis[10]; int a[10]; void dfs(int d){ if(d==9){ for(int i=1;i\u0026lt;=8;i++)cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;(i==8?\u0026#34;\u0026#34;:\u0026#34; \u0026#34;); cout\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=8;i++){ if(!vis[i]){ a[d]=i; vis[i]=1; dfs(d+1); a[d]=0; vis[i]=0; } } } void solve(){ dfs(1); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/202410/","summary":"ä¹…è¿çš„å­¦ä¹ è®°å½• 2","title":"è¿‘æ—¥åˆ·é¢˜è®°å½• 2"},{"content":"AtCoder ABC371C Make Isomorphic ç»™ä½ ç®€å•çš„æ— å‘å›¾ $G$ å’Œ $H$ ï¼Œæ¯ä¸ªå›¾éƒ½æœ‰ $N$ ä¸ªé¡¶ç‚¹ï¼šé¡¶ç‚¹ $1$ ã€ $2$ ã€ $\\ldots$ ã€ $N$ ã€‚å›¾ $G$ æœ‰ $M_G$ æ¡è¾¹ï¼Œå…¶ç¬¬ $i$ æ¡è¾¹ $(1\\leq i\\leq M_G)$ è¿æ¥é¡¶ç‚¹ $u_i$ å’Œ $v_i$ ã€‚å›¾ $H$ æœ‰ $M_H$ æ¡è¾¹ï¼Œå®ƒçš„ç¬¬ $i$ æ¡è¾¹ $(1\\leq i\\leq M_H)$ è¿æ¥é¡¶ç‚¹ $a_i$ å’Œ $b_i$ ã€‚\næ‚¨å¯ä»¥åœ¨å›¾ $H$ ä¸Šæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œæ¬¡æ•°ä¸é™ï¼Œå¯èƒ½ä¸ºé›¶ã€‚\né€‰æ‹©ä¸€å¯¹æ»¡è¶³ $1\\le i\u0026lt;j\\leq N$ çš„æ•´æ•° $(i,j)$ ã€‚æ”¯ä»˜ $A_{i,j}$ ç‚¹æˆæœ¬ï¼Œå¦‚æœ $H$ ä¸­çš„é¡¶ç‚¹ $i$ å’Œ $j$ ä¹‹é—´æ²¡æœ‰è¾¹ï¼Œåˆ™æ·»åŠ ä¸€æ¡ï¼›å¦‚æœæœ‰ï¼Œåˆ™åˆ é™¤ã€‚\næ±‚ä½¿ $G$ å’Œ $H$ åŒæ„æ‰€éœ€çš„æœ€å°æ€»æˆæœ¬ã€‚\nå› ä¸º $n\u0026lt;=8$ æ‰€ä»¥å¯ä»¥ç›´æ¥æš´åŠ›ï¼Œéå† $h$ å›¾çš„æ¯ä¸€ç§ä¸ $g$ å›¾çš„å¯¹åº”æ–¹å¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 1e3 + 7, mod = 1e9 + 7; void solve() { int n; cin \u0026gt;\u0026gt; n; bool g[N][N], h[N][N]; memset(g, false, sizeof(g)); memset(h, false, sizeof(h)); int mg, mh; cin \u0026gt;\u0026gt; mg; for (int i = 0; i \u0026lt; mg; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u][v] = g[v][u] = true; } cin \u0026gt;\u0026gt; mh; for (int i = 0; i \u0026lt; mh; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; h[u][v] = h[v][u] = true; } int cost[N][N]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; cost[i][j]; cost[j][i] = cost[i][j]; } } int p[n + 1]; for (int i = 1; i \u0026lt;= n; i++) p[i] = i; int ans = 1e9; do { int tmp = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = i + 1; j \u0026lt;= n; j++) { if (g[i][j] ^ h[p[i]][p[j]]) tmp += cost[p[i]][p[j]]; } } ans = min(ans, tmp); } while (next_permutation(p + 1, p + 1 + n)); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ABC371E I Hate Sigma Problems è®°å½•æ¯ä¸€ä¸ªæ•°ç›¸åŒçš„æ•°ä¸Šæ¬¡å‡ºç°çš„ä½ç½®ï¼Œå³å¯å¾—åˆ°å…¶å¯¹ç­”æ¡ˆä½œå‡ºçš„è´¡çŒ®\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; int n; vector\u0026lt;int\u0026gt;a(N),nxt(N),last(N); void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; ll sum=0,cnt=0; map\u0026lt;int,int\u0026gt;vis; for(int i=1;i\u0026lt;=n;i++){ if(!vis[a[i]]){ vis[a[i]]=1; cnt++; } sum+=cnt; nxt[last[a[i]]]=i; last[a[i]]=i; } ll ans=sum; for(int i=1;i\u0026lt;=n;i++){ int t=nxt[i]; if(!t)t=n+1; sum-=t-i; ans+=sum; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373D Hidden Weights You are given a directed graph with $N$ vertices and $M$ edges. The $j$-th directed edge goes from vertex $u_j$ to vertex $v_j$ and has a weight of $w_j$.\nFind one way to write an integer between $-10^{18}$ and $10^{18}$, inclusive, to each vertex such that the following condition is satisfied.\nLet $x_i$ be the value written on vertex $i$. For all edges $j=1,2,\\dots,M$, it holds that $x_{v_j} - x_{u_j} = w_j$. It is guaranteed that at least one such assignment exists for the given input.\nåŠ è¾¹æ—¶ï¼ŒåŠ åŒå‘è¾¹ï¼Œæƒå€¼ç›¸åï¼Œæ¥ç€ç›´æ¥å¯¹æŸä¸ªç‚¹å¼€å§‹è·‘ $bfs$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=2e5+7, mod=1e9+7; ll n,m; struct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; ll ans[N],vis[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v,w; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w; edge[u].push_back({v,w}); edge[v].push_back({u,-w}); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; queue\u0026lt;int\u0026gt;q; q.push(i); vis[i]=1; while(!q.empty()){ int u=q.front(); for(auto i:edge[u]){ if(!vis[i.v]){ vis[i.v]=1; ans[i.v]=ans[u]+i.w; q.push(i.v); } } q.pop(); } } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ABC373EHow to Win the Election å•¥åŠé¢˜ï¼Œä¸€çœ¼çœ‹å‡ºæ¥æ’åºå®ŒäºŒåˆ†ç­”æ¡ˆï¼Œè°ƒä¸€å¹´æ²¡è°ƒå‡ºæ¥\näºŒåˆ†æ£€æµ‹æ—¶ï¼Œçœ‹å½“å‰ä½åŠ ä¸Š $mid$ ç¥¨åï¼Œæ˜¯å¦è¿˜æœ‰ $\u0026gt;=m$ ä¸ªäººçš„ç¥¨å¯èƒ½æ¯”ä»–å¤š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N = 2e5 + 7, mod = 1e9 + 7; ll n, m, k; ll a[N], b[N]; ll s[N]; bool check(ll f, int pos) { ll lft = k - f; int x = upper_bound(b + 1, b + 1 + n, a[pos] + f) - b - 1; int y = n - m + 1; if (n - x \u0026gt;= m) return false; if (b[y] \u0026gt; a[pos]) return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 1]) \u0026gt; lft; return 1ll * (x - y + 1) * (a[pos] + f + 1) - (s[x] - s[y - 2] - a[pos]) \u0026gt; lft; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; if (n == m) { for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; \u0026#34;0 \u0026#34;; return; } memcpy(b, a, (n + 1) * sizeof(ll)); sort(b + 1, b + 1 + n); for (int i = 1; i \u0026lt;= n; i++) s[i] = s[i - 1] + b[i]; k -= s[n]; for (int i = 1; i \u0026lt;= n; i++) { ll l = 0, r = k, ans = 1e18; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid, i)) ans = mid, r = mid - 1; else l = mid + 1; } cout \u0026lt;\u0026lt; (ans \u0026lt; 1e18 ? ans : -1) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } NowCoder K-th Number äºŒåˆ†ç­”æ¡ˆæ£€æµ‹è¿‡ç¨‹ä¸­ï¼Œè®°å½•ä»å¤´åˆ°å°¾æ¯ä¸ªå­åŒºé—´çš„æ¯” $mid$ å¤§çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶åå†éå†æ•°ç»„ï¼Œçœ‹æ¯ä¸ªä½ç½®çš„æ•°èƒ½å¦ä½œä¸ºç¬¬ $k$ å¤§çš„æ•°è¿›å…¥æ•°ç»„ $b$ ,æœ€åçœ‹æ‰¾çš„æ•°æ˜¯å¦å¤§äº $m$ ä¸ª\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; ll m; int a[N],s[N]; bool check(int f){ ll sum=0; int l=0; for(int i=1;i\u0026lt;=n;i++)s[i]=s[i-1]+(a[i]\u0026gt;=f); for(int i=1;i\u0026lt;=n;i++){ while(s[i]-s[l]\u0026gt;=k)l++; sum+=l; } return sum\u0026gt;=m; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; int l=1,r=1e9,ans=1; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [SCOI2010]ä¼ é€å¸¦ ä¸‰åˆ†ä¸¤æ¡ä¼ é€å¸¦ä¸Šçš„ç‚¹ï¼Œè¿™ä¸¤ç‚¹é—´èµ°ç›´çº¿ï¼Œå…¶ä½™éƒ¨åˆ†èµ°ä¼ é€å¸¦\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; const double eps=1e-4; double ax,ay,bx,by,cx,cy,dx,dy; double p,q,r; double fx,fy,ex,ey; double dis(double x,double y,double a,double b){ return sqrt(eps+(x-a)*(x-a)+(y-b)*(y-b)); } double chec(double x){ fx=cx+(x/dis(cx,cy,dx,dy)*(dx-cx)),fy=cy+(x/dis(cx,cy,dx,dy)*(dy-cy)); return dis(fx,fy,ex,ey)/r+(dis(cx,cy,dx,dy)-x)/q; } double check(double x){ ex=ax+(x/dis(ax,ay,bx,by)*(bx-ax)),ey=ay+(x/dis(ax,ay,bx,by)*(by-ay)); double l=0,r=dis(cx,cy,dx,dy); for(int i=1;i\u0026lt;=1000;i++){ double lm=l+(r-l)/3,rm=r-(r-l)/3; if(chec(lm)\u0026gt;=chec(rm))l=lm; else r=rm; } return chec(l)+x/p; } void solve(){ cin\u0026gt;\u0026gt;ax\u0026gt;\u0026gt;ay\u0026gt;\u0026gt;bx\u0026gt;\u0026gt;by\u0026gt;\u0026gt;cx\u0026gt;\u0026gt;cy\u0026gt;\u0026gt;dx\u0026gt;\u0026gt;dy\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q\u0026gt;\u0026gt;r; double l=0,r=dis(ax,ay,bx,by); for(int i=1;i\u0026lt;=1000;i++){ double ml=l+(r-l)/3,mr=r-(r-l)/3; if(check(ml)\u0026gt;=check(mr)){ l=ml; } else r=mr; } printf(\u0026#34;%.2lf\u0026#34;,check(l)); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } å°å’ªä¹°ä¸œè¥¿ 01 åˆ†æ•°è§„åˆ’\nå¯¹ $double$ ç±»äºŒåˆ†ï¼Œé™åˆ¶äºŒåˆ†å¾ªç¯æ¬¡æ•°æ¥æ§åˆ¶äºŒåˆ†ç»“æŸå³å¯\næˆ‘ä»¬äºŒåˆ†çš„æ˜¯å•ä½ä»·æ ¼ï¼ˆå³æ€»ä»·å€¼/æ€»èŠ±è´¹ï¼‰\nåˆ¤æ–­æ¡ä»¶å³ä¸ºåœ¨è¿™ä¸ªå•ä½æ¡ä»¶ä¸‹ï¼Œä¹° $k$ ä¸ªå•†å“èƒ½å¦ä»ç„¶ä¿æŒå½“å‰å•ä½ä»·æ ¼ä¸ºæ­£\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; int n,k; int c[N],v[N]; double w[N]; bool check(double x){ for(int i=1;i\u0026lt;=n;i++)w[i]=v[i]-x*c[i]; sort(w+1,w+1+n,greater\u0026lt;double\u0026gt;()); double s=0; for(int i=1;i\u0026lt;=k;i++){ s+=w[i]; } return s\u0026gt;0; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;v[i]; double l=0,r=1e9; for(int i=1;i\u0026lt;=100;i++){ double mid=(l+r)/2; if(check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r)\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æ ˆå’Œæ’åº çŸ¥é“å…¥æ ˆé¡ºåºï¼Œæ±‚å­—å…¸åºæœ€å¤§çš„å‡ºæ ˆåºåˆ—\næˆ‘ä»¬å¯ä»¥æŒ‰å€’åºç»Ÿè®¡ä»ååˆ°å½“å‰ä½çš„æœ€å¤§å€¼ï¼Œåœ¨æ¨¡æ‹Ÿå‡ºæ ˆè¿‡ç¨‹ä¸­ï¼Œå¦‚æœåé¢æœ‰æ¯”å½“å‰ä½å¤§çš„æ•°ï¼Œé‚£è¿™ä¸€ä½å°±å…ˆä¸å‡ºæ ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; int a[N],mx[N]; stack\u0026lt;int\u0026gt;s; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=n;i\u0026gt;0;i--)mx[i]=max(mx[i+1],a[i]); for(int i=1;i\u0026lt;=n;i++){ while(!s.empty()\u0026amp;\u0026amp;s.top()\u0026gt;mx[i]){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } s.push(a[i]); } while(!s.empty()){ cout\u0026lt;\u0026lt;s.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; s.pop(); } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } [NOIP2016]èš¯èš“ å¦‚æœå…¨éƒ¨åœ¨åŒä¸€ä¸ªé˜Ÿåˆ—æˆ–å †ä¸­è¿›è¡Œå­˜å–ï¼Œä¼šè¶…æ—¶ã€‚\nå¯ä»¥è€ƒè™‘åˆ†ä¸‰ä¸ªé˜Ÿåˆ—æ¥å‚¨å­˜ï¼Œä¸€ä¸ªå­˜çš„æ˜¯åŸæ•°æ®ï¼Œåˆ‡å‰²åçš„ä¸¤éƒ¨åˆ†åˆ†å¼€å­˜åœ¨å¦å¤–ä¸¤ä¸ªé˜Ÿåˆ—ä¸­ã€‚\nåŒæ—¶è¦è€ƒè™‘éšæ—¶é—´å˜é•¿è¿™ä¸ªè¿‡ç¨‹ï¼Œæ‰€ä»¥åªå­˜å‚¨åŸé•¿ï¼Œåœ¨å–å‡ºæ—¶ï¼ŒåŠ ä¸Šå½“å‰æ—¶é—´å¢é•¿çš„é•¿åº¦ï¼Œå­˜è¿›å»æ—¶ï¼Œå‡æ‰å¢é•¿çš„é•¿åº¦ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) #define int long long const int N = 1e5 + 7, mod = 1e9 + 7; int n, m, q, u, v, t; double p; queue\u0026lt;int\u0026gt; qu[3]; int a[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; t; p = static_cast\u0026lt;double\u0026gt;(u) / v; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + 1 + n, greater\u0026lt;int\u0026gt;()); for (int i = 1; i \u0026lt;= n; i++) qu[0].push(a[i]); for (int i = 1; i \u0026lt;= m; i++) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } int len = qu[pos].front() + (i - 1) * q; qu[pos].pop(); if (i % t == 0) cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; \u0026#34; \u0026#34;; int l = len * p; int r = len - l; qu[1].push(l - q * i); qu[2].push(r - q * i); } cout \u0026lt;\u0026lt; endl; int cnt = 1; while (!qu[1].empty() || !qu[0].empty() || !qu[2].empty()) { int mx = INT_MIN, pos = 0; for (int j = 0; j \u0026lt; 3; j++) { if (!qu[j].empty() \u0026amp;\u0026amp; qu[j].front() \u0026gt; mx) { mx = qu[j].front(); pos = j; } } if (cnt % t == 0) cout \u0026lt;\u0026lt; qu[pos].front()+m*q \u0026lt;\u0026lt; \u0026#34; \u0026#34;; qu[pos].pop(); cnt++; } } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } Running Median å¯¹é¡¶å †\nå¼€ä¸¤ä¸ªå †ï¼ŒæŒ‰å°åˆ°å¤§å„å­˜ä¸€åŠï¼Œå¤šå‡ºæ¥çš„é‚£ä¸ªå³ä¸ºä¸­ä½å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e5 + 7, mod = 1e9 + 7; int p, n, a[N]; multiset\u0026lt;int\u0026gt; s1, s2; void balance() { while (s1.size() \u0026gt; s2.size() + 1) { s2.insert(*s1.rbegin()); s1.erase(prev(s1.end())); } while (s2.size() \u0026gt; s1.size()) { s1.insert(*s2.begin()); s2.erase(s2.begin()); } } void solve() { cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; s1.clear(); s2.clear(); int cnt=0,ans[N]; for (int i = 1; i \u0026lt;= n; i++) { if (s1.empty() || a[i] \u0026lt;= *s1.rbegin()) { s1.insert(a[i]); } else { s2.insert(a[i]); } balance(); if (i % 2 == 1) { ans[++cnt]=*s1.rbegin(); } } cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(int i=1;i\u0026lt;=cnt;i++){ cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(i%10==0\u0026amp;\u0026amp;i!=cnt)cout\u0026lt;\u0026lt;endl; } cout \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ä»»åŠ¡ å¯ä»¥çœ‹åˆ° $x$ çš„ç³»æ•°è¿œå¤§äº $y$, é‚£ä¹ˆåœ¨å¯¹åŸæ•°æ®æ’åºæ—¶ï¼Œä¼˜å…ˆ $x$.\néå†æ¯ä¸€ä¸ªä»»åŠ¡ï¼Œå°†èƒ½å®Œæˆå½“å‰ä»»åŠ¡çš„æ‰€æœ‰æœºå™¨éƒ½æ’å…¥å †ä¸­ï¼Œç”¨äºŒåˆ†åœ¨å †ä¸­æ‰¾åˆ° $y$ æœ€å°çš„æœºå™¨ï¼Œå†ç»§ç»­å‘ä¸‹éå†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; struct Node{ int x,y; bool operator \u0026lt; (const Node\u0026amp; a){ if(x==a.x)return y\u0026gt;a.y; return x\u0026gt;a.x; } }; ll n,m,cnt,ans; Node ma[N],as[N]; void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;ma[i].x\u0026gt;\u0026gt;ma[i].y; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;as[i].x\u0026gt;\u0026gt;as[i].y; sort(as+1,as+1+m); sort(ma+1,ma+1+n); multiset\u0026lt;int\u0026gt;s; for(int i=1,j=1;i\u0026lt;=m;i++){ while(j\u0026lt;=n\u0026amp;\u0026amp;as[i].x\u0026lt;=ma[j].x)s.insert(ma[j++].y); auto it=s.lower_bound(as[i].y); if(it!=s.end())cnt++,ans+=500*as[i].x+2*as[i].y,s.erase(it); } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } å ç§¯æœ¨ ç»´æŠ¤é™„åŠ ä¿¡æ¯çš„å¹¶æŸ¥é›†\nå¼€ $fa[N]$ å¹¶æŸ¥é›† $d[i]$ $i$ ä¸‹æ–¹çš„ç§¯æœ¨æ•° $cnt[i]$ $i$ æ‰€åœ¨çš„è”é€šå—çš„æ•°é‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=3e5+7, mod=1e9+7; int q, x, y; int fa[N], cnt[N], d[N]; int find(int x) { if (fa[x] == x) return x; int t = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = t; } void unite(int a, int b) { int fx = find(a), fy = find(b); if (fx != fy) { fa[fx] = fy; d[fx] = cnt[fy]; cnt[fy] += cnt[fx]; } } void solve() { cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; N; i++) { fa[i] = i; d[i] = 0; cnt[i] = 1; } while (q--) { char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;M\u0026#39;) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; unite(x, y); } else { cin \u0026gt;\u0026gt; x; find(x); cout \u0026lt;\u0026lt; d[x] \u0026lt;\u0026lt; endl; } } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/202409/","summary":"ä¹…è¿çš„å­¦ä¹ è®°å½•","title":"è¿‘æ—¥åˆ·é¢˜è®°å½•"},{"content":"å‰è¨€ å¥½ä¹…æ²¡å†™é¢˜äº†ï¼Œè¢«æš´æ‰“ã€‚\nå‚èµ›è¿‡ç¨‹ä¹Ÿæ˜¯æŠ½è±¡ï¼Œå¼€å±€å°±ç½šç«™ 30 min\nè¡¥é¢˜ L ç½‘ç»œé¢„é€‰èµ› å¥½ä¸å®¹æ˜“å¡å‡ºæ¥é¢˜é¢ï¼Œçœ‹åˆ° L å·²ç»è¿‡äº†ä¸å°‘äº†ï¼Œå¡äº†åŠå¤©æ‰æäº¤è¿‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e3+7, mod=1e9+7; void solve(){ int n, m, ans = 0; char mp[N][N]; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) for(int j = 1; j \u0026lt;= m; j++) cin \u0026gt;\u0026gt; mp[i][j]; for(int i = 1; i \u0026lt; n; i++){ for(int j = 1; j \u0026lt; m; j++){ if(mp[i][j] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j] == \u0026#39;p\u0026#39; \u0026amp;\u0026amp; mp[i][j+1] == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; mp[i+1][j+1] == \u0026#39;c\u0026#39;) ans++; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } K å–æ²™å­æ¸¸æˆ å¥‡æ•°æ—¶ï¼Œä¸€ç›´å– 1 å³å¯ã€‚\nä¸ºå¶æ•°æ—¶ï¼Œå¦‚æœ $\\text{lowbit}(n) \\leq k$ï¼Œå…ˆæ‰‹å– $\\text{lowbit}(n) \\leq k$ï¼Œå†ä¸æ–­æ¨¡ä»¿åè€…å³å¯ã€‚\nåä¹‹ï¼Œéšæ„å–åçš„ $\\text{lowbit}$ ä¸€å®š $\\leq k$ï¼Œåæ‰‹ä¸€å®šè·èƒœ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e5+7, mod=1e9+7; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(lowbit(n)\u0026lt;=k)cout\u0026lt;\u0026lt;\u0026#34;Alice\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;Bob\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B å†›è®­ II æ˜¾ç„¶æ˜¯æ’åºåçš„ä¸æ•´é½åº¦æœ€å°ï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°å°±æ˜¯æ•°ç»„ä¸­çš„é‡å¤æ•°çš„æ’åˆ—ç»„åˆä¹‹å’Œï¼Œè¦æ³¨æ„æœ‰å‡åºé™åºä¸¤ç§ï¼Œä½†åªæœ‰ä¸€ç§æ•°æ—¶ä¸è€ƒè™‘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e6+7, mod=998244353; ll n,a[N],ans=0,vis[N],cnt=0,answ=1,com[N]; void solve(){ cin\u0026gt;\u0026gt;n; com[0]=1; for(int i=1;i\u0026lt;=n;i++){ com[i]=(com[i-1]*i)%mod; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; if(!vis[a[i]])cnt++; vis[a[i]]++; } sort(a+1,a+1+n); for(int i=1;i\u0026lt;=n;i++){ ll mx=a[i],mn=a[i]; for(int j=i+1;j\u0026lt;=n;j++){ mx=max(mx,a[j]),mn=min(mn,a[i]); ans+=(mx-mn); } } for(int i=1;i\u0026lt;=n;i++){ if(vis[a[i]]==1)continue; answ=(answ*com[vis[a[i]]])%mod; vis[a[i]]=1; } if (cnt \u0026gt; 1) answ = (answ * 2) % mod; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;answ\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D ç¼–ç å™¨-è§£ç å™¨ è§‚å¯Ÿé¢˜ç›®\n$S_i\u0026rsquo;=\\begin{cases}S_{i-1}\u0026rsquo;+a_i+S_{i-1}\u0026rsquo;\u0026amp; i\u0026gt;1\\\\a_1\u0026amp;i=1\\end{cases}$ å¯ä»¥å‘ç° $S_{i}\u0026rsquo;$ æ˜¯ç”± $S_{i-1}\u0026rsquo;$ å˜æ¢è€Œæ¥çš„ï¼Œæ‰€ä»¥å¯ä»¥é€’æ¨æ¯ä¸€ä½ $i$ ä¸Šçš„ç­”æ¡ˆ\nå¯ä»¥å¼€ä¸€ä¸ªä¸‰ç»´æ•°ç»„ $f[i][l][r]$ : $i$ æŒ‡ç¬¬å‡ ä½ $l$ æŒ‡ä» $t$ çš„ç¬¬å‡ ä½å¼€å§‹ $r$ æŒ‡åˆ° $t$ çš„ç¬¬å‡ ä½ç»“æŸ\né€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½• $t$ çš„æ‰€æœ‰å­ä¸²åœ¨å½“å‰ $i$ ä½å‡ºç°çš„æ¬¡æ•°ï¼Œåªéœ€è¦å°†æˆ‘ä»¬éœ€è¦çš„å­ä¸²æ‹¼æ¥èµ·æ¥å³å¯å¾—åˆ°èƒ½æ‰¾åˆ°çš„ $t$ ä¸²æ•°é‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; #define lowbit(x) ((x)\u0026amp;(-x)) typedef long long ll; const int N=1e2+7, mod=998244353; string s,t; int n,m; ll f[N][N][N]; void solve(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; n=s.length(),m=t.length(); for(int i=0;i\u0026lt;m;i++) if(s[0]==t[i])f[0][i][i]=1; for(int i=1;i\u0026lt;n;i++){ for(int l=0;l\u0026lt;m;l++){ for(int r=l;r\u0026lt;m;r++){ f[i][l][r]=(f[i-1][l][r]*2) % mod; if(l==r){ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+1) % mod; } else{ if(s[i]==t[l])f[i][l][r]=(f[i][l][r]+f[i-1][l+1][r]) % mod; if(s[i]==t[r])f[i][l][r]=(f[i][l][r]+f[i-1][l][r-1]) % mod; for(int k=l;k\u0026lt;r;k++) f[i][l][r]=(f[i][l][r]+f[i-1][l][k]*f[i-1][k+1][r]) % mod; for(int k=l+1;k\u0026lt;r;k++) if(s[i]==t[k])f[i][l][r]=(f[i][l][r]+f[i-1][l][k-1]*f[i-1][k+1][r]) % mod; } } } } cout\u0026lt;\u0026lt;f[n-1][0][m-1]\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/2024ccpconline/","summary":"å‘æŒ¥éš¾èšŒï¼Œå¥½åœ¨å­¦é•¿ä»–ä»¬è¿˜è¡Œï¼Œç®—æœ‰åé¢","title":"2024CCPCç½‘ç»œèµ›"},{"content":"2024 æ²³å—èŒæ–°è”èµ› 6 è£…å¤‡äºŒé€‰ä¸€ï¼ˆä¸€ï¼‰ ç›´æ¥æ¯”è¾ƒç»“æœå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int a, b, c, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; int t1 = 100 * b * a + 100 * (100 - a); int t2 = 100 * d * c + 100 * (100 - c); cout \u0026lt;\u0026lt; (t2 \u0026gt; t1 ? \u0026#34;YES\\n\u0026#34; : \u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } è¿½å¯»å…‰çš„æ–¹å‘ å¼€ä¸€ä¸ª $suf$ æ•°ç»„ï¼Œç”¨äºè®°å½• $i$ ä½ç½®åæœ€å¤§çš„æ•°çš„ä½ç½®ï¼Œå†ç”¨ $cnt$ ç»Ÿè®¡ä¸€å…±éœ€è¦å¤šå°‘æ¬¡è½¬ç§»å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls (now\u0026lt;\u0026lt;1) #define rs (now\u0026lt;\u0026lt;1|1) const int N = 1e5+7, mod = 1e9+7; int n, l[N], suf[N]; void solve() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i]; suf[n]=suf[n-1]=n; suf[n] = n; for (int i = n-1; i \u0026gt; 0; i--) { if (l[i+1] \u0026gt; l[suf[i+1]]) suf[i] = i+1; else suf[i] = suf[i+1]; } // for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;suf[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; int cnt = 0, now = 1; while (now \u0026lt; n) { now = suf[now]; cnt++; } cout \u0026lt;\u0026lt; cnt - 1 \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ç™¾å˜å—å–½ æœ¬èº«æƒ³ç”¨ $kmp$ æ‰¾æœ€é•¿å‰ç¼€æœ€é•¿åç¼€äºŒè€…ä¸¤åŠ ä¸º $n$ æ—¶å³ç¬¦åˆæ¡ä»¶ï¼Œä¸€ç›´åªå¯¹ $95%$ï¼Œæ”¹ä¸å‡ºæ¥ï¼Œæ¢é¢˜è§£çš„æ€è·¯äº†ï¼Œæ ‡è®°å‰ç¼€åç¼€ç›¸åŒçš„ä½ç½®ï¼Œå¦‚æœäºŒè€…èƒ½ç¢°åˆ°ï¼Œæˆ–è¶…è¿‡ï¼Œå°±æœ‰ç­”æ¡ˆå­˜åœ¨ï¼Œæ–¹æ¡ˆæ•°ä¸º $l-r+1$ ä¸ª\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int n,i1,i2; string s1,s2; int main(){ cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; n=s2.length(); for(i1=0;i1\u0026lt;n-1 \u0026amp;\u0026amp; s1[i1]==s2[i1];i1++); for(i2=n-1;i2\u0026gt;=0 \u0026amp;\u0026amp; s1[i2-1]==s2[i2];i2--); if(i2\u0026lt;=i1){ cout\u0026lt;\u0026lt;i1-i2+1\u0026lt;\u0026lt;endl; for(int i=i2;i\u0026lt;=i1;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s2[i]\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; return 0; } ","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B6/","summary":"åœ¨å®¶æ‰“çš„ï¼Œæ‰“ä¸€åŠæœ‰äº‹æ¶¦äº†","title":"2024èŒæ–°è”èµ›6"},{"content":"2024 æ²³å—èŒæ–°è”èµ› 5 å¹³æ–¹æ ¹ ç›´æ¥ $sqrt$ å‘ä¸‹å–æ•´å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ unsigned long long n; cin\u0026gt;\u0026gt;n; long long ans=floor(sqrt(n)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } çˆ¬æ¥¼æ¢¯ é€’å½’\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int f[1000005],mod=1e9+7; f[0]=f[1]=1; int n; cin\u0026gt;\u0026gt;n; for(int i=2;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=3;j++){ if(i-j\u0026lt;0)break; f[i]=(f[i]+f[i-j])%mod; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; } åŒºé—´é—®é¢˜ 1 çº¿æ®µæ ‘æ¿\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) #define int long long int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } signed main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); cin\u0026gt;\u0026gt;m; while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op; if (op == 1) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cin\u0026gt;\u0026gt;x; cout \u0026lt;\u0026lt; query(1, x, x, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } å“¥å¾·å·´èµ«çŒœæƒ³ åŸƒæ°ç­›æ‰¾ $5e4$ ä»¥å†…çš„è´¨æ•°ï¼Œæš´åŠ›æšä¸¾æ˜¯å¦æœ‰ç¬¦åˆçš„å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e7 + 7, mod = 1e9 + 7; bool isp[N]; vector\u0026lt;int\u0026gt; pri; void solve() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; pri.size(); i++) { for (int j = pri.size() - 1; j \u0026gt; i; j--) { int tmp = pri[i] + pri[j]; if(tmp\u0026gt;=n)continue; if (isp[n - tmp]) { cout \u0026lt;\u0026lt; pri[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n - tmp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pri[j] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } } } cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(isp, 1, sizeof(isp)); isp[0] = isp[1] = 0; for (int i = 2; i * i \u0026lt;= N; i++) { if (isp[i]) { for (int j = i * i; j \u0026lt;= N; j += i) isp[j] = 0; } } for (int i = 2; i \u0026lt;= N; i++) if (isp[i]) pri.push_back(i); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } å­¦ç”Ÿåˆ†ç»„ å…ˆæ‰¾è¶…å‡ºçš„ $mx$ï¼Œç¼ºå°‘çš„ $mn$ï¼Œå¦‚æœäºŒè€…ç›¸ç­‰ï¼Œç›´æ¥å¾—åˆ°ç­”æ¡ˆï¼Œå¦‚æœæœ‰ä¸€è€…æ›´å¤§ï¼Œå°±åˆ¤æ–­èƒ½å¦ç”¨å…¶ä»–çš„æ‰€æœ‰æ•°æ®è¡¥å…¨è¿™éƒ¨åˆ†ï¼Œå¦‚æœå¯ä»¥ç­”æ¡ˆå³ä¸ºè¿™éƒ¨åˆ†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N=1e6+7, mod=1e9+7; int n; ll l,r; ll a[N]; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; // sort(a+1,a+1+n); ll mn=0,mnn=0,mx=0,mxx=0; for(int i=1;i\u0026lt;=n;i++){ if(a[i]\u0026lt;l)mn+=(l-a[i]),mnn+=(r-a[i]); else if(a[i]\u0026gt;r)mx+=(a[i]-r),mxx+=(a[i]-l); else mnn+=(r-a[i]),mxx+=(a[i]-l); } ll ans=0; if(mx==mn)ans=mx; else if(mx\u0026gt;mn){ if(mx\u0026gt;mnn){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mx; } else{ if(mn\u0026gt;mxx){ cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; return; } ans=mn; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } å°ç¾æƒ³æ¸¸æ³³ $dijkstra$ ä½†æ˜¯æ‰¾çš„ä¸æ˜¯æœ€çŸ­è·¯ï¼Œè€Œæ˜¯è·¯å¾„ä¸­ç»è¿‡çš„ $max$ æœ€å°ï¼Œæ”¹å˜ $dist$ æ•°ç»„ä¸­ç»Ÿè®¡çš„æ•°æ®å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5; #define int long long const int INF = LLONG_MAX; struct Node { int y, v; Node(int _y, int _v) { y = _y; v = _v; } }; int n, m, s, t, dist[N]; vector\u0026lt;Node\u0026gt; edge[N]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); fill(dist, dist + N, INF); dist[s] = 0; q.insert({0, s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto i : edge[x]) { int new_dist = max(dist[x], i.v); if (new_dist \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = new_dist; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } signed main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, a; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; a; edge[u].push_back({v, a}); edge[v].push_back({u, a}); } cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; dijkstra(s, t); return 0; } å°ç¾æƒ³æ‰“éŸ³æ¸¸ æ˜¾ç„¶æ˜¯å°†æ‰€æœ‰åˆ†æ•°å˜ä¸ºå·²æœ‰åˆ†æ•°ä¸­çš„ä¸€ä¸ªï¼Œå°†æ•°ç»„æ’åºåï¼Œä»å°åˆ°å¤§éå†ï¼Œè®¡ç®—å½“å‰é­”åŠ›å€¼å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; int sum = 0; vector\u0026lt;int\u0026gt; a(n + 1,0); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; sum += a[i]; } int ans = LLONG_MAX, pre = 0; sort(a.begin() + 1, a.end()); for (int i = 1; i \u0026lt;= n; i++) { pre += a[i]; ans = min(ans, a[i] * i - pre + sum - pre - a[i] * (n - i)); } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; return 0; } åŒºé—´é—®é¢˜ 2 å¼€å§‹è§‰å¾—æ˜¯çº¿æ®µæ ‘ï¼Œä½†æ˜¯æ•°æ®æœ‰ $l = 0$, æµæ±—é»„è±†äº†\nç”¨ $st$ è¡¨å¯ä»¥è¿‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 2e6+7; #define int long long int n, m; int a[N]; int st[N][21]; int l2[N]; void build() { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; } for (int j = 1; (1 \u0026lt;\u0026lt; j) \u0026lt;= n; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j-1], st[i + (1 \u0026lt;\u0026lt; (j-1))][j-1]); } } } int query(int l, int r) { int j = l2[r - l + 1]; return max(st[l][j], st[r - (1 \u0026lt;\u0026lt; j) + 1][j]); } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; l2[1] = 0; for (int i = 2; i \u0026lt;= n; i++) { l2[i] = l2[i / 2] + 1; } build(); cin \u0026gt;\u0026gt; m; while (m--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; query(l, r) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } å°ç¾æƒ³è·‘æ­¥ å•å‘å»ºå›¾ï¼Œå»ºä¸¤ä¸ªï¼Œåå‘æ‰¾åˆ°çš„å€¼å³ä¸ºè·‘å›ç‚¹ $1$ çš„å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define endl \u0026#34;\\n\u0026#34; typedef long long ll; const int N = 1e6 + 7, mod = 1e9 + 7; #define int long long struct Node { int y, v; Node(int _y, int _v) : y(_y), v(_v) {} }; int n, m; vector\u0026lt;Node\u0026gt; edge[N], edges[N]; vector\u0026lt;int\u0026gt; dist(N); void dijkstra(int s, vector\u0026lt;Node\u0026gt;edge[]) { priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; q; fill(dist.begin(), dist.end(), INT_MAX); dist[s] = 0; q.push({0, s}); while (!q.empty()) { int d = q.top().first; int x = q.top().second; q.pop(); if (d \u0026gt; dist[x]) continue; for (auto\u0026amp; i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { dist[i.y] = dist[x] + i.v; q.push({dist[i.y], i.y}); } } } } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; edge[u].push_back({v, w}); edges[v].push_back({u, w}); } ll ans = 0; dijkstra(1, edge); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } dijkstra(1, edges); for (int i = 2; i \u0026lt;= n; i++) { ans += dist[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } æ—¥å†æ¸¸æˆ æš´åŠ› $SG$ å‡½æ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[30][20][40],day[20]={0,31,28,31,30,31,30,31,31,30,31,30,31}; void solve(){ int y,m,d; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; cout\u0026lt;\u0026lt;(sg[y%100][m][d]?\u0026#34;YES\\n\u0026#34;:\u0026#34;NO\\n\u0026#34;); } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); for(int i=8;i\u0026lt;=12;i++) for(int j=1;j\u0026lt;=31;j++)sg[24][i][j]=1; sg[24][8][1]=0; for(int i=24;i\u0026gt;=0;i--){ for(int j=12;j\u0026gt;=1;j--){ if(i==24\u0026amp;\u0026amp;j\u0026gt;=8)continue; int d=day[j]; if(i%4==0\u0026amp;\u0026amp;j==2)d++; for(int k=d;k\u0026gt;0;k--){ int x=i,y=j,z=k+1; if(z\u0026gt;d)z=1,y++; if(y\u0026gt;12)y=1,x++; if(sg[x][y][z]==0){ sg[i][j][k]=1; continue; } x=i,y=j+1,z=k; bool flag=0; if(y\u0026gt;12)y=1,x++,flag=1; else if(y!=2){ if(z\u0026lt;=day[y])flag=1; } else{ int tmp=28; if(i%4==0)tmp=29; if(z\u0026lt;=tmp)flag=1; } if(flag\u0026amp;\u0026amp;sg[x][y][z]==0)sg[i][j][k]=1; } } } int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } å°ç¾æƒ³æ”¶é›† å¯ä»¥äºŒåˆ†ç­”æ¡ˆï¼Œåˆ¤æ–­æ˜¯å¦ç¬¦åˆäºŒåˆ†å›¾çš„æ€§è´¨\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; int n, m; int f[N]; struct Node { int x, y, z; }; vector\u0026lt;Node\u0026gt; a; int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } bool check(int mid) { iota(f, f + n + n + 1, 0); for (auto x : a) { if (x.z \u0026gt; mid) { int fx = find(x.x), fy = find(x.y); if (fx == fy) return false; f[find(x.x + n)] = find(x.y); f[find(x.y + n)] = find(x.x); } } return true; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; a.resize(m + 1); for (int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; a[i].x \u0026gt;\u0026gt; a[i].y \u0026gt;\u0026gt; a[i].z; int l = 0, r = 1e6, ans = 0; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) r = mid - 1,ans=mid; else l = mid + 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B5/","summary":"æ¯”èµ›çˆ½çˆ½çˆ½çˆ½çˆ½","title":"2024èŒæ–°è”èµ›5"},{"content":"AtCoder Beginner Contest 366 è¡¥é¢˜ A - Election 2 åˆ¤æ–­å½“å‰æ˜¯å¦æœ‰å€¼å¤§äº $n/2$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,t,a; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t\u0026gt;\u0026gt;a; if(n==1\u0026amp;\u0026amp;t==0\u0026amp;\u0026amp;a==0){ cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } else if(t\u0026gt;n/2||a\u0026gt;n/2){ cout\u0026lt;\u0026lt;\u0026#34;Yes\\n\u0026#34;; } else cout\u0026lt;\u0026lt;\u0026#34;No\\n\u0026#34;; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B - Vertical Writing ç¿»è½¬å­—ç¬¦ä¸²ï¼ŒåŒæ—¶å¯¹ç¿»è½¬åçš„æ¯è¡Œä»æœ«å°¾å¼€å§‹æ¸… * å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,mx=0; cin\u0026gt;\u0026gt;n; string s[N]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; mx=max(mx,(int)s[i].length()); } string ans[mx+1]; for(int i=0;i\u0026lt;mx;i++){ for(int j=n;j\u0026gt;0;j--){ if(i\u0026gt;=s[j].length()) ans[i]+=\u0026#34;*\u0026#34;; else ans[i]+=s[j][i]; } } for(int i=0;i\u0026lt;mx;i++){ bool flag=0; for(int j=n-1;j\u0026gt;=0;j--){ if(ans[i][j]==\u0026#39;*\u0026#39;\u0026amp;\u0026amp;!flag){ ans[i][j]=\u0026#39; \u0026#39;; } if(ans[i][j]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;ans[i][j]\u0026lt;=\u0026#39;z\u0026#39;){ flag=1; } } cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C - Balls and Bag Query å¼€ä¸€ä¸ª map è®°å½•æŸä¸€ä¸ªå€¼å½“å‰å‡ºç°äº†å‡ æ¬¡ï¼Œç¬¬ä¸€æ¬¡å‡ºç°å°± cnt++, å‡ºç°æ¬¡æ•°å˜ä¸º 0 å°± cnt\u0026ndash; æœ€åè¾“å‡º cnt\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int q; cin\u0026gt;\u0026gt;q; unordered_map\u0026lt;int,int\u0026gt;vis; int cnt=0; while(q--){ int op,x; cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x; if(!vis[x])cnt++; vis[x]++; } else if(op==2){ cin\u0026gt;\u0026gt;x; vis[x]--; if(!vis[x])cnt--; } else cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } D - Cuboid Sum Query ä¸‰ç»´å‰ç¼€å’Œæ¿\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e2+10, mod = 1e9+7; #define int long long void solve(){ int n, a[N][N][N], q, lx, rx, ly, ry, lz, rz; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt;= n; j++){ for(int k = 1; k \u0026lt;= n; k++) cin \u0026gt;\u0026gt; a[i][j][k]; } } for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i - 1][j][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j - 1][k]; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) for (int k = 1; k \u0026lt;= n; ++k) a[i][j][k] += a[i][j][k - 1]; cin \u0026gt;\u0026gt; q; while(q--){ cin \u0026gt;\u0026gt; lx \u0026gt;\u0026gt; rx \u0026gt;\u0026gt; ly \u0026gt;\u0026gt; ry \u0026gt;\u0026gt; lz \u0026gt;\u0026gt; rz; ll sum = a[rx][ry][rz] - (lx \u0026gt; 1 ? a[lx-1][ry][rz] : 0) - (ly \u0026gt; 1 ? a[rx][ly-1][rz] : 0) - (lz \u0026gt; 1 ? a[rx][ry][lz-1] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 ? a[lx-1][ly-1][rz] : 0) + (lx \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ry][lz-1] : 0) + (ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[rx][ly-1][lz-1] : 0) - (lx \u0026gt; 1 \u0026amp;\u0026amp; ly \u0026gt; 1 \u0026amp;\u0026amp; lz \u0026gt; 1 ? a[lx-1][ly-1][lz-1] : 0); cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } } signed main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } E - Manhattan Multifocal Ellipse å¯ä»¥æšä¸¾ $x$ ä» $-2e6$ åˆ° $2e6$ï¼Œå»æ‰åŸå¼ä¸­çš„ç»å¯¹å€¼å¾—åˆ°ï¼Œ$\\sum_{x_i \u0026lt; x} (x - x_i) + \\sum_{x_i \\geq x} (x_i - x)$ï¼Œé€šè¿‡æ­¤å…¬å¼å¯ä»¥å¾—åˆ°æ¯ä¸ª $x$ çš„ $\\sum_{i=1}^{n} |x - x_i|$ï¼ŒåŒç†æ±‚å¾— $\\sum_{i=1}^{n} |y - y_i|$ï¼Œåˆ†åˆ«å­˜å…¥ä¸¤ä¸ªæ•°ç»„ï¼Œå°†ä¸¤ä¸ªæ•°ç»„å‡åºæ’åºï¼Œæ­¤æ—¶åªéœ€è¦ç”¨åŒæŒ‡é’ˆå¯¹æ¯ä¸ª $x$ æ‰¾åˆ°å…¶å¯¹åº”çš„æœ€å¤§çš„ $y$ å¯¹åº”çš„ä½ç½®ï¼Œç´¯åŠ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; auto fc(vector\u0026lt;int\u0026gt; \u0026amp;a){ sort(a.begin(), a.end()); vector\u0026lt;ll\u0026gt; dis; int r = 2e6+7; int id = 0; ll pre = 0, suf = accumulate(a.begin(), a.end(), 0LL); for(int i = -r; i \u0026lt;= r; i++){ ll sum = 0; while(id \u0026lt; a.size() \u0026amp;\u0026amp; a[id] \u0026lt; i){ pre += a[id]; suf -= a[id]; ++id; } sum = 1LL * id * i - pre + suf - 1LL * (a.size() - id) * i; dis.push_back(sum); } sort(dis.begin(), dis.end()); return dis; } void solve(){ int n, d; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d; vector\u0026lt;int\u0026gt; x(n), y(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; auto dx = fc(x); auto dy = fc(y); ll ans = 0; int id = dx.size(); for(auto i : dx){ while(id \u0026gt; 0 \u0026amp;\u0026amp; dy[id-1] + i \u0026gt; d) --id; ans += id; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } F - Maximum Composition å‡½æ•°ä¹‹é—´ï¼Œé€‰æ‹©çš„ååºï¼ˆé¡ºåºï¼‰é—®é¢˜ã€‚è¿™ä¸ªååºæ€ä¹ˆå®šä¹‰å‘¢ï¼Ÿå‡½æ•° $f_i, f_j$ï¼Œå¦‚æœ $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$ï¼Œåˆ™æœ‰ $a_i(a_jx + b_j) + b_i \\geq a_j(a_ix + b_i) + b_j$ï¼Œæˆ‘ä»¬æŠŠ $i, j$ åˆ†ç¦»åœ¨ä¸€å·¦ä¸€å³ï¼Œå¾—åˆ° $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$ã€‚\nå¦‚æœ $\\frac{a_i - 1}{b_i} \\geq \\frac{a_j - 1}{b_j}$ï¼Œåˆ™ $f_i(f_j(x)) \u0026gt; f_j(f_i(x))$ï¼Œé‚£ä¹ˆæ’åºé¡ºåºå·²ç»æ¸…æ™°\nè¦ä½¿ $ans$ æœ€å¤§ï¼Œä¸å…‰è¦æ‰¾åˆ°ååºé¡ºåºï¼Œè¿˜è¦æ‰¾åˆ°ç”¨å“ª k ä¸ªå‡½æ•°ï¼Œé‚£å°±è½¬åŒ–ä¸ºäº† 01èƒŒåŒ… é—®é¢˜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 2e5+7, mod = 1e9+7; struct Node { int a, b; bool operator \u0026lt; (const Node \u0026amp;t) const { return (a - 1) * t.b \u0026lt; (t.a - 1) * b; } }; void solve() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;Node\u0026gt; l(n + 1); for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; l[i].a \u0026gt;\u0026gt; l[i].b; sort(l.begin()+1,l.end()); vector\u0026lt;ll\u0026gt; dp(k + 1, 0); dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = k; j \u0026gt;= 1; j--) { dp[j] = max(dp[j - 1] * l[i].a + l[i].b, dp[j]); } } cout \u0026lt;\u0026lt; dp[k] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/abc366/","summary":"AtCoder Beginner Contest 366 è¡¥é¢˜","title":"ABC366"},{"content":"2024 æ­ç”µå¤šæ ¡ 4 è¡¥é¢˜ å¤šå±‚è¡€æ¡ æ¨¡æ‹Ÿ, åªä¼šæœ€è¦†ç›–æœ€ä¸Šé¢çš„ä¸€å±‚è¡€é‡, æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒä¸‹å±‚è¡€é‡æ˜¯ä»€ä¹ˆ, åªç”¨æ‰¾åˆ°æœ€ä¸Šé¢çš„é‚£ä¸€å±‚æ˜¯ä»€ä¹ˆå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string h=\u0026#34;ABCDE\u0026#34;; void solve(){ int n,m,hp,dmg; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;hp\u0026gt;\u0026gt;dmg; int lst=(hp/m)%5,x=m; string upp; upp.resize(m+1,\u0026#39; \u0026#39;); if(hp\u0026lt;=m){ for(int i=1;i\u0026lt;=hp;i++)upp[i]=h[0],x=i; } else{ int rest=hp%m; // cout\u0026lt;\u0026lt;rest\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;i++){ if(rest)upp[i]=h[lst],x=i,rest--; else upp[i]=h[(lst-1+5)%5]; } } while(dmg){ if(upp[x]==\u0026#39;.\u0026#39;)break; upp[x]=\u0026#39;.\u0026#39;; x--; dmg--; if(x==0)x=m; } for(int i=0;i\u0026lt;=n+1;i++){ for(int j=0;j\u0026lt;=m+1;j++){ if((i==0\u0026amp;\u0026amp;j==0)||(i==0\u0026amp;\u0026amp;j==m+1)||(i==n+1\u0026amp;\u0026amp;j==0)||(i==n+1\u0026amp;\u0026amp;j==m+1))cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; else if(i==0||i==n+1)cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; else if(j==0||j==m+1)cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;; else cout\u0026lt;\u0026lt;upp[j]; } cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æ˜µç§°æ£€ç´¢ æ˜µç§°åˆ†å§“åå’Œç”Ÿæ—¥ä¸¤éƒ¨åˆ†, è€Œå§“åéœ€åœ¨ç”Ÿæ—¥å‰, é‚£ä¹ˆå°±è¦æ‰¾å°½é‡å‰çš„å§“å, å°½é‡åçš„ç”Ÿæ—¥\né¢„å¤„ç† $nxt[i][j]$ è¡¨ç¤º $s[i][n]$ ä¸­å­—ç¬¦ $j$ æœ€é å·¦çš„å‡ºç°ä½ç½®, ä»å·¦åˆ°å³æ‰¾åˆ°åå­—çš„æœ€åä¸€ä½åœ¨å“ª, è®°ä¸º $a[i]$, åŒç†,å€’ç€æ±‚ç”Ÿæ—¥çš„æœ€åä¸€ä½åœ¨å“ª, è®°ä¸º $b[i]$\næœ€åæ‰¾æœ‰å¤šå°‘å¯¹ $(i, j)$ æ»¡è¶³ $i \u0026lt; j$ å³å¯.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e6+7, mod=1e9+7; int n,m,ans[N]; int day[15] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string s,a; int vis[26],mp[N][26]; int fd(int *u){ int x=m+1; for(int i=3;~i;i--){ x--; if(x\u0026lt;1)return 0; x=mp[x][u[i]]; } return x; } int fc(){ int x=0; for(int i=0;i\u0026lt;a.size();i++){ x++; if(x\u0026gt;m)return m+1; x=mp[x][a[i]-\u0026#39;a\u0026#39;]; } return x; } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;10;i++)vis[i]=0; for(int i=1;i\u0026lt;=m;i++){ if(s[i-1]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;9\u0026#39;)vis[s[i-1]-\u0026#39;0\u0026#39;]=i; for(int j=0;j\u0026lt;=9;j++)mp[i][j]=vis[j]; } for(int i=0;i\u0026lt;=m+1;i++)ans[i]=0; for(int i=1;i\u0026lt;=12;i++){ for(int j=1;j\u0026lt;=day[i];j++){ int p[4]; p[0]=i/10,p[1]=i%10,p[2]=j/10,p[3]=j%10; int x=fd(p); if(x)ans[x]++; } } for(int i=m;i\u0026gt;1;i--)ans[i-1]+=ans[i]; for(int j=0;j\u0026lt;26;j++)vis[j]=m+1; for(int i=m;i;i--){ if(s[i-1]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;s[i-1]\u0026lt;=\u0026#39;z\u0026#39;)vis[s[i-1]-\u0026#39;a\u0026#39;]=i; for(int j=0;j\u0026lt;26;j++)mp[i][j]=vis[j]; } int sum=0; while(n--){ cin\u0026gt;\u0026gt;a; int x=fc(); if(x\u0026lt;m)sum+=ans[x+1]; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } æœ€ä¼˜ $k$ å­æ®µ å‰ç¼€å’Œç»Ÿè®¡åŒºé—´å’Œ, ç”¨äºŒåˆ†æ‰¾ç­”æ¡ˆ\nå¼€ä¸€ä¸ª set å­˜å½“å‰å‰ç¼€å’Œå’Œä½ç½®, åˆ¤æ–­åˆæ³•åŒºé—´æ¡ä»¶ä¸º, å½“å‰ä½ç½®èƒ½å¦å’Œ set ä¸­æ‰€å­˜çš„å…ƒç´ æ„æˆå¤§äºç­‰äº $lim$ çš„ä¸€ä¸ªç‰‡æ®µ, åŒæ—¶ç‰‡æ®µé•¿åº¦è¦ä¸ºè´¨æ•°, å¦‚æœèƒ½æ‰¾åˆ°, å°±å°†å½“å‰è®°å½•ä¸ªæ•° + 1.\näºŒåˆ†æ¡ä»¶å³ä¸º check è¿”å›çš„å€¼æ˜¯å¦å¤§äºç­‰äº $k$, éœ€è¦æ³¨æ„ $k * 2 \\leq n$, å› ä¸ºæœ€å°çš„è´¨æ•°ä¸º 2, $k * 2$ æ˜¯ $n$ çš„æœ€å°é•¿åº¦\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 typedef long long ll; const int N=1e8+7, mod=1e9+7; bool ip[N]; int n,k; ll a[N]; int check(int lim){ set\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; s; s.insert({0,0}); int res=0; for(int i=1;i\u0026lt;=n;i++){ auto it = s.begin(); while(it != s.end()){ if(a[i] - it-\u0026gt;first \u0026lt; lim) it = s.end(); else if(ip[i - it-\u0026gt;second]) break; else it++; } if(it != s.end()) res++, s.clear(); s.insert({a[i], i}); } return res; } void solve(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i=1; i\u0026lt;=n; i++){ cin \u0026gt;\u0026gt; a[i]; a[i]+=a[i-1]; } if(2*k \u0026gt; n){ cout \u0026lt;\u0026lt; \u0026#34;impossible\\n\u0026#34;; return; } int l = -2000, r = N; while(l \u0026lt; r){ ll mid = (l + r + 1) \u0026gt;\u0026gt; 1; if(check(mid) \u0026gt;= k) l = mid; else r = mid - 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); memset(ip, 1, sizeof(ip)); ip[0] = ip[1] = 0; for(int i=2; i*i\u0026lt;=N; i++){ if(ip[i]){ for(int j=i*i; j\u0026lt;=N; j+=i) ip[j]=0; } } int t; cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/2024hdu4/","summary":"éš¾éš¾éš¾éš¾","title":"2024HDU4"},{"content":"2024 èŒæ–°è”èµ› 4 D ç®€å•çš„ç´ æ•° éå† $1 \\sim \\sqrt{n}$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8+10; void solve(){ int n,flag=0; cin\u0026gt;\u0026gt;n; for(int i=2;i*i\u0026lt;=n;i++){ if(n%i==0){ flag=1; break; } } cout\u0026lt;\u0026lt;(flag?\u0026#34;No\\n\u0026#34;:\u0026#34;Yes\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } F å°é›·çš„ç®—å¼ æŒ‰é¢˜æ„æ¨¡æ‹Ÿ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; #define int long long void solve(){ string s; cin\u0026gt;\u0026gt;s; int ans=0,tmp=0; vector\u0026lt;int\u0026gt;a; for(int i=0;i\u0026lt;s.size();i++){ if(s[i]==\u0026#39;+\u0026#39;){ a.push_back(tmp); ans+=tmp,tmp=0; } else{ tmp*=10; tmp+=(s[i]-\u0026#39;0\u0026#39;); } } a.push_back(tmp); ans+=tmp; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;()); cout\u0026lt;\u0026lt;a[0]; for(int i=1;i\u0026lt;a.size();i++){ cout\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;a[i]; } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } H èªæ˜ä¸”ç‹¡çŒ¾çš„æ¶é­” $1$ å·æ¶é­”ä¸ºäº†ä¿è¯è‡ªå·±èƒ½è·èƒœï¼Œä¼šç»™ $\\frac{n}{2}$ ä¸ªæ¶é­”ä¸€äººä¸€ä¸ªé‡‘å¸ï¼Œä¿è¯è‡ªå·±èƒ½è·èƒœ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; void solve(){ int n,x; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;n; int ans=x; if(n\u0026amp;1)ans-=n/2; else ans-=n/2-1; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B å°é›·çš„ç¥å¥‡ç”µè„‘ ç»éªŒè¯ï¼Œå¯å¾—ç­”æ¡ˆä¼šåœ¨æ’åºåç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ä¸­å¾—å‡º\nåŒæˆ–ç»“æœå³ä¸ºï¼šæ‰€æœ‰ä½éƒ½ä¸º $1$ çš„å€¼å‡å»äºŒè€…çš„å¼‚æˆ–\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int a[n+100]; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int u[32],cnt=1; u[0]=1; for(int i=1;i\u0026lt;32;i++){ cnt*=2; u[i]=u[i-1]+cnt; } sort(a+1,a+1+n); int ans=2e9; for(int i=1;i\u0026lt;n;i++){ ans=min(ans,a[i]^a[i+1]); } cout\u0026lt;\u0026lt;u[m-1]-ans\u0026lt;\u0026lt;endl; } C å²—ä½åˆ†é… å¿—æ„¿è€…æ— å·®åˆ«ï¼Œæ„æ€æ˜¯åˆ†é…åˆ°å²—ä½ä¸Šçš„æ˜¯è°ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯äººæ•°\nå…ˆå›ºå®šæ¯ä¸ªå²—ä½è¯¥æœ‰çš„äººï¼Œå†å¯¹å‰©ä¸‹çš„äººåˆ†æ\nå‰©ä¸‹çš„äººæ¯ä¸ªäººéƒ½æœ‰ $(n + 1)$ ç§é€‰æ‹©ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯å°†ä»–ä»¬åˆ†ä¸º $(n + 1)$ ç»„ï¼Œå³ç”¨ $n$ ä¸ªéš”æ¿åˆ†å¼€ä»–ä»¬\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7, mod = 998244353; ll pre[N]; void init(){ pre[0] = 1; for(int i = 1; i \u0026lt; N; i++){ pre[i] = (pre[i-1] * i) % mod; } } ll rmod(ll a, ll m) { ll res = 1, y = m - 2; while (y \u0026gt; 0) { if (y % 2 == 1) res = (res * a) % m; a = (a * a) % m; y /= 2; } return res; } ll com(ll n, ll k) { if (k \u0026gt; n) return 0; return pre[n] * rmod(pre[k], mod) % mod * rmod(pre[n - k], mod) % mod; } ll mod_exp(ll base, ll exp, ll m) { ll res = 1; while (exp \u0026gt; 0) { if (exp % 2 == 1) res = (res * base) % m; base = (base * base) % m; exp /= 2; } return res; } void solve(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); ll ans = 1; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i]; m-=a[i]; } ans = (ans * com(m+n, m)) % mod; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; init(); // cin \u0026gt;\u0026gt; t; while(t--) solve(); return 0; } I é©¬æ‹‰æ¾ $x \\rightarrow y$ ä¸­é—´çš„ç‚¹éƒ½å¿½ç•¥ï¼Œæ‰¾ä¸¤ä¾§å„æœ‰å‡ ä¸ªç‚¹ï¼Œç›¸ä¹˜å³ä¸ºç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 3e5+7; int n,x,y; int s[N],vis[N]; vector\u0026lt;int\u0026gt;v[N]; bool onxy[N]; int dfs(int x){ vis[x]=1; s[x]=1; if(x==y)onxy[x]=1; for(auto i:v[x]){ if(!vis[i]){ s[x]+=dfs(i); onxy[x]|=onxy[i]; } } return s[x]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(x); int lx; for(auto i:v[x]){ if(onxy[i]==1){ lx=s[x]-s[i]; } } cout\u0026lt;\u0026lt;1LL*lx*s[y]\u0026lt;\u0026lt;endl; } J å°–å¡”ç¬¬å››å¼ºçš„é«˜æ‰‹ LCA æ¿ï¼Œå°äº $1e5$ çš„ fibonacci æ•°åªæœ‰ $24$ ä¸ªï¼Œæå‰æ‰¾åˆ°ï¼Œå†æ ¹æ®é¢˜æ„ï¼Œå¯¹æ‰€æœ‰çš„ç‚¹ä¾æ¬¡è·‘ LCA å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 const int N = 1e5+7, mod = 1e9+7; vector\u0026lt;int\u0026gt; v[N]; int d[N], f[N][32]; vector\u0026lt;int\u0026gt; a; void dfs(int x, int y) { d[x] = d[y] + 1; f[x][0] = y; for (int i = 1; i \u0026lt;= 31; i++) { f[x][i] = f[f[x][i-1]][i-1]; } for (int i = 0; i \u0026lt; v[x].size(); i++) { if (d[v[x][i]] == 0) dfs(v[x][i], x); } } int lca(int x, int y) { if (d[x] \u0026lt; d[y]) swap(x, y); for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; d[f[x][i]] \u0026gt;= d[y]) x = f[x][i]; } if (x == y) return x; for (int i = 31; i \u0026gt;= 0; i--) { if (f[x][i] != 0 \u0026amp;\u0026amp; f[y][i] != 0 \u0026amp;\u0026amp; f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } return f[x][0]; } void solve() { int f1 = 1, f2 = 1; a.push_back(f1); a.push_back(f2); while (true) { int nxt = f1 + f2; if (nxt \u0026gt; N) break; a.push_back(nxt); f1 = f2; f2 = nxt; } int n, r, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; r \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt; n; i++) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; v[x].push_back(y); v[y].push_back(x); } dfs(r, 0); while (q--) { int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; tmp; for (int i = k; i \u0026lt; a.size(); i++) { if (x + a[i] \u0026gt; n) break; tmp.push_back(x + a[i]); } int ans=0; if(tmp.size()){ ans = tmp[0]; for (int i = 1; i \u0026lt; tmp.size(); i++) { ans = lca(ans, tmp[i]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } E AND è´¨æ•°åªæœ‰ä¸€ä¸ªå¶æ•° $2$ï¼Œå¦‚æœæ²¡æœ‰ $2$ï¼Œå°±ä¸å¯èƒ½æœ‰ç¬¦åˆçš„åŒºé—´ï¼Œå› ä¸ºæœ€åä¸€ä½ä¸€å®šä¸º $1$\nåœ¨æœ‰ $2$ çš„æ—¶å€™ï¼Œå› ä¸ºå¿…é¡»é€‰ $2$ï¼ŒåŒæ—¶ $2, 3$ è¿™ä¸ªåŒºé—´ä¹Ÿä¸ç¬¦åˆï¼Œç¬¦åˆæ¡ä»¶çš„å°±æœ‰ $r - l + 1 - 2$ ä¸ªï¼Œå¦‚æœåªæœ‰ $2$ï¼Œè¦è®°å¾—ç‰¹åˆ¤\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e8 + 10; vector\u0026lt;int\u0026gt; prime; bool isnp[N]; void pre(int n) { fill(isnp, isnp + n + 1, false); for (int i = 2; i \u0026lt;= n; i++) { if (!isnp[i]) prime.push_back(i); for (auto j : prime) { if (j * i \u0026gt; n) break; isnp[j * i] = true; if (i % j == 0) break; } } } void solve() { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; auto l = lower_bound(prime.begin(), prime.end(), x)-prime.begin(); auto r = upper_bound(prime.begin(), prime.end(), y)-prime.begin(); cout \u0026lt;\u0026lt; (r - l) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (x == 2 \u0026amp;\u0026amp; x == y || x \u0026gt; 2) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; else { cout \u0026lt;\u0026lt; (r - l - 2) \u0026lt;\u0026lt; endl; } } int main() { pre(N); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } K æ¯”èµ› ç”¨çº¿æ®µæ ‘ï¼Œè®°å½•æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œå†ä»å·¦åˆ°å³ï¼Œä»å³åˆ°å·¦ï¼Œå„æŸ¥è¯¢ä¸€éï¼Œè®°å½•å·¦å³ä¸¤æ¬¡æ¯” $a[i]$ å¤§ã€å°ã€ç›¸ç­‰çš„æœ‰å‡ ä¸ªï¼Œæœ€åå¾—åˆ°ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long lll; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) const int N = 1e5 + 7, mod = 1e9 + 7; int n, a[N], tr[N \u0026lt;\u0026lt; 2], ll[N], lu[N], rl[N], ru[N], le[N], re[N]; void update(int now, int l, int r, int pos, int val) { if (l == r) { tr[now] += val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(ls, l, mid, pos, val); else update(rs, mid + 1, r, pos, val); tr[now] = tr[ls] + tr[rs]; } int query(int now, int l, int r, int s, int t) { if (s \u0026gt; r || t \u0026lt; l) return 0; if (s \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) return tr[now]; int mid = (l + r) \u0026gt;\u0026gt; 1; return query(ls, l, mid, s, t) + query(rs, mid + 1, r, s, t); } void solve() { lll ans = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; memset(tr, 0, sizeof(tr)); for (int i = 1; i \u0026lt;= n; i++) { ll[i] = query(1, 1, N, 1, a[i]); lu[i] = query(1, 1, N, a[i], N); le[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); } memset(tr, 0, sizeof(tr)); for (int i = n; i \u0026gt; 0; i--) { rl[i] = query(1, 1, N, 1, a[i]); ru[i] = query(1, 1, N, a[i], N); re[i] = query(1, 1, N, a[i], a[i]); update(1, 1, N, a[i], 1); ans += 1LL * rl[i] * lu[i]; ans += 1LL * ru[i] * ll[i]; ans -= 1LL * re[i] * le[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B4/","summary":"æ¯”èµ›çˆ½çˆ½çˆ½çˆ½","title":"2024èŒæ–°è”èµ›4"},{"content":"LCA(æœ€è¿‘å…¬å…±ç¥–å…ˆ) ç®€ä»‹ ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå°±æ˜¯ä¸¤ä¸ªç‚¹çš„å…¬å…±ç¥–å…ˆé‡Œï¼Œç¦»æ ¹æœ€è¿œçš„é‚£ä¸ª\n$LCA({u}) = u$ $u$ æ˜¯ $v$ çš„ç¥–å…ˆï¼Œå½“ä¸”ä»…å½“ $LCA({u, v}) = u$ å¦‚æœ $u, v$ äº’ä¸ä¸ºç¥–å…ˆï¼Œé‚£ä¹ˆäºŒè€…å­˜åœ¨ $LCA({u, v})$ çš„ä¸¤é¢—ä¸åŒå­æ ‘ä¸­ å‰åºéå†ä¸­ï¼Œ$LCA(S)$ å‡ºç°åœ¨æ‰€æœ‰ $S$ ä¸­å…ƒç´ ä¹‹å‰ï¼Œååºéå†ä¸­ $LCA(S)$ åˆ™å‡ºç°åœ¨æ‰€æœ‰ $S$ ä¸­å…ƒç´ ä¹‹å ä¸¤ç‚¹é›†å¹¶çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸ºä¸¤ç‚¹é›†åˆ†åˆ«çš„æœ€è¿‘å…¬å…±ç¥–å…ˆçš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå³ $LCA(A\\cup B)=LCA(LCA(A), LCA(B))$ ä¸¤ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆå¿…å®šå¤„åœ¨æ ‘ä¸Šä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯ä¸Š $d(u,v)=h(u)+h(v)-2h(LCA(u,v))$ï¼Œå…¶ä¸­ $d$ æ˜¯æ ‘ä¸Šä¸¤ç‚¹é—´çš„è·ç¦»ï¼Œ$h$ ä»£è¡¨æŸç‚¹åˆ°æ ‘æ ¹çš„è·ç¦» æ±‚æ³• æœ´ç´ ç®—æ³• æ¯æ¬¡éƒ½æ‰¾æ·±åº¦è¾ƒå¤§çš„ç‚¹ï¼Œä»¤å…¶å‘ä¸Šæœç´¢ï¼Œæ˜¾ç„¶ä¸¤ä¸ªç‚¹æœ€åä¼šç›¸é‡ï¼Œç›¸é‡ä½ç½®å³ä¸º $LCA$ï¼Œæˆ–è€…å…ˆè°ƒæ•´æ·±åº¦è¾ƒå¤§çš„ç‚¹ï¼Œä½¿äºŒè€…æ·±åº¦ç›¸åŒåï¼Œä¸€èµ·å‘ä¸Šè·³è½¬ï¼Œæœ€åä¹Ÿä¼šç›¸é‡\néœ€è¦å…ˆ $dfs$ é¢„å¤„ç†æ•´æ£µæ ‘ï¼Œæ­¤è¿‡ç¨‹ä¸º $O(n)$, æŸ¥è¯¢è¿‡ç¨‹ä¹Ÿä¸º $O(n)$\nå€å¢ç®—æ³• ç®€ä»‹ æ˜¯æœ´ç´ ç®—æ³•çš„æ”¹è¿›ç‰ˆæœ¬ï¼Œé¢„å¤„ç† $fa[x][i]$ æ•°ç»„ï¼Œä½¿æ¸¸æ ‡å¯ä»¥å¿«é€Ÿç§»åŠ¨ï¼Œå‡å°‘è·³è½¬æ¬¡æ•°ã€‚\n$fa[x][i]$ è¡¨ç¤ºçš„æ˜¯ç‚¹ $x$ çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆã€‚å¯ä»¥é€šè¿‡ $dfs$ é¢„å¤„ç†å¾—åˆ°\nä¼˜åŒ–è·³è½¬çš„è¿‡ç¨‹ï¼šé¦–å…ˆï¼Œæˆ‘ä»¬è¦å°† $u, v$ è·³è½¬åˆ°åŒä¸€æ·±åº¦ï¼Œè®¡ç®—å¾—å‡ºäºŒè€…æ·±åº¦ä¹‹å·®ä¸º $y$ï¼Œå°† $y$ ç”¨äºŒè¿›åˆ¶æ‹†åˆ†ï¼Œå°† $y$ æ¬¡æ¸¸æ ‡è·³è½¬ä¼˜åŒ–ä¸º $y$ çš„äºŒè¿›åˆ¶ä¸­ $1$ çš„ä¸ªæ•°æ¬¡è·³è½¬ã€‚æ¥ç€ä»æœ€å¤§çš„ $i$ å¼€å§‹å¾ªç¯å°è¯•ï¼Œä¸€ç›´åˆ° $0$ï¼Œå¦‚æœ $fa[u][i] \\neq fa[v][i]$ï¼Œé‚£ä¹ˆæœ€åçš„ $LCA$ ä¸º $fa[u][0]$\né¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \\log n)$, æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(\\log n)$\næ¨¡æ¿ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 6e5+7; int n,m,s; vector\u0026lt;int\u0026gt;v[N]; int d[N],f[N][32]; void dfs(int x,int y){ d[x]=d[y]+1; f[x][0]=y; for(int i=1;i\u0026lt;=31;i++){ f[x][i]=f[f[x][i-1]][i-1]; } for(int i=0;i\u0026lt;v[x].size();i++){ if(d[v[x][i]]==0)dfs(v[x][i],x); } } int lca(int x,int y){ if(d[x]\u0026lt;d[y])swap(x,y); for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;d[f[x][i]]\u0026gt;=d[y]) x=f[x][i]; } if(x==y)return x; for(int i=31;i\u0026gt;=0;i--){ if(f[x][i]!=0\u0026amp;\u0026amp;f[y][i]!=0\u0026amp;\u0026amp;f[x][i]!=f[y][i]){ x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;n;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; v[x].push_back(y); v[y].push_back(x); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;lca(x,y)\u0026lt;\u0026lt;endl; } } ä¾‹é¢˜ HDU 2586 æ ‘ä¸Šæœ€çŸ­è·¯æŸ¥è¯¢\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 40005; vector\u0026lt;int\u0026gt;v[N],w[N]; int fa[N][31],cost[N][31],dep[N]; int n,m,a,b,c; void dfs(int now,int fno){ fa[now][0]=fno; dep[now]=dep[fa[now][0]]+1; for(int i=1;i\u0026lt;31;i++){ fa[now][i]=fa[fa[now][i-1]][i-1]; cost[now][i]=cost[fa[now][i-1]][i-1]+cost[now][i-1]; } int sz=v[now].size(); for(int i=0;i\u0026lt;sz;i++){ if(v[now][i]==fno)continue; cost[v[now][i]][0]=w[now][i]; dfs(v[now][i],now); } } int lca(int x,int y){ if(dep[x]\u0026gt;dep[y])swap(x,y); int tmp=dep[y]-dep[x],ans=0; for(int j=0;tmp;++j,tmp\u0026gt;\u0026gt;=1){ if(tmp\u0026amp;1)ans+=cost[y][j],y=fa[y][j]; } if(y==x)return ans; for(int j=30;j\u0026gt;=0\u0026amp;\u0026amp;y!=x;j--){ if(fa[x][j]!=fa[y][j]){ ans+=cost[x][j]+cost[y][j]; x=fa[x][j]; y=fa[y][j]; } } ans+=cost[x][0]+cost[y][0]; return ans; } void solve(){ memset(fa,0,sizeof(fa)); memset(cost,0,sizeof(cost)); memset(dep,0,sizeof(dep)); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ v[i].clear(); w[i].clear(); } for(int i=1;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; v[a].push_back(b); v[b].push_back(a); w[a].push_back(c); w[b].push_back(c); } dfs(1,0); for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;lca(a,b)\u0026lt;\u0026lt;endl; } } int main(){ ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } Tarjan ç®—æ³• ç®€ä»‹ æ˜¯ç¦»çº¿ç®—æ³•ï¼Œéœ€è¦ä½¿ç”¨å¹¶æŸ¥é›†è®°å½•æŸä¸ªç»“ç‚¹çš„ç¥–å…ˆç»“ç‚¹\né¦–å…ˆæ¥å—è¾“å…¥è¾¹(é¢†æ¥é“¾è¡¨)ï¼ŒæŸ¥è¯¢è¾¹(å¦ä¸€ä¸ªé“¾è¡¨ä¸­)ã€‚æŸ¥è¯¢è¾¹å…¶å®æ˜¯è™šæ‹ŸåŠ çš„è¾¹ï¼Œæ¯æ¬¡è¾“å…¥æŸ¥è¯¢è¾¹çš„æ—¶å€™ï¼Œéƒ½å°†æ­¤è¾¹å’Œå…¶åå‘è¾¹åŠ å…¥åˆ° $queryedge$ æ•°ç»„é‡Œ ç„¶åå¯¹å…¶è¿›è¡Œ $DFS$ éå†ï¼ŒåŒæ—¶ä½¿ç”¨ $vis$ æ•°ç»„è®°å½•ç»“ç‚¹æ˜¯å¦è¢«è®¿é—®ï¼Œ$parent$ è®°å½•å½“å‰ç»“ç‚¹çš„çˆ¶äº²ç»“ç‚¹ æ¯æ¬¡éå†åˆ°æŸä¸ªç»“ç‚¹çš„æ—¶å€™ï¼Œè®¤ä¸ºè¿™ä¸ªç»“ç‚¹çš„æ ¹èŠ‚ç‚¹å°±æ˜¯ä»–æœ¬èº«ï¼Œã€‚è®©ä»¥è¿™ä¸ªç»“ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„ $DFS$ å…¨éå†å®Œä»¥åï¼Œå†å°†è¿™ä¸ªç»“ç‚¹çš„æ ¹èŠ‚ç‚¹è®¾ç½®ä¸ºè¿™ä¸ªç»“ç‚¹çš„çˆ¶ä¸€çº§ç»“ç‚¹ å›æº¯çš„æ—¶å€™ï¼Œå¦‚æœä»¥è¯¥èŠ‚ç‚¹ä¸ºèµ·ç‚¹ï¼Œ$queryedge$ æŸ¥è¯¢è¾¹çš„å¦ä¸€ä¸ªç»“ç‚¹ä¹Ÿæ°å¥½è®¿é—®è¿‡äº†ï¼Œç›´æ¥æ›´æ–°æŸ¥è¯¢è¾¹çš„ $LCA$ ç»“æœ è¾“å‡ºç»“æœ Tarjan ç®—æ³•éœ€è¦åˆå§‹åŒ–å¹¶æŸ¥é›†ï¼Œæ‰€ä»¥é¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚\næœ´ç´ çš„ Tarjan ç®—æ³•å¤„ç†æ‰€æœ‰ $m$ æ¬¡è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(m \\alpha(m+n, n) + n)$\næ¨¡æ¿ #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Edge { public: int toVertex, fromVertex; int next; int LCA; Edge() : toVertex(-1), fromVertex(-1), next(-1), LCA(-1) {}; Edge(int u, int v, int n) : fromVertex(u), toVertex(v), next(n), LCA(-1) {}; }; const int MAX = 100; int head[MAX], queryHead[MAX]; Edge edge[MAX], queryEdge[MAX]; int parent[MAX], visited[MAX]; int vertexCount, queryCount; int find(int x) { if (parent[x] == x) { return x; } else { return parent[x] = find(parent[x]); } } void tarjan(int u) { parent[u] = u; visited[u] = 1; for (int i = head[u]; i != -1; i = edge[i].next) { Edge\u0026amp; e = edge[i]; if (!visited[e.toVertex]) { tarjan(e.toVertex); parent[e.toVertex] = u; } } for (int i = queryHead[u]; i != -1; i = queryEdge[i].next) { Edge\u0026amp; e = queryEdge[i]; if (visited[e.toVertex]) { queryEdge[i ^ 1].LCA = e.LCA = find(e.toVertex); } } } int main() { memset(head, 0xff, sizeof(head)); memset(queryHead, 0xff, sizeof(queryHead)); cin \u0026gt;\u0026gt; vertexCount \u0026gt;\u0026gt; queryCount; int count = 0; for (int i = 0; i \u0026lt; vertexCount - 1; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; edge[count] = Edge(start, end, head[start]); head[start] = count; count++; edge[count] = Edge(end, start, head[end]); head[end] = count; count++; } count = 0; for (int i = 0; i \u0026lt; queryCount; i++) { int start = 0, end = 0; cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; queryEdge[count] = Edge(start, end, queryHead[start]); queryHead[start] = count; count++; queryEdge[count] = Edge(end, start, queryHead[end]); queryHead[end] = count; count++; } tarjan(1); for (int i = 0; i \u0026lt; queryCount; i++) { Edge\u0026amp; e = queryEdge[i * 2]; cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; e.fromVertex \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; e.toVertex \u0026lt;\u0026lt; \u0026#34;) \u0026#34; \u0026lt;\u0026lt; e.LCA \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"http://localhost:1313/posts/study/lca/","summary":"LCA å­¦ä¹ è®°å½•","title":"LCA"},{"content":"çº¿æ®µæ ‘å­¦ä¹  ç®€ä»‹ å¸¸ç”¨çš„ç”¨æ¥ç»´æŠ¤ åŒºé—´ä¿¡æ¯ çš„æ•°æ®ç»“æ„ã€‚\nçº¿æ®µæ ‘å¯ä»¥åœ¨ $O(\\log N)$ çš„æ—¶é—´å¤æ‚åº¦å†…å®ç°å•ç‚¹ä¿®æ”¹ã€åŒºé—´ä¿®æ”¹ã€åŒºé—´æŸ¥è¯¢ï¼ˆåŒºé—´æ±‚å’Œï¼Œæ±‚åŒºé—´æœ€å¤§å€¼ï¼Œæ±‚åŒºé—´æœ€å°å€¼ï¼‰ç­‰æ“ä½œã€‚\nå®ç°è¿‡ç¨‹å³ä¸ºå°†æ¯ä¸ªé•¿åº¦ä¸ä¸º $1$ çš„ç‰‡æ®µåˆ†æˆå·¦å³ä¸¤ä¸ªç‰‡æ®µï¼Œä¸æ–­é€’å½’ä¸‹å»ï¼ŒæŠŠåŒºé—´åˆ†ä¸ºæ ‘å½¢ç»“æ„ï¼Œé€šè¿‡åˆå¹¶ä¸¤ç«¯æ¥æ±‚å€¼\næ¨¡æ¿ å•ç‚¹ä¿®æ”¹ æ“ä½œ $1$ å•ç‚¹ä¿®æ”¹\næ“ä½œ $2$ æŸ¥è¯¢åŒºé—´æœ€å°å€¼\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv; }tr[N\u0026lt;\u0026lt;2]; void update(int now){ tr[now].minv=min(tr[ls].minv,tr[rs].minv); } void build(int now,int l,int r){ if(l==r){ tr[now].minv=a[l]; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now].minv=val; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } int query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now].minv; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return min(query(ls,l,r,s,mid),query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n)\u0026lt;\u0026lt;endl; } return 0; } åŒºé—´åˆå¹¶ ä¸å…‰è®°å½•æœ€å°å€¼ï¼ŒåŒæ—¶è®°å½•æœ€å°å€¼å‡ºç°æ¬¡æ•°\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int minv,cnt; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.minv=min(l.minv,r.minv); if(l.minv==r.minv)a.cnt=l.cnt+r.cnt; else if(l.minv\u0026lt;r.minv)a.cnt=l.cnt; else a.cnt=r.cnt; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],1}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,1};; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).minv\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;query(1,x,y,1,n).cnt\u0026lt;\u0026lt;endl; } return 0; } æœ€å¤§å­æ®µå’Œ æ•°ç»„ç‰‡æ®µä¸­æœ‰æ­£æœ‰è´Ÿï¼Œéœ€è¦ç»Ÿè®¡çš„æ•°æ®å˜å¤šï¼Œåˆå¹¶æ—¶å¯èƒ½æ¶‰åŠåˆ°å·¦å³ç‰‡æ®µç›¸æ¥éƒ¨åˆ†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n,m; int a[N]; struct Node{ int mss,mpre,msuf,s; }tr[N\u0026lt;\u0026lt;2]; Node operator + (const Node \u0026amp;l,const Node \u0026amp;r){ Node a; a.mss=max({l.mss,r.mss,l.msuf+r.mpre}); a.mpre=max(l.mpre,l.s+r.mpre); a.msuf=max(r.msuf,r.s+l.msuf); a.s=l.s+r.s; return a; } void update(int now){ tr[now]=tr[ls]+tr[rs]; } void build(int now,int l,int r){ if(l==r){ tr[now]={a[l],a[l],a[l],a[l]}; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(ls,l,mid); build(rs,mid+1,r); update(now); } void change(int now,int s,int t,int pos,int val){ if(s==t){ tr[now]={val,val,val,val}; return; } int mid=(s+t)\u0026gt;\u0026gt;1; if(pos\u0026lt;=mid) change(ls,s,mid,pos,val); else change(rs,mid+1,t,pos,val); update(now); } Node query(int now,int l,int r,int s,int t){ if(l\u0026lt;=s\u0026amp;\u0026amp;r\u0026gt;=t)return tr[now]; int mid=(s+t)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid) return query(ls,l,r,s,mid); else if(l\u0026gt;mid) return query(rs,l,r,mid+1,t); else return (query(ls,l,r,s,mid)+query(rs,l,r,mid+1,t)); } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; build(1,1,n); while(m--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(op==1){ change(1,1,n,x,y); } else cout\u0026lt;\u0026lt;query(1,x,y,1,n).mss\u0026lt;\u0026lt;endl; } return 0; } æ‡’æƒ°æ ‡è®° å¯¹ç‰‡æ®µä¿®æ”¹ï¼Œç”¨æ‡’æƒ°æ ‡è®°æ ‡è®°å½“å‰æ®µï¼Œä¹‹åå†å–åˆ°æ—¶ï¼Œå°†æ ‡è®°ä¼ åˆ°å­æ®µ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls (now \u0026lt;\u0026lt; 1) #define rs (now \u0026lt;\u0026lt; 1 | 1) int n, m; int a[N]; struct Node { int len, sum, tag; } tr[N \u0026lt;\u0026lt; 2]; Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = l.sum + r.sum; a.tag = 0; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, int k) { tr[now].tag += k; tr[now].sum += tr[now].len * k; } void pushdown(int now) { if (tr[now].tag) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = 0; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], 0}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, int val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans += query(ls, l, r, s, mid); if (r \u0026gt; mid) ans += query(rs, l, r, mid + 1, t); return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, z; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { cin \u0026gt;\u0026gt; z; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } æ‡’æƒ°æ ‡è®° 2 ä¸å…‰æœ‰åŒºé—´åŠ ï¼Œè¿˜æœ‰åŒºé—´ä¹˜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; #define ls now\u0026lt;\u0026lt;1 #define rs now\u0026lt;\u0026lt;1|1 int n, mod, q; int a[N]; struct Tag { int mul, add; }; struct Node { int len, sum; Tag tag; } tr[N\u0026lt;\u0026lt;2]; Tag operator + (const Tag \u0026amp;a, const Tag \u0026amp;b) { return {a.mul * b.mul % mod, (a.add * b.mul + b.add) % mod}; } Node operator + (const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.sum = (l.sum + r.sum) % mod; a.tag = {1, 0}; a.len = l.len + r.len; return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void settag(int now, Tag t) { tr[now].tag = tr[now].tag + t; tr[now].sum = (tr[now].sum * t.mul + tr[now].len * t.add) % mod; } void pushdown(int now) { if (tr[now].tag.mul != 1 || tr[now].tag.add) { settag(ls, tr[now].tag); settag(rs, tr[now].tag); tr[now].tag = {1, 0}; } } void build(int now, int l, int r) { if (l == r) { tr[now] = {1, a[l], {1, 0}}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void modify(int now, int l, int r, int s, int t, Tag val) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) { settag(now, val); return; } pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) modify(ls, l, r, s, mid, val); if (r \u0026gt; mid) modify(rs, l, r, mid + 1, t, val); update(now); } int query(int now, int l, int r, int s, int t) { if (l \u0026lt;= s \u0026amp;\u0026amp; r \u0026gt;= t) return tr[now].sum; pushdown(now); int mid = (s + t) \u0026gt;\u0026gt; 1; int ans = 0; if (l \u0026lt;= mid) ans = (ans + query(ls, l, r, s, mid)) % mod; if (r \u0026gt; mid) ans = (ans + query(rs, l, r, mid + 1, t)) % mod; return ans; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q \u0026gt;\u0026gt; mod; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (q--) { int op, x, y; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; Tag z = {1, 0}; if (op == 1) { cin \u0026gt;\u0026gt; z.mul; modify(1, x, y, 1, n, z); } else if (op == 2) { cin \u0026gt;\u0026gt; z.add; modify(1, x, y, 1, n, z); } else { cout \u0026lt;\u0026lt; query(1, x, y, 1, n) \u0026lt;\u0026lt; endl; } } return 0; } çº¿æ®µæ ‘ä¸ŠäºŒåˆ† é‡ç‚¹æ”¹çš„æ˜¯æŸ¥è¯¢éƒ¨åˆ†\næ‰¾åˆ°åŒºé—´ä¸­ç¬¬ä¸€ä¸ªå¤§äºç­‰äº $d$ çš„ä½ç½®\nä½†æ˜¯ $l == s$, $r == t$ æ—¶ä¸è¿”å›ï¼Œç»§ç»­é€’å½’\næ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯ $O(\\log n)$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5 + 7; #define ls now \u0026lt;\u0026lt; 1 #define rs now \u0026lt;\u0026lt; 1 | 1 int n, m; int a[N]; struct Node { int mx; } tr[N \u0026lt;\u0026lt; 2]; Node operator+(const Node \u0026amp;l, const Node \u0026amp;r) { Node a; a.mx = max(l.mx, r.mx); return a; } void update(int now) { tr[now] = tr[ls] + tr[rs]; } void build(int now, int l, int r) { if (l == r) { tr[now] = {a[l]}; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(ls, l, mid); build(rs, mid + 1, r); update(now); } void change(int now, int s, int t, int pos, int val) { if (s == t) { tr[now] = {val}; return; } int mid = (s + t) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) change(ls, s, mid, pos, val); if (pos \u0026gt; mid) change(rs, mid + 1, t, pos, val); update(now); } int search(int now, int l, int r, int s, int t, int d) { if (l == s \u0026amp;\u0026amp; r == t) { if (tr[now].mx \u0026lt; d) return -1; if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; if (tr[ls].mx \u0026gt;= d) return search(ls, l, mid, s, mid, d); return search(rs, mid + 1, r, mid + 1, t, d); } int mid = (s + t) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) return search(ls, l, r, s, mid, d); if (r \u0026gt; mid) return search(rs, l, r, mid + 1, t, d); int pos = search(ls, l, mid, s, mid, d); if (pos != -1) return pos; return search(rs, mid + 1, r, mid + 1, t, d); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; build(1, 1, n); while (m--) { int op, x, y, d; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if (op == 1) { change(1, 1, n, x, y); } else { cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; search(1, x, y, 1, n, d) \u0026lt;\u0026lt; endl; } } return 0; } ","permalink":"http://localhost:1313/posts/study/%E7%BA%BF%E6%AE%B5%E6%A0%91/","summary":"å˜´çˆ±çš„çº¿æ®µæ ‘","title":"çº¿æ®µæ ‘"},{"content":"2024 æ²³å—èŒæ–°è”èµ› 3 B æ­£åˆ™è¡¨è¾¾å¼ ç­¾åˆ°ï¼Œå››ä¸ªæ•°å­—éƒ½åœ¨ $[1,255]$ ä¹‹é—´å³ä¸ºåˆæ³•\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool check(string s) { int n = s.size(); int num = 0, dots = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;.\u0026#39;) { if (num \u0026lt; 0 || num \u0026gt; 255) return false; num = 0; } else if (isdigit(s[i])) { num = num * 10 + (s[i] - \u0026#39;0\u0026#39;); if (num \u0026gt; 255) return false; } else { return false; } } if (num \u0026lt; 0 || num \u0026gt; 255) return false; return true; } int main() { int n; cin \u0026gt;\u0026gt; n; int cnt = 0; for(int i=1;i\u0026lt;=n;i++) { string s; cin \u0026gt;\u0026gt; s; if (check(s)) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C Circle æ‰¾è§„å¾‹ï¼Œæ‰‹æ¨¡ä¸¤éå‘ç° $n = 1$ï¼Œæ—¶ä¸º $2$ï¼Œå…¶ä»–æƒ…å†µéƒ½æ˜¯æ¯æ¬¡å¢åŠ  $(2 \\cdot (n - 1))$ ä¸ªåœ†ï¼ŒåŒ–ç®€å…³ç³»å¼å¾— $S(n) = n^2 - n + 2$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n==0) cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;; else cout\u0026lt;\u0026lt;1LL*n*n-n+2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } J keillempkillå­¦å§ã®å·ç§¯ æŒ‰é¢˜æ„æ¨¡æ‹Ÿå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; #define int long long int n,m; int a[25][25],b[25][25],c[25][25]; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;n;j++)cin\u0026gt;\u0026gt;a[i][j]; } for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;m;j++)cin\u0026gt;\u0026gt;b[i][j]; } for(int i=0;i\u0026lt;m-n+1;i++){ for(int j=0;j\u0026lt;m-n+1;j++){ int now=0; for(int x=i;x\u0026lt;n+i;x++){ for(int y=j;y\u0026lt;n+j;y++) now+=(a[x-i][y-j]*b[x][y]); } cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } L SSH å¤§ STL\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int q, n, m; unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; ips, keys; unordered_map\u0026lt;string, string\u0026gt; p2p; int main() { cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= m; i++) { string pub, pri; cin \u0026gt;\u0026gt; pub \u0026gt;\u0026gt; pri; p2p[pri] = pub; } for (int i = 1; i \u0026lt;= n; i++) { string ip; int k; cin \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; k; for (int j = 1; j \u0026lt;= k; j++) { string user, pub; int t; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; t; ips[ip].push_back(user); for (int l = 1; l \u0026lt;= t; l++) { cin \u0026gt;\u0026gt; pub; keys[user].push_back(pub); } } } while (q--) { string user, ip, pri; cin \u0026gt;\u0026gt; user \u0026gt;\u0026gt; ip \u0026gt;\u0026gt; pri; if (find(ips[ip].begin(), ips[ip].end(), user) != ips[ip].end() \u0026amp;\u0026amp; find(keys[user].begin(), keys[user].end(), p2p[pri]) != keys[user].end()) { cout \u0026lt;\u0026lt; \u0026#34;Yes\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;No\\n\u0026#34;; } } } F ç´¯åŠ å™¨ æ­£è§£æ˜¯æš´åŠ›è·‘ä¸€éï¼Œè®°å½•ä» $1$ åˆ° $i$ çš„æ”¹å˜æ¬¡æ•°ï¼Œè¯¢é—®æ—¶ç”¨ $pre[r] - pre[l]$ å³å¯\nèµ›æ—¶ eng åœ¨æ‰¾è§„å¾‹äº†ï¼Œå¯ä»¥å‘ç°ä»ç¬¬ $0$ ä½å¼€å§‹ï¼Œæ¯æ¬¡æ”¹å˜æ¬¡æ•°éƒ½ $/2$ï¼Œå¦‚æœé‡åˆ°å‰ä¸€ä½åŸæ¥ä¸º $1$ ç°åœ¨ä¸º $0$ çš„ï¼Œå°±å°†ç°åœ¨è®°å½•çš„ $now + 1$ï¼Œæœ€åä¹Ÿå¯å¾—å‡ºç­”æ¡ˆ\nèµ›æ—¶ä»£ç \n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int x,y,xx[32],yy[32]; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int t=x+y; for(int i=31;i\u0026gt;=0;i--){ if((x\u0026gt;\u0026gt;i)\u0026amp;1)xx[i]=1; else xx[i]=0; if((t\u0026gt;\u0026gt;i)\u0026amp;1)yy[i]=1; else yy[i]=0; } int now=y,ans=y; for(int i=1;i\u0026lt;32;i++){ if(xx[i-1]==1\u0026amp;\u0026amp;yy[i-1]==0)now++; ans+=(now/2); // cout\u0026lt;\u0026lt;now\u0026lt;\u0026lt;\u0026#34; \u0026#34;; now/=2; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } I æ¸¸æˆ ä¸¤æ¬¡æœ€çŸ­è·¯ï¼Œä¸€æ¬¡åªå¯ä»¥èµ°é€šè·¯çš„ï¼Œå¦ä¸€æ¬¡å…ˆæ‹¿é’¥åŒ™ï¼Œå†èµ°åˆ°ç»ˆç‚¹ï¼Œæ¯”è¾ƒä¸¤æ¬¡å“ªä¸ªçŸ­å“ªä¸ªæ˜¯ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; #define int long long struct Node { int y, w; }; vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; edge(N), edges(N); int n, m, k, dist[N]; int a, b, c, d; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int dijkstra(int s, int t, vector\u0026lt;vector\u0026lt;Node\u0026gt;\u0026gt; \u0026amp;edge) { q.clear(); fill(dist, dist + N, LLONG_MAX); dist[s] = 0; q.insert({dist[s], s}); while (!q.empty()) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t) break; for (auto \u0026amp;i : edge[x]) { if (dist[x] + i.w \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.w; q.insert({dist[i.y], i.y}); } } } return dist[t]; } signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; if (d == 1) { edge[a].push_back({b, c}); edge[b].push_back({a, c}); } edges[a].push_back({b, c}); edges[b].push_back({a, c}); } int ans = LLONG_MAX, fk = -1; fk = dijkstra(1, k, edge); if (fk != LLONG_MAX) { ans = min(dijkstra(1, n, edge), dijkstra(k, n, edges) + fk); } else { ans = dijkstra(1, n, edge); } if (ans == LLONG_MAX) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } K æš´é£Ÿä¹‹å²è±å§† å¯¹äºä¸€ä¸ªå²è±å§†ï¼Œä»–åœ¨å·¦ä¾§èƒ½åƒæ‰çš„æ•°é‡ï¼Œå³ä¸ºå·¦ä¾§ç¬¬ä¸€ä¸ªæ¯”ä»–å°çš„å²è±å§†èƒ½åƒçš„æ•°é‡ï¼Œå³ä¾§åŒç†ã€‚æ‰€ä»¥ä»–èƒ½åƒçš„æ•°é‡å³ä¸ºå·¦ä¾§èƒ½åƒçš„æ•°é‡åŠ ä¸Šå³ä¾§èƒ½åƒçš„æ•°é‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+7; int n,a[N],f[N]; deque\u0026lt;int\u0026gt;q; void solve(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=n;i++){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i]) q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } q.clear(); for(int i=n;i\u0026gt;0;i--){ while(!q.empty()\u0026amp;\u0026amp;q.back()\u0026gt;a[i])q.pop_back(); f[i]+=q.size(); q.push_back(a[i]); } for(int i=1;i\u0026lt;=n;i++)cout\u0026lt;\u0026lt;f[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E åŒºé—´ çº¿æ®µæ ‘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e5+10; int a[N]; struct Node{ int l,r,mx,len; }tr[N\u0026lt;\u0026lt;2]; void build(int now,int l,int r){ tr[now]=Node{r-l+1,r-l+1,r-l+1,r-l+1}; if(l==r)return; int mid=(l+r)\u0026gt;\u0026gt;1; build((now\u0026lt;\u0026lt;1),l,mid); build(((now\u0026lt;\u0026lt;1)|1),mid+1,r); } Node update(Node x,Node y){ if(x.len==0)return y; if(y.len==0)return x; Node ans; ans.len=x.len+y.len; int tmp=max(x.mx,y.mx); ans.mx=max(x.r+y.l,tmp); ans.l=x.l; ans.r=y.r; if(x.l==x.len)ans.l+=y.l; if(y.r==y.len)ans.r+=x.r; return ans; } void change(int now,int l,int r,int x){ if(l==r){ a[l]^=1; tr[now].l=tr[now].r=tr[now].mx=a[l]^1; return; } int mid=(l+r)\u0026gt;\u0026gt;1; if(x\u0026lt;=mid)change((now\u0026lt;\u0026lt;1),l,mid,x); else change(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x); tr[now]=update(tr[(now\u0026lt;\u0026lt;1)],tr[((now\u0026lt;\u0026lt;1)|1)]); } Node query(int now,int l,int r,int x,int y){ if(l\u0026gt;=x\u0026amp;\u0026amp;r\u0026lt;=y)return tr[now]; int mid=(l+r)\u0026gt;\u0026gt;1; Node ans={0,0,0,0}; if(x\u0026lt;=mid)ans=query((now\u0026lt;\u0026lt;1),l,mid,x,y); if(y\u0026gt;mid)ans=update(ans,query(((now\u0026lt;\u0026lt;1)|1),mid+1,r,x,y)); return ans; } int main(){ int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; build(1,1,n); while(q--){ int op,x,y; cin\u0026gt;\u0026gt;op\u0026gt;\u0026gt;x; if(op==1)change(1,1,n,x); else { cin\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;query(1,1,n,x,y).mx\u0026lt;\u0026lt;endl; } } } H é­”æ³• ç”¨ $dp[x][y][k]$, è®°å½•åœ¨ $(x, y)$ å¤„ä½¿ç”¨ $k$ æ¬¡é­”æ³•ï¼Œæœ€å°çš„æƒå€¼ä¹‹å’Œ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int n,m,h; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;h; vector a(n + 1, vector(m + 1, 0)); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++)cin\u0026gt;\u0026gt;a[i][j]; vector dp(n + 1, vector(m + 1, vector(n + m, 1e16))); dp[1][1][0]=a[1][1],dp[1][1][1]=0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (i == 1 \u0026amp;\u0026amp; j == 1) continue; for (int k = 0; k \u0026lt; n + m; k++) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + a[i][j]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k] + a[i][j]); if (k) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1]); dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1]); } } } } for(int i=0;i\u0026lt;n+m;i++){ if(dp[n][m][i]\u0026lt;h){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return; } } } signed main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); } G æ±‚å€¼ æ˜“æƒ³åˆ°å°† $w$ å’Œå‰é¢çš„å…³ç³»å¼åˆ†å¼€çœ‹ï¼Œç­”æ¡ˆå³ä¸ºå…³ç³»å¼å’Œ $w$ æœ€æ¥è¿‘æ—¶çš„ç­”æ¡ˆï¼Œå¯ä»¥æƒ³åˆ° $A$ $B$ $C$ ä¸‰è€…çš„é¡ºåºå…¶å®æ— æ‰€è°“ï¼Œåªå’Œä»–ä»¬çš„å¤§å°æœ‰å…³ç³»ï¼Œå‡è®¾å…³ç³»å¼ç»“æœä¸º $S$ï¼Œ$A \u0026lt; B \u0026lt; C$, é‚£ä¹ˆ $S$ æœ€å°å°±æ˜¯ $A \\cdot n$ï¼Œæœ€å¤§å°±æ˜¯ $C \\cdot n$ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆå›ºå®šä»é€‰ $n$ ä¸ª $A$ å¼€å§‹ï¼Œæ¯æ¬¡å¾ªç¯ä¸­å¢åŠ  $1$ ä¸ª $B - A$ çš„å€¼ï¼Œè¿™æ ·å°±åœ¨ $O(n)$ çš„æ—¶é—´ä¸­è§£å†³äº† $A$ $B$ çš„æ•°é‡ï¼Œå†åœ¨æ¯æ¬¡å¾ªç¯ä¸­é’ˆå¯¹ $C$ è¿›è¡Œé€‰å–ï¼Œå¦‚æœå½“å‰ $(W - S) / (C - B)$ çš„å€¼å¤§äº $i$ é‚£ä¹ˆæˆ‘ä»¬å°±é€‰ $i$ ä¸ª $C$ï¼Œå¦åˆ™å°±é€‰ $(W - S) / (C - B - A)$ ä¸ª $C$ å’Œ $(W - S) / (C - B) + 1$ çš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œé€‰æœ€ä¼˜çš„\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long void solve(){ int aa[3],a,b,c,n,w; cin\u0026gt;\u0026gt;aa[0]\u0026gt;\u0026gt;aa[1]\u0026gt;\u0026gt;aa[2]\u0026gt;\u0026gt;n\u0026gt;\u0026gt;w; sort(aa,aa+3); a=aa[0],b=aa[1]-aa[0],c=aa[2]-aa[1]; int ans,res=w-a*n; ans=res; if(ans\u0026lt;=0){ cout\u0026lt;\u0026lt;-ans\u0026lt;\u0026lt;endl; return; } for(int i=1;i\u0026lt;=n;i++){ res-=b; ans=min(ans,abs(res)); if(res\u0026lt;=0)break; if(c==0)continue; int t=res/c; if(t\u0026gt;i)ans=min(ans,res-c*i); else ans=min(ans,res-c*t); if(i\u0026gt;t)ans=min(ans,abs(res-c*(t+1))); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } signed main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); } G å¼€å¿ƒæ¶ˆæ¶ˆä¹ ä¸€ä¸ªæ•°å¼‚æˆ–ä»–æœ¬èº«ä¸º $0$ï¼Œå¦‚æœç›¸é‚»çš„æ•°ç›¸åŒï¼Œä»–ä»¬åªéœ€è¦æ¶ˆè€—ä¸€æ¬¡ï¼Œä¸åŒçš„å°±å¢åŠ æ¶ˆè€—ï¼Œç‰¹ä¾‹æ˜¯ä¸º $0$ï¼Œçš„ä¸éœ€è¦æ¶ˆè€—\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,last=-1,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; if(x!=last){ last=x; if(x!=0) ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } ","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B3/","summary":"æ¯”èµ›çˆ½çˆ½çˆ½","title":"2024èŒæ–°è”èµ›3"},{"content":"æœ€å°ç”Ÿæˆæ ‘åŸºç¡€ç®—æ³•å­¦ä¹  å®šä¹‰ æˆ‘ä»¬å®šä¹‰æ— å‘è¿é€šå›¾çš„ æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼ŒMSTï¼‰ä¸ºè¾¹æƒå’Œæœ€å°çš„ç”Ÿæˆæ ‘ã€‚\næ³¨æ„ï¼šåªæœ‰è¿é€šå›¾æ‰æœ‰ç”Ÿæˆæ ‘ï¼Œè€Œå¯¹äºéè¿é€šå›¾ï¼Œåªå­˜åœ¨ç”Ÿæˆæ£®æ—ã€‚\nKruskal ç®—æ³• ç®€ä»‹ åŸºæœ¬æ€æƒ³æ˜¯ä»å°åˆ°å¤§åŠ å…¥è¾¹ï¼Œæ˜¯ä¸ªè´ªå¿ƒç®—æ³•ã€‚\nå°†æ‰€æœ‰è¾¹çš„è¾¹æƒæ’åºï¼Œä»å°åˆ°å¤§åŠ å…¥ç”Ÿæˆæ ‘ä¸­ï¼Œå¦‚æœæŸæ¬¡åŠ å…¥ä¼šç”Ÿæˆç¯å°±èˆå¼ƒæ­¤è¾¹ï¼Œç›´åˆ°åŠ å…¥äº† $n - 1$ æ¡è¾¹ï¼Œå½¢æˆæ ‘ã€‚æ—¶é—´å¤æ‚åº¦ä¸º $O(m \\log m)$\nå®ç° struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int find(int i){ if(fa[i]==i)return i; return fa[i]=find(fa[i]); } int Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=find(a[i].x),y=find(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } return cnt; } ä¾‹é¢˜ æ´›è°·P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int x,y,v; bool operator \u0026lt; (const Node \u0026amp;a){ return v\u0026lt;a.v; } }a[500001]; int n,m,fa[500001]; int findset(int i){ if(fa[i]==i)return i; return fa[i]=findset(fa[i]); } void Kruskal(){ for(int i=1;i\u0026lt;=n;i++)fa[i]=i; sort(a+1,a+1+m); int cnt=n,ans=0; for(int i=1;i\u0026lt;=m;i++){ int x=findset(a[i].x),y=findset(a[i].y); if(x!=y){ fa[x]=y; ans+=a[i].v; cnt--; } if(cnt==1)break; } if(cnt==1) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++)cin\u0026gt;\u0026gt;a[i].x\u0026gt;\u0026gt;a[i].y\u0026gt;\u0026gt;a[i].v; Kruskal(); return 0; } Prim ç®—æ³• ç®€ä»‹ åŸºæœ¬æ€æƒ³æ˜¯ä»ä¸€ä¸ªç‚¹å¼€å§‹ï¼Œä¸æ–­åŠ ç‚¹ï¼Œè€Œä¸æ˜¯ Kruskal çš„åŠ è¾¹\nå…·ä½“åšæ³•å°±æ˜¯åœ¨å½“å‰å›¾å¯è¿ç‚¹ä¸Šé€‰æ‹©è·ç¦»æœ€è¿‘çš„ä¸€ä¸ªç‚¹ï¼Œå°†è¿™ä¸ªç‚¹åŠ å…¥å›¾ï¼Œç»§ç»­æ‰¾æœ€è¿‘çš„ç‚¹ï¼Œç›´åˆ°æ‰€æœ‰çš„ç‚¹éƒ½æ‰¾åˆ°\næ—¶é—´å¤æ‚åº¦ä¸€èˆ¬ä¸º $O(n^2)$\nå®ç° struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;-1\\n\u0026#34;; } ä¾‹é¢˜ æ´›è°·P3366\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; vector\u0026lt;Node\u0026gt;edge[5001]; int n,m,dist[5001]; bool b[5001]; void Prim(){ memset(b,0,sizeof(b)); memset(dist,127,sizeof(dist)); dist[1]=0; int ans=0,tot=0; for(;;){ int x=-1; for(int j=1;j\u0026lt;=n;j++){ if(!b[j]\u0026amp;\u0026amp;dist[j]\u0026lt;1\u0026lt;\u0026lt;30) if(x==-1||dist[j]\u0026lt;dist[x])x=j; } if(x==-1)break; b[x]=1; ++tot; ans+=dist[x]; for(auto j:edge[x]){ dist[j.y]=min(dist[j.y],j.v); } } if(tot==n) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;orz\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; edge[x].push_back(Node(y,z)); edge[y].push_back(Node(x,z)); } Prim(); return 0; } ","permalink":"http://localhost:1313/posts/study/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","summary":"æœ€å°ç”Ÿæˆæ ‘å­¦ä¹ è®°å½•","title":"æœ€å°ç”Ÿæˆæ ‘"},{"content":"æœ€çŸ­è·¯åŸºç¡€ç®—æ³•å­¦ä¹  ç‰¹ç‚¹æ±‡æ€» æœ€çŸ­è·¯ç®—æ³• Floyd Bellmanâ€“Ford Dijkstra Johnson æœ€çŸ­è·¯ç±»å‹ æ¯å¯¹ç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ å•æºæœ€çŸ­è·¯ å•æºæœ€çŸ­è·¯ æ¯å¯¹ç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ ä½œç”¨äº ä»»æ„å›¾ ä»»æ„å›¾ éè´Ÿæƒå›¾ ä»»æ„å›¾ èƒ½å¦æ£€æµ‹è´Ÿç¯ï¼Ÿ èƒ½ èƒ½ ä¸èƒ½ èƒ½ æ—¶é—´å¤æ‚åº¦ $O(N^3)$ $O(NM)$ $O(M \\log M)$ $O(NM \\log M)$ Floyd ç®—æ³• ç®€ä»‹ ç”¨æ¥æ±‚ä»»æ„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯\nå¤æ‚åº¦è¾ƒé«˜ $O(n^3)$ å®¹æ˜“å®ç°\nä½¿ç”¨ä¸ä»»ä½•å›¾ï¼Œä¸ç®¡æœ‰å‘æ— å‘ï¼Œè¾¹æƒæ­£è´Ÿï¼Œä½†æ˜¯æœ€çŸ­è·¯å¿…é¡»å­˜åœ¨ï¼Œä¸èƒ½å­˜åœ¨è´Ÿç¯(å³è¾¹æƒä¹‹å’Œä¸ºè´Ÿæ•°çš„ç¯ï¼Œå¯ä»¥æ— é™æ¬¡é€šè¿‡å‡å°‘æ‰€æ±‚ç­”æ¡ˆ)\nå®ç° å®šä¹‰ä¸€ä¸ªæ•°ç»„ $f[k][x][y]$ï¼Œè¡¨ç¤ºåªå…è®¸ç»è¿‡ç‚¹ 1 åˆ° $k$ (åŒ…å«ç‚¹ 1 åˆ°ç‚¹ $k$ çš„å­å›¾ï¼Œ$x$ $y$ ä¸ä¸€å®šåœ¨å­å›¾ä¸­)ï¼Œç‚¹ $x$ åˆ°ç‚¹ $y$ çš„æœ€çŸ­è·¯é•¿åº¦\n$f[n][x][y]$ å³ä¸º $x$ åˆ° $y$ çš„æœ€çŸ­è·¯é•¿åº¦\n$f[0][x][y]$: $x$ å’Œ $y$ ä¹‹é—´æœ‰è”é€šè·¯æ—¶ä¸ºäºŒè€…çš„è¾¹æƒï¼Œè‹¥æ— åˆ™ä¸º $+\\infty $ å¦‚æœ $x == y$ åˆ™ä¸º 0\n$f[k][x][y] = \\min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])$ï¼ˆ$f[k-1][x][y]$ï¼Œä¸ºä¸ç»è¿‡ $k$ ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè€Œ $f[k-1][x][k]+f[k-1][k][y]$ï¼Œä¸ºç»è¿‡äº† $k$ ç‚¹çš„æœ€çŸ­è·¯ï¼‰ã€‚\nå¯ä»¥å‘ç°ç¬¬ä¸€ç»´æ˜¯æ— å½±å“çš„ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ° $O(n^2)$\nvoid floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } ä¾‹é¢˜ æ´›è°· B3647\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int f[110][110]; int inf = 1e9; void floyd(){ for(int k=1;k\u0026lt;=n;k++){ for(int x=1;x\u0026lt;=n;x++){ for(int y=1;y\u0026lt;=n;y++){ f[x][y]=min(f[x][y],f[x][k]+f[k][y]); } } } } int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int x,y,w; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; if(!f[x][y])f[x][y]=f[y][x]=w; else f[x][y]=f[y][x]=min(f[x][y],w); } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ if(f[i][j])continue; if(i==j)f[i][j]=0; else f[i][j]=inf; } } floyd(); for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++)cout\u0026lt;\u0026lt;f[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } Bellman-Ford ç®—æ³• ç®€ä»‹ åŸºäºæ¾é©°æ“ä½œçš„æœ€çŸ­è·¯ç®—æ³•ï¼Œå¯ä»¥æ±‚å‡ºæœ‰è´Ÿæƒçš„å›¾çš„æœ€çŸ­è·¯ï¼Œå¹¶å¯ä»¥å¯¹æœ€çŸ­è·¯ä¸å­˜åœ¨çš„æƒ…å†µè¿›è¡Œåˆ¤æ–­\nSPFA æ˜¯ Bellman-Ford çš„ä¸€ç§å®ç°\næ¾é©°æ“ä½œæŒ‡çš„æ˜¯ $dis[v] = \\min(dis[v], dis[u] + w[u][v])$\nBellman-Ford ç®—æ³•åšçš„å°±æ˜¯ä¸æ–­å°è¯•å¯¹å›¾ä¸Šæ¯ä¸€æ¡è¾¹è¿›è¡Œæ¾é©°ï¼Œæ¯ä¸€è½®å¾ªç¯éƒ½å°è¯•å¯¹å›¾ä¸Šæ‰€æœ‰çš„è¾¹è¿›è¡Œä¸€æ¬¡æ¾é©°æ“ä½œï¼Œå½“ä¸€æ¬¡å¾ªç¯ä¸­æ²¡æœ‰æˆåŠŸçš„æ¾é©°æ“ä½œæ—¶ï¼Œç®—æ³•åœæ­¢\næ•´ä¸ªç®—æ³•æœ€å¤šè¿›è¡Œ $n - 1$ è½®æ¾é©°æ“ä½œï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º $O(nm)$\nå¦‚æœä» $s$ ç‚¹å‡ºå‘ï¼ŒæŠµè¾¾ä¸€ä¸ªè´Ÿç¯ï¼Œæ¾é©°ä¼šæ— ä¼‘æ­¢çš„è¿›è¡Œä¸‹å»ï¼Œå¦‚æœ $n - 1$ è½®åè¿˜æœ‰èƒ½æ¾é©°çš„è¾¹ï¼Œè¯´æ˜ä» $s$ ç‚¹å‡ºå‘ï¼Œèƒ½å¤ŸæŠµè¾¾ä¸€ä¸ªè´Ÿç¯\nå¦‚æœä»¥ $s$ ç‚¹è·‘ï¼Œæ²¡æœ‰æ‰¾åˆ°è´Ÿç¯ï¼Œåªèƒ½è¯´æ˜ä» $s$ ç‚¹æ— æ³•åˆ°è¾¾è´Ÿç¯ï¼Œå¦‚æœè¦åˆ¤æ–­å›¾ä¸Šæ˜¯å¦æœ‰è´Ÿç¯ï¼Œéœ€è¦å»ºç«‹ä¸€ä¸ªè¶…çº§æºç‚¹ $o$ å¯¹å›¾ä¸Šæ¯ä¸ªç‚¹è¿ä¸€æ¡æƒå€¼ä¸º 0 çš„è¾¹ï¼Œå†ä»¥ $o$ ä¸ºèµ·ç‚¹è·‘ä¸€é Bellman-Ford\nå®ç° struct Node{ int u,v,w; }; vector\u0026lt;Node\u0026gt;edge; int dis[10100],u,v,w; int n,m; const int INF = 1e9; bool bellmanford(int n,int s){ memset(dis,INF,sizeof(dis)); dis[s]=0; bool flag=false; for(int i=1;i\u0026lt;=n;i++){ flag=false; for(int j=0;j\u0026lt;edge.size();j++){ u=edge[j].u,v=edge[j].v,w=edge[j].w; if(dis[u]==INF)continue; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; flag=true; } } if(!flag)break; } return flag; } é˜Ÿåˆ—ä¼˜åŒ– SPFA\nå¾ˆæ˜¾ç„¶ï¼Œåªæœ‰ä¸Šæ¬¡è¢«æ¾é©°çš„ç‚¹æ‰€è¿æ¥çš„è¾¹ï¼Œæ‰å¯èƒ½è¿›è¡Œä¸‹ä¸€æ¬¡çš„æ¾é©°æ“ä½œ\nå¯ä»¥ç”¨é˜Ÿåˆ—æ¥ç»´æŠ¤å¯èƒ½å¼•èµ·æ¾é©°æ“ä½œçš„ç‚¹\nSPFA ä¹Ÿå¯ä»¥ç”¨äºåˆ¤æ–­ $s$ æ˜¯å¦èƒ½æŠµè¾¾è´Ÿç¯ï¼Œåªéœ€è®°å½•æœ€çŸ­è·¯ç»è¿‡äº†å¤šå°‘æ¡è¾¹å³å¯ï¼Œè‹¥ç»è¿‡äº†è‡³å°‘ $n$ æ¡è¾¹ï¼Œè¯´æ˜ $s$ å¯ä»¥æŠµè¾¾ä¸€ä¸ªè´Ÿç¯\nstruct Node{ int v,w; }; vector\u0026lt;Node\u0026gt;edge[N]; int dis[N],cnt[N],vis[N]; queue\u0026lt;int\u0026gt;q; bool spfa(int n,int s){ memset(dis,63,sizeof(dis)); memset(cnt,0,sizeof(cnt)); memset(vis,0,sizeof(vis)); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front(); q.pop(); vis[u]=0; for(auto x:edge[u]){ int v=x.v,w=x.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n)return false; if(!vis[v])q.push(v),vis[v]=1; } } } return true; } ä¾‹é¢˜ æ´›è°· P3385\nBellman-Ford\nSPFA\nDijkstra ç®—æ³• ç®€ä»‹ æ±‚è§£ éè´Ÿæƒå›¾ ä¸Šå•æºæœ€çŸ­è·¯å¾„\nå°†ç‚¹åˆ†ä¸ºä¸¤ä¸ªé›†åˆï¼Œä¸€ä¸ªä¸ºå·²ç¡®å®šæœ€çŸ­è·¯å¾„çš„ç‚¹é›† $s$ï¼Œå¦ä¸€ä¸ªä¸ºæœªç¡®å®šæœ€çŸ­è·¯é•¿åº¦çš„ç‚¹é›† $t$ï¼Œåˆå§‹çŠ¶æ€æ‰€æœ‰ç‚¹éƒ½åœ¨ $t$ ä¸­\nåˆå§‹åŒ– $dis[s] = 0$, å…¶ä»–ç‚¹çš„ $dis$ å‡ä¸º $+\\infty $\nç„¶åé‡å¤ä¸‹åˆ—æ“ä½œï¼š\n(1) ä» $t$ ä¸­å–ä¸€ä¸ªæœ€çŸ­è·¯é•¿åº¦æœ€å°çš„ç‚¹ï¼Œç§»åˆ° $s$ ä¸­\n(2) å¯¹åˆšåŠ å…¥ $s$ ä¸­çš„ç‚¹è¿›è¡Œæ‰€æœ‰å‡ºè¾¹çš„æ¾é©°æ“ä½œ\nç›´åˆ° $t$ ä¸ºç©ºï¼Œç®—æ³•ç»“æŸ\næš´åŠ›å®ç° æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$\nå †ä¼˜åŒ– æ—¶é—´å¤æ‚åº¦ $O(m \\log n)$\nå®ç° æš´åŠ›\nstruct Node{ int y,v; Node(int _y,int _v){y=_y;v=_v;} }; //å¼€ä¸€ä¸ªç»“æ„ä½“ç”¨äºå‚¨å­˜è¾¹çš„ä¿¡æ¯ï¼Œy ä»£è¡¨è¿™æ¡è¾¹é€šå‘å“ªï¼Œv ä»£è¡¨è¿™æ¡è¾¹çš„è¾¹æƒ int n,m,u,v,w,s,t,dist[N]; bool vis[N]; vector\u0026lt;Node\u0026gt;edge[N];//edge æ•°ç»„çš„ä¸‹æ ‡å°±æ˜¯è¾¹çš„èµ·å§‹ç‚¹ï¼ŒNode ä¸­çš„ y ä»£è¡¨è¿™æ¡è¾¹é€šå‘å“ªä¸ªç‚¹ void dijkstra(int s,int t){//s æŒ‡ä»£èµ·ç‚¹ï¼Œt æŒ‡ä»£ç»ˆç‚¹ memset(vis,0,sizeof(vis)); memset(dist,127,sizeof(dist)); //åˆå§‹å°†æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯éƒ½è®¾ç½®ä¸ºæ— ç©·å¤§ dist[s]=0;//èµ·ç‚¹åˆ°è‡ªå·±çš„è·ç¦»ä¸º 0 for(;;){ int x=-1;//x æ˜¯è¿™ä¸€è½®å¾ªç¯ä¸­æ‰¾åˆ°çš„æœ€çŸ­è·¯å¾„ for(int i=1;i\u0026lt;=n;i++){ if(!vis[i]\u0026amp;\u0026amp;dist[i]\u0026lt;(1\u0026lt;\u0026lt;30))//å¦‚æœå½“å‰è¿™ä¸ªç‚¹æ²¡è¢«æ›´æ–°è¿‡ï¼Œå¹¶ä¸”åˆ°è¾¾å®ƒçš„æœ€çŸ­è·¯ä¸æ˜¯åˆå§‹åŒ–çš„æ— ç©·å¤§ï¼Œæˆ‘ä»¬å°±è€ƒè™‘ä»–æ˜¯ä¸æ˜¯å½“å‰çš„æœ€ä¼˜é€‰æ‹© if(x==-1||dist[i]\u0026lt;dist[x])x=i;//å¦‚æœ x è¿˜æœªè¢«æ›´æ–°ï¼Œæˆ–è€…åˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·¯æ¯”ä¹‹å‰é€‰çš„æ›´çŸ­ï¼Œæˆ‘ä»¬å°±æ›´æ–° x } if(x==t||x==-1)break;//å¦‚æœ x ä¸ºç»ˆç‚¹ï¼Œæˆ–éå†æ‰€æœ‰ç‚¹å x è¿˜æ²¡æ›´æ–°ï¼Œå°±ç»ˆæ­¢ç®—æ³• vis[x]=1;//æ ‡è®°å½“å‰è¿™ä¸ª x é¿å…ä¹‹åé‡å¤ä½¿ç”¨ for(auto i:edge[x]){//éå†ä»¥ x è¿™ä¸ªç‚¹ä¸ºèµ·ç‚¹çš„æ‰€æœ‰è¾¹ dist[i.y]=min(dist[i.y],dist[x]+i.v);//æ›´æ–°èƒ½åˆ°è¾¾çš„ç‚¹çš„æœ€çŸ­è·¯ } } } å †ä¼˜åŒ–\nstruct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } ä¾‹é¢˜ æ´›è°·P1339\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Node { int y, v; Node(int _y, int _v) { y = _y, v = _v; } }; int n, m, s, t, dist[100005]; vector\u0026lt;Node\u0026gt; edge[100005]; set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; void dijkstra(int s, int t) { q.clear(); memset(dist, 127, sizeof(dist)); dist[s] = 0; for (int i = 1; i \u0026lt;= n; i++) q.insert({dist[i], i}); for (; !q.empty();) { int x = q.begin()-\u0026gt;second; q.erase(q.begin()); if (x == t || dist[x] \u0026gt; 1 \u0026lt;\u0026lt; 30) break; for (auto i : edge[x]) { if (dist[x] + i.v \u0026lt; dist[i.y]) { q.erase({dist[i.y], i.y}); dist[i.y] = dist[x] + i.v; q.insert({dist[i.y], i.y}); } } } cout \u0026lt;\u0026lt; dist[t] \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for (int i = 1; i \u0026lt;= m; i++) { int u, v, c; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; c; edge[u].push_back(Node(v, c)); edge[v].push_back(Node(u, c)); } dijkstra(s, t); return 0; } Johnson å…¨æºæœ€çŸ­è·¯å¾„ç®—æ³• å®ç° ä¸ºäº†å®ç°æœ‰è´Ÿæƒå›¾ä¸Šçš„ Dijkstraï¼Œæˆ‘ä»¬å¯ä»¥æ–°å»ºä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ $o$ï¼Œä»è¿™ä¸ªç‚¹å‘å…¶ä»–æ‰€æœ‰ç‚¹è¿ä¸€æ¡è¾¹æƒä¸º 0 çš„è¾¹\næ¥ä¸‹æ¥ç”¨ Bellman-Ford æ±‚å‡ºèŠ‚ç‚¹ $o$ åˆ°å…¶ä»–æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ï¼Œè®°ä¸º $h[i]$\nå‡å¦‚å­˜åœ¨ä¸€æ¡ä» $u$ åˆ° $v$ï¼Œè¾¹æƒä¸º $w$ çš„è¾¹ï¼Œåˆ™å°†å…¶è¾¹æƒé‡è®¾ä¸º $w + h[u] - h[v]$\næ¥ä¸‹æ¥ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹ï¼Œè·‘ $n$ è½® Dijkstra å³å¯æ±‚å‡ºä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯äº†\nè¯¥ç®—æ³•æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nm \\log m)$\n","permalink":"http://localhost:1313/posts/study/%E6%9C%80%E7%9F%AD%E8%B7%AF/","summary":"æœ€çŸ­è·¯å­¦ä¹ è®°å½•","title":"æœ€çŸ­è·¯"},{"content":"2024 æ²³å—èŒæ–°è”èµ› 1 A é€ æ•° ç»™å®šæ•´æ•° $n$ï¼Œæ“ä½œ 1ï¼š$+1$ï¼Œæ“ä½œ 2ï¼š$+2$ï¼Œæ“ä½œ 3ï¼š$\\times 2$ï¼Œå¤šå°‘æ¬¡å°† $0$ è½¬åŒ–åˆ° $n$\né€†å‘æ€ç»´ï¼ŒæŠŠ $n$ åŒ–ä¸º $0$ å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H ä¸¤éš¾æŠ‰æ‹© é•¿åº¦ä¸º $n$ çš„æ•°ç»„ $a$ï¼Œä¸¤ç§æ“ä½œé€‰ä¸€ä¸ªè¿›è¡Œä¸€æ¬¡æˆ–ä¸æ“ä½œã€‚\næ˜¾ç„¶å°†æ•°ç»„æœ€å¤§å€¼ $\\times n$ åç­”æ¡ˆæœ€å¤§\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end()); int sum=0; for(int i=0;i\u0026lt;n;i++){ sum+=a[i]; } sum=max(sum+n,sum+(n-1)*a[n-1]); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } K å›¾ä¸Šè®¡æ•° æ„é€ çš„ä¸¤å—è”é€šå—å³ä¸ºæœ€æ¥è¿‘ $n/2$ çš„ä¸¤å—\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int n,m; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } if(n\u0026lt;=1){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return 0; } cout\u0026lt;\u0026lt;(long long)n/2*(n-n/2)\u0026lt;\u0026lt;endl; } I é™¤æ³•ç§»ä½ $a$ ä¸­æœ€å¤§å€¼ä½äºç¬¬ä¸€ä½æ—¶å³æ˜¯ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t; vector\u0026lt;int\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int mx=0,ans=0; for(int i=1;i\u0026lt;=min(t,n);i++){ if(a[n-i+1]\u0026gt;mx){ mx=a[n-i+1]; ans=i%n; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } F ä¸¤éš¾æŠ‰æ‹©æ–°ç¼– ä¸ H ç±»ä¼¼ï¼Œä½†æ˜¯æ“ä½œèŒƒå›´éš $i$ æ”¹å˜è€Œæ”¹å˜ $O(n^{3/2})$ æš´åŠ›è¿‡\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); int sum = 0, ans = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) sum ^= a[i]; ans = sum; for (int i = 1; i \u0026lt;= n; i++) { for (int x = 1; x \u0026lt;= n / i; x++) { int t1 = sum ^ a[i] ^ (a[i] + x); int t2 = sum ^ a[i] ^ (a[i] * x); ans = max(ans, max(t1, t2)); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } G æ—…é€”çš„ç»ˆç‚¹ åæ‚”è´ªå¿ƒï¼Œå‰ $k$ ä¸ªç›´æ¥å­˜å…¥ setï¼Œåç»­çš„å°äº set å†…ç¬¬ä¸€ä¸ªå…ƒç´ å°±æ›¿æ¢ï¼Œå¦åˆ™å°±æ­£å¸¸è¿›è¡Œ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll __int128 int main(){ long long n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;long long\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; multiset\u0026lt;ll\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ s.insert(a[i]); if(s.size()\u0026gt;k){ m-=*s.begin(); if(m\u0026lt;=0){ cout\u0026lt;\u0026lt;i-1\u0026lt;\u0026lt;endl; return 0; } s.erase(s.begin()); } } cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; return 0; } B çˆ±æ¢é™©çš„æœµæ‹‰ å›¾ä¸­å¯èƒ½æœ‰ç¯ï¼Œé‚£ä¹ˆå°±æ˜¯è¦æ‰¾åŒ…å«ç¯çš„æœ€é•¿é“¾ï¼Œæˆ–æ˜¯æ— ç¯çš„æœ€é•¿é“¾\nè®°å½•æ¯ä¸ªç‚¹çš„å…¥åº¦ï¼Œå¦‚æœæŸä¸ªç‚¹çš„å…¥åº¦ä¸º $0$ï¼Œä»–ä»¬ä¸ä¼šæ„æˆç¯ï¼Œå³å¯ä½œä¸ºé“¾èµ·ç‚¹ï¼Œå†ä¾æ¬¡å¯¹å…¥åº¦ä¸º $0$ çš„ç‚¹æ“ä½œï¼Œæ‰¾å‡ºä»–ä»¬èƒ½æ„æˆæœ€é•¿çš„é“¾æœ‰å¤šé•¿ã€‚\nä¹‹åå†ä»¥æ¯ä¸ªç‚¹ä¸ºèµ·ç‚¹æ‰¾ç­”æ¡ˆï¼Œå¦‚æœå‰é¢çš„è¿‡ç¨‹æ ‡è®°è¿‡åˆ™è·³è¿‡ï¼Œæ²¡æ ‡è®°è¿‡è¯´æ˜è¿™æ˜¯ç¯ä¸Šç‚¹ï¼Œç”¨ dfs æ‰¾è¿™ä¸ªç¯åŠ ä¸Šå‰é“¾æœ‰å¤šé•¿ï¼Œå¹¶æ›´æ–°ç­”æ¡ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+10; int a[N],dis[N],cnt[N]; bool vis[N]; deque\u0026lt;int\u0026gt;q; int dfs(int x){ int sum=0,mx=0; for(int i=x;;i=a[i]){ if(vis[i])break; vis[i]=1; ++sum; mx=max(mx,dis[i]); } return mx+sum; } int main(){ int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; cnt[a[i]]++; } for(int i=1;i\u0026lt;=n;i++) if(!cnt[i])q.push_back(i); while(!q.empty()){ int x=q.front(); q.pop_front(); vis[x]=1; dis[a[x]]=max(dis[a[x]],dis[x]+1); --cnt[a[x]]; if(!cnt[a[x]])q.push_back(a[x]); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; int tmp=dfs(i); ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } C æœ‰å¤§å®¶å–œæ¬¢çš„é›¶é£Ÿå— äºŒåˆ†å›¾åŒ¹é…æ¿å­ï¼Œä¹‹åå­¦äº†è¡¥\nD å°è“çš„äºŒè¿›åˆ¶è¯¢é—® æ˜¾ç„¶æ˜¯å‰ç¼€å’Œï¼Œé‚£ä¹ˆé‡ç‚¹å°±æ˜¯å¦‚ä½•è®¡ç®—å‰ $x$ ä¸ªæ•°çš„ $1$ çš„ä¸ªæ•°\nä»æœ€ä½ä½çœ‹èµ·ï¼Œåªæœ‰ $0$ï¼Œ$1$ï¼ŒäºŒè€…å¾ªç¯ï¼Œå†å¾€ä¸Š $1$ ä½ï¼Œä»ç„¶ä¸º $0$ï¼Œ$1$ å¾ªç¯ï¼Œæ˜¾ç„¶æ¯ä¸€ä½ä¸Šçš„å¾ªç¯éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬å¯¹æ¯ä¸€ä½èƒ½å‡ºç°çš„ $1$ è¿›è¡Œè®¡ç®—ï¼Œå½“å‰ä½æ•°ä¸º $k$ æ—¶ï¼Œè¿™ä¸€ä½ä¸Šå°±ä¼šæœ‰ $2^k$ ä¸ª $1$ å’Œ $2^k$ ä¸ª $0$ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 998244353; ll sum(ll x,int y){ if(x==0) return 0; ll s=1LL\u0026lt;\u0026lt;y; ll cnt=x/s; ll ans=cnt*s/2; ll d=cnt*s+(1LL\u0026lt;\u0026lt;(y-1)); ll dd=x-d+1; if(dd\u0026gt;0) ans+=dd; return ans; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ ll ans=0,l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; for(int i=61;i\u0026gt;0;i--){ ll p=(sum(r,i)%MOD-sum(l-1,i)%MOD+MOD)%MOD; ans=(ans+p)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } J æœ€å¤§çŸ©é˜µåŒ¹é… å°†çŸ©é˜µä¸Šä¸‹ç¿»è½¬åï¼Œå˜ä¸ºå›ºå®šå·¦ä¸Šä¸€ä¸ªç‚¹ï¼Œå‘å…¶ä»–ä¸‰ä¸ªæ–¹å‘æ‹“å±•çš„é—®é¢˜ï¼Œç”¨äºŒç»´å‰ç¼€å’Œè¾…åŠ©åˆ¤æ–­ä¸‰ä¸ªç‚¹æ˜¯å¦éƒ½ä¸º $1$ï¼Œæ¥å®ç° DP çŠ¶æ€è½¬ç§»\n","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B1/","summary":"æ¯”èµ›çˆ½","title":"2024èŒæ–°è”èµ›1"},{"content":"Codeforces Round 962 è¿˜å¾—ç»ƒ\nA Legs å…ˆé™¤ $4$ å†é™¤ $2$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale æŒ‰é¢˜æ„åˆç†é—´éš”è¾“å‡ºå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort å¯¹ $a$ åˆ° $z$ è¿™ $26$ ä¸ªå­—ç¬¦åˆ†åˆ«å¼€å‰ç¼€å’Œï¼Œç»Ÿè®¡ $l$ åˆ° $r$ ä¹‹é—´ä»–ä»¬ä¸åŒçš„æ•°é‡ï¼Œæ›´æ”¹å·®å¼‚æ•°é‡é™¤ $2$ (å‘ä¸Šå–æ•´)ï¼Œå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; int n, q; string a, b; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = \u0026#34; \u0026#34; + a; b = \u0026#34; \u0026#34; + b; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; va(26, vector\u0026lt;int\u0026gt;(n + 1, 0)), vb(26, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { va[x - \u0026#39;a\u0026#39;][i] = va[x - \u0026#39;a\u0026#39;][i - 1]; vb[x - \u0026#39;a\u0026#39;][i] = vb[x - \u0026#39;a\u0026#39;][i - 1]; } va[a[i] - \u0026#39;a\u0026#39;][i]++; vb[b[i] - \u0026#39;a\u0026#39;][i]++; } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; long long ans = 0; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { ans += abs((va[x - \u0026#39;a\u0026#39;][r] - va[x - \u0026#39;a\u0026#39;][l - 1]) - (vb[x - \u0026#39;a\u0026#39;][r] - vb[x - \u0026#39;a\u0026#39;][l - 1])); } if(ans\u0026amp;1)ans++; ans/=2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D Fun ç»™å®šä¸¤ä¸ªæ•´æ•° $n$ å’Œ $x$ ï¼Œæ±‚ $ab + ac + bc \\leq n$ å’Œ $a + b + c \\leq x$ çš„ä¸ªæ­£æ•´æ•°çš„ä¸‰å…ƒç»„ $(a, b, c)$ çš„ä¸ªæ•°ã€‚ æ³¨æ„é¡ºåºé—®é¢˜(ä¾‹å¦‚ $(1, 1, 2)$ å’Œ $(1, 2, 1)$ è¢«è§†ä¸ºä¸åŒ)ï¼Œ $a$ ï¼Œ $b$ ï¼Œ $c$ å¿…é¡»ä¸¥æ ¼å¤§äº $0$ ã€‚\nèµ›æ—¶åªé¡¾ç€ç ”ç©¶è¿™ä¸¤ä¸ªå¼å­èƒ½å¦èåˆåŒ–ç®€ä¸ºä¸€ä¸ªå¼å­ï¼Œè¿˜æ˜¯è§é¢˜å°‘äº†\nçœ‹ç¬¬ä¸€ä¸ªå¼å­å¯çŸ¥ï¼Œ$a * b \\leq n$, æ‰€ä»¥ $b$ æœ‰ $n\\log n$ ä¸ªé€‰æ‹©ï¼Œå¯ä»¥å¾ªç¯ $ab$ æ±‚è§£\nå†é€šè¿‡ä¸¤ä¸ªå¼å­æ¨å¾— $c \\leq \\frac{n - ab}{a + b}$ å’Œ $c \\leq x - a - b$ ,å°†èŒƒå›´å°çš„åŠ å…¥ç­”æ¡ˆå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ ll n,x,ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ ll mn=min((n-i*j)/(i+j),(x-i-j)); mn=max(mn,0); ans+=mn; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E Decode èµ›æ—¶é¢˜éƒ½æ²¡å¼„å¤ªæ˜ç™½ æ¯æ¬¡æ‰¾åˆ°ç¬¦åˆåŒºé—´ä¼šä½¿ç­”æ¡ˆåŠ  $l * (n - r + 1)$\nç”¨å‰ç¼€å’Œè®°å½•å½“å‰ä½ç½® $1$ $0$ å‡ºç°æ¬¡æ•°ï¼Œ$1$ æŒ‡ä»£æ­¤å¤„ä¸º $1$ï¼Œ$-1$ æŒ‡ä»£æ­¤å¤„ä¸º $0$ã€‚ç„¶åé€ä½è®°å½•å½“å‰å‰ç¼€å’Œçš„å¤§å°ï¼Œå¦‚æœä¹‹å‰å­˜è¿‡ï¼Œé‚£ä¹ˆå°±æ›´æ–°ç­”æ¡ˆã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 1e9 + 7; void solve(){ string s; cin\u0026gt;\u0026gt;s; int n=s.size(); s=\u0026#34; \u0026#34;+s; vector\u0026lt;ll\u0026gt;pre(n+1,0); for(int i=1;i\u0026lt;=n;i++){ pre[i]=(s[i]==\u0026#39;1\u0026#39;?1:-1)+pre[i-1]; } map\u0026lt;int,ll\u0026gt;cnt; cnt[0]=1; ll ans=0; for(int i=1;i\u0026lt;=n;i++){ ans=(ans+cnt[pre[i]]*(n-i+1)*1LL%MOD)%MOD; cnt[pre[i]]=(cnt[pre[i]]+i+1)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/cf962/","summary":"Codeforces Round 962 è¡¥é¢˜","title":"CF962"},{"content":"åšå¼ˆè®º ç®€ä»‹ ä¸¤äººåœ¨å…¬å¹³è§„åˆ™ä¸‹è¿›è¡Œæœ‰é™çš„å¯¹å†³ï¼Œèƒœè´Ÿæ˜ç¡®\nç±»ä¼¼æœ‰å‘æ— ç¯å›¾ï¼Œç”±ä¸€ä¸ªçŠ¶æ€è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€\nå¯¹å…ˆæ‰‹æ¥è¯´ï¼Œå­˜åœ¨ä¸¤ç§çŠ¶æ€ï¼Œå³å¿…èƒœæ€å’Œå¿…è´¥æ€\nå¿…èƒœæ€ å½“å‰çŠ¶æ€çš„åç»­ä¸ºå¿…è´¥æ€ï¼Œå½“å‰çŠ¶æ€å³ä¸ºå¿…èƒœæ€\nå¿…è´¥æ€ ä¸å­˜åœ¨åç»­ï¼Œæˆ–æ˜¯æ‰€æœ‰åç»­éƒ½å¿…èƒœ\nDP è§£å†³åšå¼ˆ åˆ©ç”¨çŠ¶æ€è½¬ç§»çš„å…³ç³»ï¼Œæ¥è§£å†³ç®€å•çš„åšå¼ˆé—®é¢˜\nç§»æ£‹å­é—®é¢˜ $n \\times m$ çš„æ£‹ç›˜ï¼Œ$(1,1)$ åœ¨å·¦ä¸Šè§’ï¼Œ$(n,m)$ åœ¨å³ä¸‹è§’ï¼Œæ¯æ ¼æ ‡æ˜é»‘ç™½ä¸¤è‰²\nä¸Šé¢æœ‰ä¸€ä¸ªæ£‹å­ï¼ŒAlice å’Œ Bob è½®æµç§»åŠ¨è¿™ä¸ªæ£‹å­ï¼ŒAlice å…ˆæ‰‹ç§»åŠ¨ï¼Œæ¯æ¬¡å¯ä»¥å‘ä¸Šæˆ–å‘å·¦ç§»åŠ¨ä¸€æ ¼ï¼Œä¸€æ—¦ç§»åŠ¨åˆ°ç¬¬ä¸€è¡Œæˆ–ç¬¬ä¸€åˆ—æ¸¸æˆç»“æŸï¼Œæ‰§è¡Œæœ€åä¸€æ­¥ç§»åŠ¨çš„äººï¼Œå¦‚æœå°†æ£‹å­ç§»åŠ¨åˆ°é»‘æ ¼ï¼Œå°±è·èƒœï¼Œåä¹‹ï¼Œåˆ™å¤±è´¥ã€‚\nç°åœ¨ç»™è¿™ä¸ªæ£‹å­çš„èµ·å§‹ä½ç½®ï¼Œé—®æœ€åè·èƒœçš„ç©å®¶æ˜¯è°ï¼Œå¯¹äºæ‰€æœ‰çš„ $(i,j)$ æ»¡è¶³ $2 \\leq i,j \\leq n$ è¾“å‡º\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN][MAXN],n,m; string a,b; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=0;i\u0026lt;=m-2;i++){ dp[1][i+2]=(a[i]==\u0026#39;W\u0026#39;); } for(int i=0;i\u0026lt;=n-2;i++){ dp[i+2][1]=(b[i]==\u0026#39;W\u0026#39;); } for(int i=2;i\u0026lt;=n;i++){ for(int j=2;j\u0026lt;=m;j++){ dp[i][j]=!(dp[i-1][j]\u0026amp;\u0026amp;dp[i][j-1]); if(dp[i][j])cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;B\u0026#34;; } puts(\u0026#34;\u0026#34;); } } å–çŸ³å­æ¸¸æˆ æœ‰ä¸€å †çŸ³å­ï¼Œå¤§å°ä¸º $x$ï¼ŒAlice å’Œ Bob è½®æµæ“ä½œï¼ŒAlice å…ˆæ‰‹ï¼ŒAlice æ¯æ¬¡å¯ä»¥å– $a[i]$ ä¸ªçŸ³å­ï¼ŒBob å¯ä»¥å– $b[i]$ ä¸ªï¼Œè°ä¸èƒ½æ“ä½œå°±è¾“ã€‚\né—®è°èƒ½è·èƒœï¼Œå¯¹ $x = 1 \\sim m$ éƒ½è¾“å‡º\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n1, n2, m, a[N], b[N], A[N], B[N]; int main(){ cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n1; i++){ cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n2; i++){ cin \u0026gt;\u0026gt; b[i]; } for (int i = 1; i \u0026lt;= m; i++){ for (int j = 1; j \u0026lt;= n1; j++){ if(i \u0026gt;= a[j] \u0026amp;\u0026amp; B[i-a[j]] == 0){ A[i] = 1; break; } } for (int j = 1; j \u0026lt;= n2; j++){ if(i \u0026gt;= b[j] \u0026amp;\u0026amp; A[i-b[j]] == 0){ B[i] = 1; break; } } puts(A[i] ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); } return 0; } å¸¦å’Œå±€çš„æƒ…å†µ å­˜åœ¨å…ˆæ‰‹å¿…è´¥ï¼Œèƒœ\nå­˜åœ¨å’Œï¼Œå’Œ\nè´¥\nç»å…¸æ¨¡å‹ å·´ä»€åšå¼ˆ æœ‰ $n$ ä¸ªçŸ³å­ï¼Œæ¯æ¬¡å– $1 \\sim m$ ä¸ªï¼ŒAlice å…ˆå–ï¼Œè°å–æœ€åä¸€é¢—è°èƒœ\n$n % (m + 1) = 0$ï¼Œå…ˆæ‰‹å¿…è´¥\n$n % (m + 1) \\neq 0$ï¼Œå…ˆæ‰‹å¿…èƒœ\nå¨ä½å¤«åšå¼ˆ æœ‰ä¸¤å †çŸ³å­ï¼Œåˆ†åˆ«æœ‰ $a, b$ é¢—ï¼Œæ¯æ¬¡å¯ä»¥é€‰ä¸€å †å– $x$ ä¸ªï¼Œä¹Ÿå¯ä»¥é€‰ä¸¤å †éƒ½å– $x$ ä¸ª\næ‰€ä»¥ $(a, b)$ æœ‰ä¸‰ç§è½¬ç§»ï¼Œ$(a-x, b)$, $(a, b-x)$, $(a-x, b-x)$;\næ‰“è¡¨æ‰¾è§„å¾‹\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } é¦–å…ˆå‘ç° $(a, b)$ å’Œ $(b, a)$ï¼ŒçŠ¶æ€ç›¸åŒï¼Œå³åŒä¸ºå¿…è´¥æ€æˆ–å¿…èƒœæ€\nå†å¯¹ $a \u0026lt; b$ çš„æƒ…å†µåˆ†æï¼Œå‘ç° $a$ æ˜¯ä» $1$ åˆ° $n$ çš„ï¼Œ$b - a$ é€æ¸é€’å¢ï¼Œä¾æ¬¡ä¸º $1, 2, 3, 4, 5, \u0026hellip;$\nNim æ¨¡å‹ æœ‰ $n$ å †çŸ³å­ï¼Œæ¯å †æœ‰ $a[i]$ ä¸ªçŸ³å­ï¼ŒAlice å’Œ Bob è½®æµå–ï¼ŒAlice å…ˆå–ï¼Œæ¯æ¬¡å¯ä»¥ä»é€‰ä¸€å †ä»»å– $x$ ä¸ªçŸ³å­ï¼Œå¯ä»¥æ‹¿å…‰ï¼Œä½†ä¸èƒ½ä¸æ‹¿ï¼Œè°æœ€åæŠŠæ‰€æœ‰çš„æ‹¿å…‰è°è·èƒœ\nå…ˆæ‰“è¡¨\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; // for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) // if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } å‘ç° $i == j$ï¼Œç»æ¨å¹¿æ›´å¤šç»´ï¼Œå¯ä»¥æ€»ç»“å‡ºå¿…è´¥æ€ï¼š$A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\nè¦è¯æ˜æ­¤ç»“è®ºï¼Œå¯ä»ä¸‰ä¸ªå®šç†å…¥æ‰‹\n1ï¼šæ²¡æœ‰åç»­çŠ¶æ€çš„çŠ¶æ€æ˜¯å¿…è´¥æ€\n2ï¼šå¯¹äº $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n \\neq 0$ çš„å±€é¢ä¸€å®šå­˜åœ¨æŸç§ç§»åŠ¨ä½¿ $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\n3ï¼šå¯¹äº $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$ï¼Œä¸å­˜åœ¨ä¸€ç§ç§»åŠ¨ä½¿ $A_1 \\oplus A_2 \\oplus A_3 \\oplus \u0026hellip; \\oplus A_n = 0$\nä¾‹é¢˜ç»ƒä¹  çŸ³å­æ¸¸æˆ 2 æœ‰ $n$ å †çŸ³å­ï¼Œæ¯å †æœ‰ $a[i]$ ä¸ªçŸ³å­ï¼ŒAlice å’Œ Bob è½®æµæ“ä½œï¼Œæ¯æ¬¡å¯ä»¥æŠŠä¸€å †ä¸ªæ•°ä¸ºå¥‡æ•°çš„çŸ³å­åˆ†ä¸ºä¸¤å †ï¼Œä¸¤å †éƒ½ä¸èƒ½ä¸ºç©ºï¼Œæˆ–æŠŠä¸¤å †ä¸ºå¶æ•°çš„çŸ³å­å’Œä¸ºä¸€å †\nå¯ä»¥æ³¨æ„åˆ°ä¸¤ç§æ“ä½œéƒ½æ˜¯å¯¹å †æ•°æ”¹å˜ï¼Œé‚£ä¹ˆå †æ•°çš„å¥‡å¶æ€§å°±æ˜¯çªç ´ç‚¹ï¼ŒåŒæ—¶æ ¹æ®æ“ä½œçš„å®è´¨ï¼Œå¯ä»¥å‘ç°åªæœ‰ $1$ ä¸ªçŸ³å­çš„å †æ˜¯æ— æ³•ç»§ç»­æ“ä½œçš„ï¼Œæœ€åçŸ³å †å°†å˜æˆå…¨æ˜¯ $1$ æˆ–è€… $1$ ä¸ªå¶æ•°å‰©ä¸‹çš„å…¨æ˜¯ $1$\næ‰€ä»¥ç»“è®ºå°±æ˜¯ï¼šå¦‚æœçŸ³å †å…¨æ˜¯ $1$ï¼Œåˆ™å…ˆæ‰‹å¿…è´¥ï¼Œå¦‚æœä¸æ˜¯å…¨ä¸º $1$ é‚£ä¹ˆå°±æ£€æµ‹ç»“æŸæ—¶å †æ•°çš„å¥‡å¶æ€§æ˜¯å¦æ”¹å˜\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, odd, one; int x; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1;i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; x; if (x % 2 == 1) odd++; if (x == 1) one++; } if (one != n) odd++; if ((odd + n) % 2 != 0)cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#34;; return 0; } çŸ³å­æ¸¸æˆ 3 æœ‰ $n$ å †çŸ³å­ï¼Œæ¯å †æœ‰ $a[i]$ ä¸ªçŸ³å­ï¼ŒAlice å’Œ Bob è½®æµæ“ä½œï¼Œé€‰æ‹© $n/2$ å †éç©ºçŸ³å­ï¼Œæ¯å †ç§»é™¤æ‰æ­£æ•°ä¸ª(å¯ä»¥ä¸åŒ)çš„çŸ³å­ï¼Œä» Alice å¼€å§‹ã€‚\nå€’æ¨ï¼š\nå¿…è´¥ï¼šè¶…è¿‡ $n/2$ ä¸ªå †å·²ç»ä¸º $0$ å¿…èƒœï¼šæœ‰ $1 \\sim n/2$ ä¸ªå †ä¸º $0$\nå¿…è´¥ï¼šæœ‰ $\u0026gt; n/2$ ä¸ªå †çŸ³å­æ•°é‡ä¸º $1$\nå¿…èƒœï¼šæœ‰ $1 \\sim n/2$ ä¸ªå †çš„æ•°é‡ä¸º $1$\nå¿…è´¥ï¼šæœ‰ $\u0026gt; n/2$ ä¸ªå †çš„æ•°é‡ä¸º $2$\n\u0026hellip;\u0026hellip;\næœ‰å¤§äº $n/2$ ä¸ªå †çš„æ•°é‡ = minï¼Œå¿…è´¥\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, mx = 1e9, cnt; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if (x \u0026lt; mx) mx = x, cnt = 0; if (x == mx) cnt++; } if (cnt \u0026gt; n/2) cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; return 0; } SG æ¿å­ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int sg[1010]; int main() { int n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; i++) { set\u0026lt;int\u0026gt; s; for (int j = 1; j \u0026lt;= i; j *= p) { s.insert(sg[i - j]); } while (s.count(sg[i])) sg[i]++; printf(\u0026#34;%d %d\\n\u0026#34;, i, sg[i]); } return 0; } ","permalink":"http://localhost:1313/posts/study/%E5%8D%9A%E5%BC%88%E8%AE%BA/","summary":"ç®€å•çš„åšå¼ˆè®ºå­¦ä¹ ","title":"åšå¼ˆè®º"},{"content":"2024 æ²³å—èŒæ–°è”èµ› 2 çŠ¶æ€ + ç‹—è¿+ py å¤§æ³•ï¼Œç›®å‰æœ€å¥½çš„ä¸€æŠŠ\nI é‡ç”Ÿä¹‹zbkè¦æ‹¿å›å±äºä»–çš„ä¸€åˆ‡ ç­¾åˆ°ï¼Œæš´åŠ›æ‰¾ $chuan$ çš„æ•°é‡å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F æ°´çµçµçš„å°å­¦å¼Ÿ è§‚å¯Ÿé¢˜ç›®ï¼Œå‘ç°åšå¼ˆåŒæ–¹åç§°ç›¸åŒï¼Œä¸ç®¡è°èµ¢éƒ½ä¸€æ ·ï¼Œç›´æ¥è¾“å‡ºå³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;\u0026#34;DHY\\n\u0026#34;; } } A å›½é™…æ—…è¡Œ I è®¤çœŸè¯»é¢˜å¯å¾—çŸ¥ï¼Œæ’ä¸ºè”é€šå›¾ï¼Œæ’åºæ‰€æœ‰å›½å®¶å³å¯ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n,m,q,k; vector\u0026lt;int\u0026gt;a(N); map\u0026lt;int,int\u0026gt;vis; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } sort(a.begin()+1,a.begin()+1+n); while(q--){ cin\u0026gt;\u0026gt;k; cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; } } J è¿™æ˜¯ç­¾åˆ° çŸ©é˜µè®¡ç®—æ¿\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int a[6][6]; int cal(int n, int a[6][6]) { if (n == 1) return a[0][0]; int res = 0; int sub[6][6]; for (int x = 0; x \u0026lt; n; x++) { int subi = 0; for (int i = 1; i \u0026lt; n; i++) { int subj = 0; for (int j = 0; j \u0026lt; n; j++) { if (j == x) continue; sub[subi][subj] = a[i][j]; subj++; } subi++; } res += (x % 2 == 0 ? 1 : -1) * a[0][x] * cal(n - 1, sub); } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; a[i][j]; int ans = INT_MAX; int u=min(n,m); for(int i=1;i\u0026lt;=u;i++){ ans=min(ans,cal(i,a)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H ç‹¼ç‹¼çš„å¤‡å¿˜å½• STL å¤§æ³•å¥½\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, cnt, m; string s; map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; note; map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; vis; set\u0026lt;string\u0026gt; peo; void erase(string \u0026amp;a, string \u0026amp;b) { if (a == b) { b = \u0026#34;\u0026#34;; return; } if (a.size() \u0026gt; b.size() \u0026amp;\u0026amp; a.substr(a.size() - b.size()) == b) { b = \u0026#34;\u0026#34;; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; cnt; peo.insert(s); for (int j = 1; j \u0026lt;= cnt; j++) { string t; cin \u0026gt;\u0026gt; t; if (!vis[s][t]) note[s].push_back(t); vis[s][t]++; } } for (auto x : peo) { int m = note[x].size(); for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { erase(note[x][i], note[x][j]); erase(note[x][j], note[x][i]); } } sort(note[x].begin(), note[x].end()); note[x].erase(remove(note[x].begin(), note[x].end(), \u0026#34;\u0026#34;), note[x].end()); } cout \u0026lt;\u0026lt; peo.size() \u0026lt;\u0026lt; endl; for (auto x : peo) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; note[x].size(); for (auto s : note[x]) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s; } cout \u0026lt;\u0026lt; endl; } return 0; } D A*BBBB é«˜ç²¾åº¦ æ ¹æ®é¢˜æ„å¯çŸ¥ æ˜¯åŒä¸€ä¸ªç»“æœå¾€å‰ç§» $b.size()$ æ¬¡ç›¸åŠ  èµ›æ—¶ç¬¨æ¯”æ²¡è°ƒå‡ºæ¥ python å¼•å…¥ demical åº“è¿‡çš„\nèµ›æ—¶ä»£ç \nfrom decimal import * import sys t=int(input()) for i in range(t): setcontext(Context(prec=2000000, Emax=2000000, Emin=0)) print((Decimal(sys.stdin.readline())*Decimal(sys.stdin.readline()))) æ­£è§£\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e7+10; typedef long long ll; int a[N],sum[N],ans[N\u0026lt;\u0026lt;1]; string A,B; void solve(){ cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B; int la=A.length(),lb=B.length(),b=B[0]-\u0026#39;0\u0026#39;; ll last=0; a[la+1]=0; for(int i=1;i\u0026lt;=la;i++){ a[i]=(A[la-i]-\u0026#39;0\u0026#39;)*b+last; last=a[i]/10; a[i]*=10; sum[i]=sum[i-1]+a[i]; } sum[la+1]=sum[la]+last; last=0; for(int i=1;i\u0026lt;=la+lb;i++){ int l=min(i,la+1),r=max(0,i-lb); ans[i]=sum[l]-sum[r]+last; last=ans[i]/10; ans[i]%=10; } bool flag=0; for(int i=la+lb;i\u0026gt;=1;--i) { if(!ans[i]) { if(flag) printf(\u0026#34;%d\u0026#34;,ans[i]); } else { flag=1; printf(\u0026#34;%d\u0026#34;,ans[i]); } } if(!flag) printf(\u0026#34;0\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E \u0026ldquo;å¥½\u0026quot;å­—ç¬¦ è§‚å¯Ÿå¾—åˆ° $a$ï¼Œ$b$ åŒä¸€å­—ç¬¦æ‰€å¤„ä½ç½®ç›¸é‚»å·®å€¼æ„æˆçš„ä¸€ä¸ªå¾ªç¯åŒæ„å¦‚æœç›¸åŒï¼Œå°±ç¬¦åˆé¢˜æ„\né‚£ä¹ˆå°±å¯¹ 26 ä¸ªå­—ç¬¦å„è·‘ä¸€æ¬¡ æ‰¾åˆ°ä½ç½® å­˜å…¥å­—ç¬¦ä¸² æ‰¾åˆ°è¯¥ä¸²çš„æœ€å°è¡¨ç¤º æ¯”è¾ƒå³å¯\néœ€è¦æ³¨æ„å°†åŸ $a$ï¼Œ$b$ å†å¤åˆ¶æœ¬èº«ä¸€é å› ä¸ºè¿™æ ·æ‰èƒ½ä¿è¯æ‰¾çš„æœ€å°è¡¨ç¤ºæ²¡æœ‰ç¼ºå°‘\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp(int nxt[], string a) { int n = a.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; a[i] != a[j]) j = nxt[j - 1]; if (a[i] == a[j]) j++; nxt[i] = j; } return n - nxt[n - 1]; } string getmin(string s, int n) { s = s + s; int i = 0, j = 1; while (j \u0026lt; n) { int k = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) ++k; if (s[i + k] \u0026gt; s[j + k]) i += k + 1; else j += k + 1; if (i == j) j++; if (i \u0026gt; j) swap(i, j); } string t = s.substr(i, n); return t; } int main() { int n; string a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = a + a; b = b + b; map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; va, vb; map\u0026lt;char, string\u0026gt; sa, sb; for (int i = 0; i \u0026lt; n * 2; i++) { va[a[i]].push_back(i); vb[b[i]].push_back(i); } int cnt = 0, nxt[2000010]; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { if (va[x].size() != vb[x].size() || va[x].size() == 0 || vb[x].size() == 0) continue; for (int i = 1; i \u0026lt; va[x].size(); i++) { sa[x] += to_string(va[x][i] - va[x][i - 1]); } for (int i = 1; i \u0026lt; vb[x].size(); i++) { sb[x] += to_string(vb[x][i] - vb[x][i - 1]); } if (getmin(sa[x], kmp(nxt, sa[x])) == getmin(sb[x], kmp(nxt, sb[x]))) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C å° $w$ å’Œå¤§ $W$ çš„å¯¹å†³ sg æš´åŠ›æ‰“è¡¨ å‘ç° 8 ä¸ªä¸ºä¸€ä¸ªå¾ªç¯ æœ€åä¸¤ä¸ªäº¤æ¢ä½ç½®\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int calc(int x){ if(x%8==0)return x-1; if(x%8==7)return x+1; else return x; } int ans; int main(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=calc(x); } if(ans==0)cout\u0026lt;\u0026lt;\u0026#34;W win\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;w win\\n\u0026#34;; } G $lxy$ çš„é€šé£æŠ¥ä¿¡ å› ä¸ºæ•°æ®ä¸å¤§ï¼Œç›´æ¥ bfs è·‘æ¯ä¸ªç‚¹å¯¹å…¶ä»–ç‚¹çš„è·ç¦»ï¼Œå†æ±‚æœ€å°ç”Ÿæˆæ ‘å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; struct Node{ int x,y,id; }b[N]; int n,m,ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},tot,dis[N][N],a[N][N]; bool vis[N]; deque\u0026lt;Node\u0026gt;q; void bfs(int id){ q.clear(); q.push_back(Node{b[id].x,b[id].y,0}); dis[b[id].x][b[id].y]=0; while(!q.empty()){ Node now=q.front(); q.pop_front(); for(int i=0;i\u0026lt;4;i++){ int x=now.x+dx[i],y=now.y+dy[i]; if(x\u0026lt;1||y\u0026lt;1||x\u0026gt;n||y\u0026gt;m||a[x][y]==-1)continue; if(dis[x][y]\u0026gt;now.id+1){ dis[x][y]=now.id+1; q.push_back(Node{x,y,dis[x][y]}); } } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ dis[i][j]=1e9; char x; cin\u0026gt;\u0026gt;x; if(x==\u0026#39;.\u0026#39;)a[i][j]=0; else if(x==\u0026#39;#\u0026#39;)a[i][j]=-1; else { a[i][j]=++tot; b[tot]=Node{i,j,tot}; } } } dis[b[1].x][b[1].y]=0; for(int i=1;i\u0026lt;=tot;i++){ int mi=1e9,id=0; for(int j=1;j\u0026lt;=tot;++j){ if(vis[j])continue; if(mi\u0026gt;dis[b[j].x][b[j].y])mi=dis[b[j].x][b[j].y],id=j; } if(!id){ puts(\u0026#34;No\u0026#34;); return; } vis[id]=1; ans+=mi; if(i!=tot)bfs(id); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"http://localhost:1313/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B2/","summary":"æ¯”èµ›çˆ½çˆ½","title":"2024èŒæ–°è”èµ›2"},{"content":"æœ€å°è¡¨ç¤ºæ³• ç†è®ºå­¦ä¹  ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² $s$ï¼Œé¦–å°¾ç›¸æ¥ï¼ˆå¾ªç¯åŒæ„ï¼‰ï¼Œæ‰¾åˆ°å…¶å­—å…¸åºæœ€å°çš„æƒ…å†µ $O(n)$\nç”¨ä¸¤ä¸ªæŒ‡é’ˆ $i,j$ï¼Œåˆ†åˆ«æŒ‡å‘ç›®å‰ä¸¤ä¸ªå¯èƒ½æ˜¯ç­”æ¡ˆçš„èµ·å§‹ä½ç½®\nåˆå§‹ $i = 1, j = 2$ï¼Œéšç€ç®—æ³•è¿›è¡Œå¢å¤§\nå‡è®¾ç°åœ¨ $i \u0026lt; j$ï¼Œä¸”ä» $i$ å¼€å§‹çš„ $k$ ä½å­—ç¬¦å’Œä» $j$ å¼€å§‹çš„ $k$ ä½å­—ç¬¦æ˜¯ä¸€æ ·çš„ï¼Œæ­¤æ—¶è¿™ä¸¤æ®µå­ä¸²ç›¸åŒ\nå¦‚æœ $s[i+k] \\neq s[j+k]$\nè°å¤§è°å¾€åç§»åŠ¨ $k+1$ ä¸ªä½ç½®\nå¦‚æœ $s[i+k] == s[j+k]$\néšä¾¿ç§»åŠ¨ä¸€ä¸ª\næœ€åå°äº $n$ çš„é‚£ä¸ªæŒ‡é’ˆå°±æ˜¯æ‰€æ±‚ç­”æ¡ˆ\nvoid getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } ä¾‹é¢˜ å¾ªç¯åŒæ„åˆ¤æ–­ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² $a, b$ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å¾ªç¯åŒæ„\nåªéœ€åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æœ€å°è¡¨ç¤ºæ˜¯å¦ä¸€æ ·å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a,b; int getmin(string s){ int n=s.size(); int i=0,j=1; s=s+s; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)++j; if(i\u0026gt;j)swap(i,j); } return i; } int main(){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=getmin(a),j=getmin(b),k=0;k\u0026lt;n;k++){ if(a[(i+k)%n]!=b[(j+k)%n]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return 0; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } æœ€å°å¾ªç¯è¦†ç›– ç»™å‡ºå­—ç¬¦ä¸² $a$ï¼Œæ±‚å‡ºè¿™ä¸ªå­—ç¬¦ä¸²çš„å­—å…¸åºæœ€å°çš„æœ€å°å¾ªç¯è¦†ç›–\nå…ˆç”¨ $kmp$ æ±‚å‡ºæœ€å°å¾ªç¯ç‰‡æ®µé•¿åº¦ï¼Œå†æ±‚è¿™ä¸ªé•¿åº¦çš„å­ä¸²çš„æœ€å°è¡¨ç¤º\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a; int nxt[100005]; int kmp(){ int n=a.size(); nxt[0]=0; int j=0; for(int i=1;i\u0026lt;n;i++){ while(j\u0026amp;\u0026amp;a[i]!=a[j]) j=nxt[j-1]; if(a[i]==a[j]) j++; nxt[i]=j; } return n-nxt[n-1]; } void getmin(string s,int n){ s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int l=i;l\u0026lt;i+n;l++)cout\u0026lt;\u0026lt;s[l]; } int main(){ cin\u0026gt;\u0026gt;a; getmin(a,kmp()); return 0; } ","permalink":"http://localhost:1313/posts/study/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"æœ€å°è¡¨ç¤ºæ³•å­¦ä¹ è®°å½•","title":"æœ€å°è¡¨ç¤ºæ³•"},{"content":"æ­ç”µå¤šæ ¡ 2 è¡¥é¢˜ 1010 å¥³ç¥çš„ç¿æ™º æŒ‰é¡ºåºåˆå¹¶ 8 å—ç¢ç‰‡ï¼Œå¦‚æœä¸¤ç‰‡ç›¸åŒï¼Œåˆæˆåä»ç›¸åŒï¼Œå¦‚ä¸åŒï¼Œå–å·¦ä¾§çš„ï¼Œæœ€ååˆæˆå¤§ç¢ç‰‡æ—¶ï¼Œå¦‚æœä¸¤ç‰‡ç›¸åŒï¼Œä¸å˜ï¼Œå¦‚æœä¸åŒï¼Œå–å‡ºç°æ¬¡æ•°æœ€å¤šçš„ï¼Œå¦‚æœä¸ç¡®å®šï¼Œè¾“å‡º $N$ã€‚\nç­¾åˆ°ï¼Œç›´æ¥æš´åŠ›\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vis[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL åˆ’åˆ† è¾“å…¥: 1 s3://hdu-oj-bucket/problem=1/type=data/ è¾“å‡ºï¼š s3 hdu-oj-bucket problem=1 type=data\nç­¾åˆ°ï¼ŒæŒ‰é¢˜æ„æ‹†åˆ†å­—ç¬¦ä¸²å³å¯\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string s; cin\u0026gt;\u0026gt;s; int pos = s.find(\u0026#34;://\u0026#34;); cout\u0026lt;\u0026lt;s.substr(0,pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; pos+=3; int now = s.find(\u0026#34;/\u0026#34;,pos); cout\u0026lt;\u0026lt;s.substr(pos,now-pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; while(1){ pos=now+1; if(pos\u0026gt;=s.size())break; now = s.find(\u0026#34;/\u0026#34;,pos); string t = s.substr(pos,now-pos); int flag = t.find(\u0026#34;=\u0026#34;); if(flag!=-1)cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1001 é¸¡çˆª ç»™ $n$ æ¡è¾¹ï¼Œä»»æ„é¡¶ç‚¹ï¼Œæ„é€ æ•°é‡æœ€å¤šçš„é¸¡çˆªï¼ŒåŒæ—¶ä¿è¯è¾“å‡ºæ¯æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹æ—¶ï¼Œä¿è¯è¡Œä¼˜å…ˆéå†ï¼Œå­—å…¸åºæœ€å°ã€‚\né¸¡çˆªçš„å®šä¹‰ï¼š1 ä¸ªé¡¶ç‚¹ï¼Œå’Œå®ƒæ‰€è¿çš„ 3 æ¡è¾¹ï¼Œä¸åŒ…æ‹¬å…¶ä»–é¡¶ç‚¹ï¼Œä¸å¯é‡å¤åˆ©ç”¨ã€‚\næ„é€ ï¼Œæ˜“æƒ³å‡º $n$ æ¡è¾¹ï¼Œæœ€å¤šæ„é€ å‡º $n/3$ ä¸ªé¸¡çˆªï¼Œå¤šå‡ºçš„ 1 æˆ– 2 ä¸ªè¾¹ï¼Œè¡¥åˆ°é¡¶ç‚¹1ä¸Šå³å¯ã€‚\nå› ä¸ºå­—å…¸åºæœ€å°ï¼Œæ‰€ä»¥é¡¶ç‚¹ 1 ä¸Šè¿çš„è¾¹è‚¯å®šæœ€å¤šï¼Œæˆ‘ä»¬å°±è®© 1 è¿åˆ°æ‰€æœ‰çš„é¡¶ç‚¹ä¸Šï¼Œè¿™æ ·å…¶ä»–æ‰€æœ‰æ„é€ é¸¡çˆªçš„é¡¶ç‚¹ $n$ éƒ½èƒ½ç”¨ä¸Š $1-n$ è¿™æ¡è¾¹ã€‚å› æ­¤ 1 è‡ªå·±ç”¨çš„è¾¹è‚¯å®šæ˜¯å…¥åº¦æœ€å°çš„å‡ ä¸ªé¡¶ç‚¹ï¼Œå³ç¼–å·æœ€å¤§çš„é¡¶ç‚¹ï¼Œç±»æ¨åˆ°ä¹‹åçš„é¡¶ç‚¹ï¼Œéƒ½æ˜¯å…ˆé‡‡ç”¨ä¸å…¶ä¹‹å‰çš„é¡¶ç‚¹çš„è¾¹ï¼Œå†ä»æœ€åé¢é€‰ã€‚åˆ°é¡¶ç‚¹ 4 å¼€å§‹ï¼Œä¸å†éœ€è¦å¾€åé‡‡ç”¨ï¼Œå› ä¸ºå‰é¢æœ‰ 3 ä¸ªé¡¶ç‚¹æä¾›è¾¹ï¼Œä¸å†éœ€è¦é¢å¤–çš„é¡¶ç‚¹æ¥æä¾›è¾¹ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n\u0026gt;=3){ int now=0,cnt=n/3+3; for(int i=1;i\u0026lt;=min(n/3,3);i++){ for(int j=i+1;j\u0026lt;=cnt-i+1;j++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(i==1\u0026amp;\u0026amp;j==cnt-i+1){ int now=j; while(n%3!=0){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;++now\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; n--; } } } } } else{ for(int i=2;i\u0026lt;=n+1;i++)cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1006 ä¼ å¥‡å‹‡å£«å°å‡¯ æœ‰ä¸€ä¸ª $n$ ä¸ªç»“ç‚¹çš„æœ‰æ ¹æ ‘ï¼Œä½ éœ€è¦ä» 1 å·ç»“ç‚¹èµ°åˆ°ä»»æ„ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œæ¯å¤©ä½ æœ‰ $p[i]/15$ çš„å¯èƒ½æ€§å¯ä»¥å‘ä»»æ„ä¸€ä¸ªå„¿å­èŠ‚ç‚¹èµ°ä¸€æ­¥ï¼ˆ $i$ ä¸ºä½ å½“å‰æ‰€åœ¨çš„èŠ‚ç‚¹ç¼–å·ï¼‰ï¼Œè¯¢é—®ä½ æœŸæœ›æœ€å¤šå¯ä»¥åœ¨è¿™é¢—æ ‘ä¸Šèµ°å¤šä¹…\næœŸæœ›è®¡ç®—ï¼Œåœ¨æŸä¸€èŠ‚ç‚¹åœç•™çš„æ­¥æ•°åº”è¯¥ä¸º $15/p[i]$ ã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; ll ans=0, LCM=360360; vector\u0026lt;int\u0026gt; nxt[N]; vector\u0026lt;int\u0026gt; p(N); ll gcd(int x,int y){ if(!x||!y)return x+y; return gcd(y,x%y); } void dfs(int u,int fa, ll sum) { sum += (LCM / p[u]); if(sum\u0026gt;ans)ans=sum; for (auto x : nxt[u]) { if(x==fa)continue; dfs(x, u, sum); } } void solve() { int n; cin \u0026gt;\u0026gt; n; ans=0; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; nxt[u].push_back(v); nxt[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; dfs(1, 0, 0); ll d=gcd(15*ans,LCM); printf(\u0026#34;%lld/%lld\\n\u0026#34;,15*ans/d,LCM/d); for (int i = 1; i \u0026lt;= n; i++) nxt[i].clear(); } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 1003 ç»å¯¹ä¸æ¨¡æ‹Ÿçš„ç®€å•é­”æ–¹ 1)æš´åŠ›ï¼Œä»åˆå§‹çŠ¶æ€å¼€å§‹æ¨¡æ‹Ÿï¼Œæ¯æ¬¡å¯¹æ¯”å½“å‰çŠ¶æ€å’Œç»™å‡ºçŠ¶æ€ï¼Œè‹¥ç›¸åŒæˆ–ä¸åŒç‚¹ä»…ä¸¤ä¸ªï¼Œå³å¾—åˆ°ç­”æ¡ˆ\n2)å°†é­”æ–¹è§†ä¸º 2 é˜¶çš„ï¼Œé¢„å¤„ç†å¾—åˆ° 24 ç§å¯èƒ½çŠ¶æ€ï¼Œä¸ç»™å‡ºçŠ¶æ€å¯¹æ¯”ï¼Œè‡³å¤šæœ‰ä¸€ä¸ªè§’ä¸åŒï¼Œå³ä¸ºç­”æ¡ˆã€‚\nä¹‹åè¡¥... 1011 åœ¨ A é‡Œé¢æ‰¾æœ‰ C çš„ B ACè‡ªåŠ¨æœºï¼ˆè¿˜ä¸ä¼šï¼Œä¹‹åè¡¥\u0026hellip;.\n","permalink":"http://localhost:1313/posts/study/2024hdu2/","summary":"éš¾éš¾","title":"2024HDU2"},{"content":"Manacher ç†å¿µå­¦ä¹  è§£å†³æœ€é•¿å›æ–‡å­ä¸²é—®é¢˜\nç»™å‡ºä¸€ä¸ªä»»æ„å­—ç¬¦ä¸²ï¼Œæ±‚å‡ºè¿™ä¸ªå­—ç¬¦ä¸²ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²\næ­£å¸¸æƒ…å†µä¸‹ï¼Œéœ€è¦å¯¹é•¿åº¦å¥‡å¶ä¸åŒçš„åˆ†ç±»è®¨è®ºã€‚ä½†å¯ä»¥ç”¨ä¸€ä¸ª $s$ ä¸­ä¸å­˜åœ¨çš„å­—ç¬¦ï¼ŒæŠŠ $s$ ä¸­æ¯ä¸€ä½éš”å¼€ï¼Œå†æ±‚æ–°ä¸²ä¸­å¥‡æ•°é•¿åº¦çš„æœ€é•¿å›æ–‡å­ä¸²å³å¯\nå¯¹äºæ–°ä¸² $s$ ï¼Œæˆ‘ä»¬çš„ç›®çš„æ˜¯æ±‚å‡ºä»å®ƒçš„ä»»æ„ä½ç½® $i$ å‡ºå‘ï¼Œå¾€ä¸¤è¾¹æœ€è¿œèƒ½æ‹“å±•å‡ºçš„å›æ–‡å­ä¸²çš„é•¿åº¦ï¼Œè®°åš $p[i]$ (åŒ…æ‹¬ $i$ æœ¬èº«ï¼Œæ‰€ä»¥æœ€å°ä¸º 1)\nç»´æŠ¤ $p[i]$ çš„å€¼ï¼š\nç»´æŠ¤ä¸€ä¸ªåˆ°ç›®å‰ä½ç½®çš„ $R$ æœ€å¤§çš„åŒºé—´ $[L, R]$ï¼Œå…¶ä¸­ $L = M - p[M] + 1$ ($M \u0026lt; i$) $R = M + p[M] - 1$\n$[L, R]$ æ˜¯ä¸€ä¸ªå›æ–‡ä¸² å¦‚æœ $i \\leq R$:\næ‰¾åˆ° $i$ å¯¹äº $M$ çš„å¯¹ç§°ç‚¹ $k$ï¼Œæ­¤æ—¶ $i - M = M - k, k = 2 * M - i$; æ­¤æ—¶æœ‰ä¸¤ç§æƒ…å†µï¼š\n(1) å¦‚æœ $p[k]$ å¯¹åº”çš„å›æ–‡åŒºé—´ $[k - p[k] + 1, k + p[k] - 1]$ï¼Œä¸å«å·¦ç«¯ç‚¹ $L$ï¼Œè¯´æ˜è¿™ä¸ªå›æ–‡åŒºé—´åœ¨ $[L, R]$ ä¹‹ä¸­ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å¾—åˆ° $p[i] = p[k]$\n(2) å¦‚æœåŒ…å«äº†å·¦ç«¯ç‚¹ $L$ï¼Œæ­¤æ—¶ $[L, 2k-L]$ è¿™ä¸€ç«¯ä¸ºå›æ–‡ä¸²ã€‚ç”±äº $[L, R]$ æ˜¯å›æ–‡ä¸²ï¼Œå¯å¾—å‡º $[2i-R, R]$ ä¹Ÿæ˜¯å›æ–‡ä¸²ã€‚å¾€ä¸¤ç«¯æš´åŠ›æ‹“å±•å³å¯ã€‚ å¦‚æœ $i \u0026gt; R$ï¼š\næš´åŠ›ä¸¤ç«¯æ‹“å±•å³å¯ éƒ½è¦è®°å¾—æ›´æ–° $M, L, R$ çš„å€¼ã€‚\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } æ´›è°·ä¾‹é¢˜ P3805\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; int n,p[2*N]; string s,t; void manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s; manacher(); return 0; } å‘ç‚¹ï¼šå­—ç¬¦ä¸² $t$ è¦ resizeï¼Œä¸ç„¶ re\n","permalink":"http://localhost:1313/posts/study/manacher/","summary":"é©¬æ‹‰è½¦å­¦ä¹ è®°å½•","title":"Manacher"},{"content":"0721 å­¦ä¹ è®°å½• ä»Šå¤©é›†è®­ä¼‘æ¯ï¼Œè‡ªå·±çœ‹äº†çœ‹ä»£ç æºçš„è§†é¢‘è¡¥çŸ¥è¯†ç‚¹\nkmp ç›¸å…³ å­ä¸²æŸ¥è¯¢ è¾“å…¥ä¸¤ä¸ªå­—ç¬¦ä¸² $s$, $p$ï¼ŒæŸ¥è¯¢ $p$ æ˜¯å¦åœ¨ $s$ ä¸­å‡ºç°ï¼Œè‹¥å‡ºç°è¾“å‡ºå‡ºç°ä½ç½®ï¼Œå¦åˆ™è¾“å‡º $-1$\nç®€åŒ–ç‰ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } å¸¸è§„ç‰ˆ\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){ while(j==m||(j\u0026amp;\u0026amp;s[i]!=p[j])) j=nxt[j-1]; if(s[i]==p[j]) j++; f[i]=j; } for(int i=0;i\u0026lt;n;i++){ if(f[i]==m)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } å¯»æ‰¾æœ€å°å¾ªç¯å­ä¸² å­—ç¬¦ä¸² $s$ æ˜¯ç”±æŸä¸ªå­ä¸²é‡å¤è¿æ¥è€Œæˆçš„ï¼Œå¯»æ‰¾æ„æˆ $s$ çš„æœ€å°å­ä¸²çš„é•¿åº¦\nç­”æ¡ˆå…¶å®å°±æ˜¯ $n - \\text{nxt}[n]$\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],n,m; void kmp(){ m=p.size(); int j=0; nxt[0]=0; p=p; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } cout\u0026lt;\u0026lt;m-nxt[m-1]\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;p; kmp(); return 0; } Secret word ç»™å‡ºå­—ç¬¦ä¸² $s$ï¼Œå¯»æ‰¾æœ€é•¿å­—ç¬¦ä¸² $p$ï¼Œ$p$ æ»¡è¶³ï¼ˆæ˜¯ $s$ çš„å­ä¸²ï¼Œç¿»è½¬åæ˜¯ $s$ çš„å‰ç¼€ï¼‰\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int nxt[200001],n; void kmp(){ n=s.size(); int j=0; nxt[0]=0; string t=s; reverse(t.begin(),t.end()); s=s+\u0026#34;#\u0026#34;+t; for(int i=1;i\u0026lt;n*2+1;i++){ while(j\u0026amp;\u0026amp;s[i]!=s[j]) j=nxt[j-1]; if(s[i]==s[j]) j++; nxt[i]=j; } int ans=-1; for(int i=n;i\u0026lt;2*n+1;i++){ ans=max(ans,nxt[i]); } for(int i=ans-1;i\u0026gt;=0;i--)cout\u0026lt;\u0026lt;s[i]; } int main(){ cin\u0026gt;\u0026gt;s; kmp(); return 0; } exkmp æ´›è°· P5410\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; typedef long long ll; string s,p; ll z[N*2],n,m; void exkmp(string s,string p){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; ll L=0,R=-1; z[0]=m; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ ll k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } ll ans=0; for(int i=0;i\u0026lt;m;i++)ans^=(1LL*(i+1)*(z[i]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ans=0; for(int i=0;i\u0026lt;n;i++)ans^=(1LL*(i+1)*(z[i+m+1]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(s,p); return 0; } ","permalink":"http://localhost:1313/posts/study/0721/","summary":"æ—¥å¸¸å­¦ä¹ è®°å½•","title":"0721"},{"content":"KMPå­¦ä¹ è®°å½• ç†å¿µå­¦ä¹  å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ æŸ¥æ‰¾$s$ä¸­$p$æ˜¯å¦å‡ºç°\næš´åŠ›åŒ¹é… $O(nm)$\nå“ˆå¸Œä¼˜åŒ– $O(n+m)$\nKMP çº¿æ€§å¤æ‚åº¦è§£å†³ $O(n+m)$\nKMP ä¸­å¯¹äº $s$ ä¸­æ¯ä¸ªä½ç½® $i$ï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°æœ€å¤§çš„ $j$ æ»¡è¶³$s[i - j +1]\u0026hellip;s[i]$ å’Œ $p[1]\u0026hellip;[j]$ ç›¸åŒ\n$f[i]$ å¯¹åº”$j$çš„ä½ç½®ï¼Œ$j$å¯¹åº”$p$ä¸­çš„ä½ç½®\nå¦‚æœ $j$ ä¸ç­‰äº $m$ï¼Œå¹¶ä¸” $s[i + 1] == p[j + 1]$ï¼Œ$j$ å³ç§»ä¸€ä½\nå¦åˆ™ï¼Œ$j$ å‘å‰å›é€€ï¼Œåˆ°æ»¡è¶³ $s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j]$ ä¸” $k$ æœ€å¤§çš„ä½\nå¦‚æœ $s[i + 1]$ ä»ä¸ç­‰äº $p[j + 1]$ï¼Œä¸åœå‘å‰å›é€€ï¼Œç›´åˆ°ç›¸ç­‰æˆ– $j = 0$\nå¿«é€Ÿæ±‚å‡º $k$\næ˜“å¾—åˆ°æ±‚ $k$ ä¸ $s$ æ— å…³\næœ€å¤§çš„ $k$ æ»¡è¶³ $k \u0026lt; j$ï¼Œä½¿å¾— $p[1]..p[k]$ å’Œ $p[j - k + 1]\u0026hellip;p[j]$ å®Œå…¨ç›¸åŒ\nå¯ä»¥ç”¨ $next$ ç»´æŠ¤æ¯ä¸ª $j$ å¯¹åº”çš„ $k$\nvoid kmp(){ n=s.size()+1,m=p.size()+1;//å­—ç¬¦ä¸²ä¸‹æ ‡ä» 1 å¼€å§‹ int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } æ´›è°·ä¾‹é¢˜ P3375\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n, m; string s, p; int nxt[N], f[N]; void kmp() { n = s.size(); m = p.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j]) j = nxt[j - 1]; if (p[i] == p[j]) j++; nxt[i] = j; } j = 0; for (int i = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j]) j = nxt[j - 1]; if (s[i] == p[j]) j++; f[i] = j; if (j == m) { cout \u0026lt;\u0026lt; i - m + 2 \u0026lt;\u0026lt; endl; j = nxt[j - 1]; } } for (int i = 0; i \u0026lt; m; i++) { cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; kmp(); return 0; } EXKMP(Z-algorithm) ç†è®ºå­¦ä¹  çº¿æ€§æ—¶é—´å¤æ‚åº¦æ±‚å‡ºå­—ç¬¦ä¸²$s$å’Œä»–çš„ä»»æ„åç¼€ $s[i]\u0026hellip;s[n]$ çš„æœ€é•¿å…¬å…±å‰ç¼€çš„é•¿åº¦ $O(n)$\nä¸ kmp çš„åŒºåˆ«ï¼šä¸€ä¸ªæ˜¯åˆ° $s[i]$ ç»“æŸï¼Œä¸€ä¸ªæ˜¯ä» $s[i]$ å¼€å§‹\nå®šä¹‰ $z[1] = 0$ï¼Œä» $2$ åˆ° $n$ æšä¸¾ $i$ï¼Œä¾æ¬¡è®¡ç®— $z[i]$ çš„å€¼\nè®¡ç®— $z[i]$ æ—¶ï¼Œå‰é¢çš„ $z$ éƒ½å·²ç»è®¡ç®—å¥½äº†\nå¯¹äº $j$ï¼Œæœ‰ $s[j]\u0026hellip;s[j + z[j] - 1]$ å’Œ $s[1]\u0026hellip;s[z[j]]$ å®Œå…¨ç›¸ç­‰\nä¸ºäº†è®¡ç®— $z[i]$ï¼Œåœ¨æšä¸¾$i$çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦ç»´æŠ¤$R$çš„æœ€å¤§åŒºé—´ $[L, R]$ï¼Œå…¶ä¸­ $L = j$ï¼Œ$R =j + z[i] - 1$\nåˆå§‹æ—¶ $L = 1,R = 0$\nå¦‚æœ $i \\leq R$:\næ˜“çŸ¥ $s[L]\u0026hellip;s[R] = s[1]\u0026hellip;s[R - L + 1]$\nä»¤ $k = i - L + 1$ï¼Œ$i$ ä¸ $k$ çš„ä½ç½®å¯¹åº”ï¼Œæ­¤æ—¶$s[i]..s[R] = s[k]..s[R - L + 1]$\nå¦‚æœ $z[k] \u0026lt; R - i + 1$ï¼Œè¯´æ˜ä» $k$ å¼€å§‹åŒ¹é…ä¸åˆ°é‚£ä¹ˆè¿œï¼Œä¹Ÿå°±æ˜¯ä» $i$ å¼€å§‹åŒ¹é…ä¸åˆ° $R$ï¼Œæ­¤æ—¶ $z[i] = z[k]$\nåä¹‹ï¼Œè¯´æ˜å¯ä»¥åŒ¹é…åˆ° $R$ é‚£ä¹ˆè¿œï¼Œä» $R+1$ å¼€å§‹å¾€åæš´åŠ›\nå¦‚æœ $i \u0026gt; R$:\næš´åŠ›æšä¸¾åŒ¹é…ï¼Œè®°å¾—æ›´æ–° $L$ å’Œ $R$\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } ä¾‹é¢˜ ç»™å‡ºå­—ç¬¦ä¸² $s$, $p$ï¼Œæ±‚ $s$ ä¸­ $p$ å‡ºç°çš„æ¬¡æ•°å’Œä½ç½®\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int z[200001],n,m; void exkmp(){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; int L=0,R=-1; z[0]=0; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } int ans=0; for(int i=m+1;i\u0026lt;m+n+1;i++) if(z[i]==m)ans++; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=m+1;i\u0026lt;n+m+1;i++) if(z[i]==m)cout\u0026lt;\u0026lt;i-m\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(); return 0; } ","permalink":"http://localhost:1313/posts/study/kmp/","summary":"KMP å­¦ä¹ è®°å½•","title":"KMP"},{"content":"ç®€å•çš„æ’åºå®ç° å¿«é€Ÿæ’åº å¿«æ’ åˆ†æ²»æ€æƒ³ å¤æ‚åº¦ $[n\\log n, n^2]$ ä¸ç¨³å®š \u0026ndash;$x$éšæœºå–\næ’åºåŒºé—´ä¸º $[l, r]$ æ—¶ï¼Œé•¿åº¦å°äº $1$ï¼Œç›´æ¥é€€å‡ºï¼Œå¦åˆ™é€‰ä¸€ä¸ªæ•°å­— $x$ ä½œä¸ºæ¯”è¾ƒå…ƒç´ \nå°†å¤§äº $x$ çš„æ”¾å³è¾¹ï¼Œå°äº $x$ çš„æ”¾å·¦è¾¹ï¼Œç­‰äº $x$ çš„éšæ„æ”¾\nç¡®å®š $x$ çš„ä½ç½®åï¼Œå¯¹ä¸¤ä¾§ç»§ç»­é€’å½’\nvoid quicksort(int l, int r) { if (l \u0026gt;= r) return; // é•¿åº¦å°äº 1ï¼Œç›´æ¥é€€å‡º swap(a[l], a[l + rand() % (r - l + 1)]); // ä¿è¯ x éšæœºå– int x = a[l]; int i = l, j = r; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt; x) // ä¸èƒ½å†™æˆ a[j] \u0026gt;= x j--; if (i \u0026lt; j) a[i++] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt; x) // ä¸èƒ½å†™æˆ a[i] \u0026lt;= x i++; if (i \u0026lt; j) a[j--] = a[i]; } a[i] = x; quicksort(l, i - 1); // ä¸èƒ½é€’å½’ i quicksort(i + 1, r); } //å¦ä¸€ç§å†™æ³•\nvoid Quicksort(int l, int r){ if(l\u0026gt;=r)return; int b[100001],c[100001]; int x=a[l+rand()\u0026amp;(r-l+1)]; int l1=0,l2=0,y=0; for(int i=l;i\u0026lt;=r;i++){ if(a[i]\u0026lt;x) b[++l1]=a[i]; else if(a[i]\u0026gt;x) c[++l2]=a[i]; else ++y; } for(int i=1;i\u0026lt;=l1;i++) a[l+i-1]=b[i]; for(int i=1;i\u0026lt;=y;i++) a[l+l1+i-1]=x; for(int i=1;i\u0026lt;=l2;i++) a[l+l1+y+i-1]=c[i]; Quicksort(l,l+l1-1); Quicksort(l+l1+y,r); } å½’å¹¶æ’åº å½’å¹¶æ’åº åˆ†æ²» å¤æ‚åº¦ $n\\log n$ ä¸”ç¨³å®š è¦æ’åº $[l, r]$ï¼Œé•¿åº¦ä¸º$1$ç›´æ¥é€€å‡ºï¼Œå¦åˆ™åˆ†ä¸º $[l, m],[m+1, r]$; é€’å½’ä¸¤ä¸ªå­åŒºé—´è¿›è¡Œå½’å¹¶æ’åº å°†æ’åºå¥½çš„å­åŒºé—´åˆå¹¶\nvoid mergesort(int l,int r){ if(l==r)return; int m=(l+r)/2; mergesort(l,m); mergesort(m+1,r); int p1=l,p2=m+1,tot=0; while(p1\u0026lt;=m\u0026amp;\u0026amp;p2\u0026lt;=r){ if(a[p1]\u0026lt;=a[p2]) c[++tot]==a[p1++]; else c[++tot]=a[p2++]; } while(p1\u0026lt;=m) c[++tot]=a[p1++]; while(p2\u0026lt;=m) c[++tot]=a[p2++]; for(int i=1;i\u0026lt;=tot;i++) a[i+l-1]=c[i]; } è®¡æ•°æ’åº è®¡æ•°æ’åº é€‚åˆå€¼åŸŸèŒƒå›´è¾ƒå° å¤æ‚åº¦ $n+k$ ç¨³å®š ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°äº†å‡ æ¬¡ ç»Ÿè®¡å®Œå‡ºç°æ¬¡æ•°ï¼Œæ±‚å‰ç¼€å’Œï¼Œå¯çŸ¥é“æ¯ä¸ªæ•°å­—åœ¨æ‹å®Œåºçš„ä½ç½®çš„èŒƒå›´ ä¿è¯ç¨³å®šæ€§ï¼Œå€’ç€ç¡®å®šåŸæœ¬æ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—æœ€åæ’åœ¨ä½çº§ä½\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[a[i]]; for(int i=1;i\u0026lt;=m;i++) for(int j=1;j\u0026lt;=c[i];j++) printf(\u0026#34;%d\u0026#34;,i); printf(\u0026#34;\\n\u0026#34;); for(int i=2;i\u0026lt;=m;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[i]=c[a[i]]--; for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d\u0026#34;,r[i]); printf(\u0026#34;\\n\u0026#34;); } åŸºæ•°æ’åº åŸºæ•°æ’åº å¤æ‚åº¦ $nk$ æ‹†åˆ†æˆ $m$ ä¸ªå…³é”®å­— ä»åå¾€å‰ ä¾æ¬¡å¯¹ $m$ ä¸ªå…³é”®å­—è¿›è¡Œæ’åº æ¯æ¬¡æ’åºä¼šä½¿ç”¨ä¸Šä¸€æ¬¡æ’åºçš„ç»“æœ ä¸€èˆ¬ä½¿ç”¨è®¡æ•°æ’åºæ¥å®Œæˆæ¯æ¬¡çš„æ’åº ä¾‹å¦‚å¯¹ä¸‰ä½æ•°æ’åº å…ˆæ’ä¸ªä½ å†æ’åä½ å†æ’ç™¾ä½ ç»å¸¸è¢«ç”¨äºå­—ç¬¦ä¸²çš„æ’åº åç¼€æ•°ç»„çš„æ ¸å¿ƒå°±æ˜¯åŸºæ•°æ’åº\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[v[i]]; for(int i=1;i\u0026lt;=9;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[sa[i]]=c[v[sa[i]]]--; for(int i=1;i\u0026lt;=n;i++) sa[r[i]]=i; } void radixsort(){ for(int i=1;i\u0026lt;=n;i++) sa[i]=i; int x=1; for(int i=1;i\u0026lt;=m;i++,x*=10){ for(int j=1;j\u0026lt;=n;j++){ v[j]=a[j]/x%10; } countingsort(); } } ","permalink":"http://localhost:1313/posts/study/easy-sort/","summary":"Educational Codeforces Round 164 (Rated for Div. 2) è¡¥é¢˜","title":"ç®€å•çš„æ’åº"}]