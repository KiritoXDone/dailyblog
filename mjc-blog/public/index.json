[{"content":"2024 河南萌新联赛 1 A 造数 给定整数 n，操作 1：+1，操作 2：+2，操作 3：x2，多少次将 0 转化到 n\n逆向思维，把 n 化为 0 即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 n 的数组 a，两种操作选一个进行一次或不操。\n显然将数组最大值 * n 后答案最大\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end()); int sum=0; for(int i=0;i\u0026lt;n;i++){ sum+=a[i]; } sum=max(sum+n,sum+(n-1)*a[n-1]); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } K 图上计数 构造的两块联通块即为最接近 n/2 的两块\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int n,m; signed main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } if(n\u0026lt;=1){ cout\u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; return 0; } cout\u0026lt;\u0026lt;(long long)n/2*(n-n/2)\u0026lt;\u0026lt;endl; } I 除法移位 a 中最大值位于第一位时即是答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t; vector\u0026lt;int\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; } int mx=0,ans=0; for(int i=1;i\u0026lt;=min(t,n);i++){ if(a[n-i+1]\u0026gt;mx){ mx=a[n-i+1]; ans=i%n; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } F 两难抉择新编 与 H 类似，但是操作范围随 i 改变而改变 O(n^3/2) 暴力过\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); int sum = 0, ans = 0; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n; i++) sum ^= a[i]; ans = sum; for (int i = 1; i \u0026lt;= n; i++) { for (int x = 1; x \u0026lt;= n / i; x++) { int t1 = sum ^ a[i] ^ (a[i] + x); int t2 = sum ^ a[i] ^ (a[i] * x); ans = max(ans, max(t1, t2)); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } G 旅途的终点 反悔贪心，前 k 个直接存入 set，后续的小于 set 内第一个元素就替换，否则就正常进行\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll __int128 int main(){ long long n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;long long\u0026gt;a(n+1); for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; multiset\u0026lt;ll\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ s.insert(a[i]); if(s.size()\u0026gt;k){ m-=*s.begin(); if(m\u0026lt;=0){ cout\u0026lt;\u0026lt;i-1\u0026lt;\u0026lt;endl; return 0; } s.erase(s.begin()); } } cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; return 0; } B 爱探险的朵拉 图中可能有环，那么就是要找包含环的最长链，或是无环的最长链\n记录每个点的入度，如果某个点的入度为 0，他们不会构成环，即可作为链起点，再依次对入度为 0 的点操作，找出他们能构成最长的链有多长。\n之后再以每个点为起点找答案，如果前面的过程标记过则跳过，没标记过说明这是环上点，用 dfs 找这个环加上前链有多长，并更新答案\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e5+10; int a[N],dis[N],cnt[N]; bool vis[N]; deque\u0026lt;int\u0026gt;q; int dfs(int x){ int sum=0,mx=0; for(int i=x;;i=a[i]){ if(vis[i])break; vis[i]=1; ++sum; mx=max(mx,dis[i]); } return mx+sum; } int main(){ int n,ans=0; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; cnt[a[i]]++; } for(int i=1;i\u0026lt;=n;i++) if(!cnt[i])q.push_back(i); while(!q.empty()){ int x=q.front(); q.pop_front(); vis[x]=1; dis[a[x]]=max(dis[a[x]],dis[x]+1); --cnt[a[x]]; if(!cnt[a[x]])q.push_back(a[x]); } for(int i=1;i\u0026lt;=n;i++){ if(vis[i])continue; int tmp=dfs(i); ans=max(ans,tmp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } C 有大家喜欢的零食吗 二分图匹配板子，之后学了补\nD 小蓝的二进制询问 显然是前缀和，那么重点就是如何计算前 x 个数的 1 的个数\n从最低位看起，只有 0，1，二者循环，再往上 1 位，仍然为 0，1 循环，显然每一位上的循环都是一样的，我们对每一位能出现的 1 进行计算，当前位数为 k 时，这一位上就会有 2^k 个 1 和 2^k 个 0.\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 998244353; ll sum(ll x,int y){ if(x==0) return 0; ll s=1LL\u0026lt;\u0026lt;y; ll cnt=x/s; ll ans=cnt*s/2; ll d=cnt*s+(1LL\u0026lt;\u0026lt;(y-1)); ll dd=x-d+1; if(dd\u0026gt;0) ans+=dd; return ans; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ ll ans=0,l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; for(int i=61;i\u0026gt;0;i--){ ll p=(sum(r,i)%MOD-sum(l-1,i)%MOD+MOD)%MOD; ans=(ans+p)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } J 最大矩阵匹配 将矩阵上下翻转后，变为固定左上一个点，向其他三个方向拓展的问题，用二维前缀和辅助判断三个点是否都为 1，来实现 DP 状态转移\n","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B1/","summary":"2024 河南萌新联赛 1 A 造数 给定整数 n，操作 1：+1，操作 2：+2，操作 3：x2，多少次将 0 转化到 n 逆向思维，把 n 化为 0 即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,cnt=0; cin\u0026gt;\u0026gt;n; while(n){ if(n\u0026amp;1)n--,cnt++; else if(n\u0026gt;2)cnt++,n/=2; else cnt++,n-=2; } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } H 两难抉择 长度为 n 的数组 a，两种操作选一个进行一次或不操。 显然将数组最大值 * n 后答案最大 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long signed main(){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;a(n); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end());","title":"2024萌新联赛1"},{"content":"Codeforces Round 962 还得练\nA Legs 先除 4 再除 2\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间他们不同的数量，更改差异数量除 2 (向上取整)，即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; int n, q; string a, b; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = \u0026#34; \u0026#34; + a; b = \u0026#34; \u0026#34; + b; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; va(26, vector\u0026lt;int\u0026gt;(n + 1, 0)), vb(26, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { va[x - \u0026#39;a\u0026#39;][i] = va[x - \u0026#39;a\u0026#39;][i - 1]; vb[x - \u0026#39;a\u0026#39;][i] = vb[x - \u0026#39;a\u0026#39;][i - 1]; } va[a[i] - \u0026#39;a\u0026#39;][i]++; vb[b[i] - \u0026#39;a\u0026#39;][i]++; } while (q--) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; long long ans = 0; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { ans += abs((va[x - \u0026#39;a\u0026#39;][r] - va[x - \u0026#39;a\u0026#39;][l - 1]) - (vb[x - \u0026#39;a\u0026#39;][r] - vb[x - \u0026#39;a\u0026#39;][l - 1])); } if(ans\u0026amp;1)ans++; ans/=2; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } D Fun 给定两个整数 n 和 x ，求 ab + ac + bc ≤ n 和 a + b + c ≤ x 的个正整数的三元组 (a, b, c) 的个数。 注意顺序问题(例如 (1, 1, 2) 和 (1, 2, 1) 被视为不同)， a ， b ， c 必须严格大于 0 。\n赛时只顾着研究这两个式子能否融合化简为一个式子，还是见题少了\n看第一个式子可知，a * b \u0026lt;= n, 所以 b 有 nlogn 个选择，可以循环 ab 求解\n再通过两个式子推得 c \u0026lt;= (n - ab) / (a + b)和 c \u0026lt;= x - a - b ,将范围小的加入答案即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; void solve(){ ll n,x,ans=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j*i\u0026lt;=n;j++){ ll mn=min((n-i*j)/(i+j),(x-i-j)); mn=max(mn,0); ans+=mn; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E Decode 赛时题都没弄太明白 每次找到符合区间会使答案加 l * (n - r + 1)\n用前缀和记录当前位置 1 0 出现次数，1 指代此处为 1，-1 指代此处为 0。然后逐位记录当前前缀和的大小，如果之前存过，那么就更新答案。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MOD = 1e9 + 7; void solve(){ string s; cin\u0026gt;\u0026gt;s; int n=s.size(); s=\u0026#34; \u0026#34;+s; vector\u0026lt;ll\u0026gt;pre(n+1,0); for(int i=1;i\u0026lt;=n;i++){ pre[i]=(s[i]==\u0026#39;1\u0026#39;?1:-1)+pre[i-1]; } map\u0026lt;int,ll\u0026gt;cnt; cnt[0]=1; ll ans=0; for(int i=1;i\u0026lt;=n;i++){ ans=(ans+cnt[pre[i]]*(n-i+1)*1LL%MOD)%MOD; cnt[pre[i]]=(cnt[pre[i]]+i+1)%MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/cf962/","summary":"Codeforces Round 962 还得练 A Legs 先除 4 再除 2 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; int cnt=n/4; if(n%4!=0)cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } B Scale 按题意合理间隔输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N =1010; char mp[N][N]; void solve(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; for(int i=1;i\u0026lt;=n;i+=k){ for(int j=1;j\u0026lt;=n;j+=k) cout\u0026lt;\u0026lt;mp[i][j]; cout\u0026lt;\u0026lt;endl; } } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间他们不同的数量，更改差异数量除 2 (向上取整)，即可 #include \u0026lt;bits/stdc++.h\u0026gt;","title":"CF962"},{"content":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确\n类似有向无环图，由一个状态转移到下一个状态\n对先手来说，存在两种状态，即必胜态和必败态\n必胜态 当前状态的后续为必败态，当前状态即为必胜态\n必败态 不存在后续，或是所有后续都必胜\nDP 解决博弈 利用状态转移的关系，来解决简单的博弈问题\n移棋子问题 n * m 的棋盘，(1,1) 在左上角，(n,m) 在右下角，每格标明黑白两色\n上面有一个棋子，Alice 和 Bob 轮流移动这个棋子，Alice 先手移动，每次可以向上或向左移动一格，一旦移动到第一行或第一列游戏结束，执行最后一步移动的人，如果将棋子移动到黑格，就获胜，反之，则失败。\n现在给这个棋子的起始位置，问最后获胜的玩家是谁，对于所有的 (i,j) 满足 2\u0026lt;=i,j\u0026lt;=n 输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN][MAXN],n,m; string a,b; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=0;i\u0026lt;=m-2;i++){ dp[1][i+2]=(a[i]==\u0026#39;W\u0026#39;); } for(int i=0;i\u0026lt;=n-2;i++){ dp[i+2][1]=(b[i]==\u0026#39;W\u0026#39;); } for(int i=2;i\u0026lt;=n;i++){ for(int j=2;j\u0026lt;=m;j++){ dp[i][j]=!(dp[i-1][j]\u0026amp;\u0026amp;dp[i][j-1]); if(dp[i][j])cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;B\u0026#34;; } puts(\u0026#34;\u0026#34;); } } 取石子游戏 有一堆石子，大小为 x，Alice 和 Bob 轮流操作，Alice 先手，Alice 每次可以取 a[i] 个石子，Bob 可以取 b[i] 个，谁不能操作就输。\n问谁能获胜，对 x = 1 ~ m 都输出\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n1, n2, m, a[N], b[N], A[N], B[N]; int main(){ cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n1; i++){ cin \u0026gt;\u0026gt; a[i]; } for (int i = 1; i \u0026lt;= n2; i++){ cin \u0026gt;\u0026gt; b[i]; } for (int i = 1; i \u0026lt;= m; i++){ for (int j = 1; j \u0026lt;= n1; j++){ if(i \u0026gt;= a[j] \u0026amp;\u0026amp; B[i-a[j]] == 0){ A[i] = 1; break; } } for (int j = 1; j \u0026lt;= n2; j++){ if(i \u0026gt;= b[j] \u0026amp;\u0026amp; A[i-b[j]] == 0){ B[i] = 1; break; } } puts(A[i] ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); } return 0; } 带和局的情况 存在先手必败，胜\n存在和，和\n败\n经典模型 巴什博弈 有 n 个石子，每次取 1~m 个，Alice 先取，谁取最后一颗谁胜\nn % (m + 1) = 0, 先手必败\nn % (m + 1) != 0, 先手必胜\n威佐夫博弈 有两堆石子，分别有 a, b 颗，每次可以选一堆取 x 个，也可以选两堆都取 x 个\n所以 (a, b)有三种转移，(a-x, b), (a, b-x), (a-x, b-x);\n打表找规律\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 首先发现 (a, b) 和 (b, a), 状态相同，即同为必败态或必胜态\n再对 a \u0026lt; b 的情况分析，发现 a 是从 1 到 n 的，b - a 逐渐递增，依次为 1 2 3 4 5 \u0026hellip;\nNim 模型 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流取，Alice 先取，每次可以从选一堆任取 x 个石子， 可以拿光，但不能不拿，谁最后把所有的拿光谁获胜\n先打表\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int dp[N][N]; int main(){ for (int i = 0; i \u0026lt;= 100; i++){ for (int j = 0; j \u0026lt;= 100; j++){ for (int x = 1; x \u0026lt;= i; x++) if (dp[i - x][j] == 0) dp[i][j] = 1; for (int x = 1; x \u0026lt;= j; x++) if (dp[i][j - x] == 0) dp[i][j] = 1; // for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) // if (dp[i - x][j - x] == 0) dp[i][j] = 1; if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); } } return 0; } 发现 i == j，经推广更多维，可以总结出必败态：A1^A2^A3^\u0026hellip;^An = 0\n要证明此结论，可从三个定理入手\n1：没有后续状态的状态是必败态\n2：对于 A1^A2^A3^\u0026hellip;^An != 0 的局面一定存在某种移动使 A1^A2^A3^\u0026hellip;^An = 0\n3：对于 A1^A2^A3^\u0026hellip;^An = 0，不存在一种移动使 A1^A2^A3^\u0026hellip;^An = 0\n例题练习 石子游戏 2 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，每次可以把一堆个数为奇数的石子分为两堆，两堆都不能为空，或把两堆为偶数的石子和为一堆\n可以注意到两种操作都是对堆数改变，那么堆数的奇偶性就是突破点，同时根据操作的实质，可以发现只有 1 个石子的堆是无法继续操作的，最后石堆将变成全是 1 或者 1 个偶数剩下的全是 1\n所以结论就是：如果石堆全是 1，则先手必败，如果不是全为 1 那么就检测结束时堆数的奇偶性是否改变\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, odd, one; int x; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1;i \u0026lt;= n; i++){ cin \u0026gt;\u0026gt; x; if (x % 2 == 1) odd++; if (x == 1) one++; } if (one != n) odd++; if ((odd + n) % 2 != 0)cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#34;; return 0; } 石子游戏 3 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，选择 n/2 堆非空石子，每堆移除掉正数个(可以不同)的石子，从 Alice 开始。\n倒推：\n必败：超过 n/2 个堆已经为 0 必胜：有 1 ~ n/2 个堆为 0\n必败：有 \u0026gt; n/2 个堆石子数量为 1\n必胜：有 1 ~ n/2 个堆的数量为 1\n必败：有 \u0026gt; n/2 个堆的数量为 2\n\u0026hellip;\u0026hellip;\n有大于 n/2 个堆的数量 = min，必败\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 10010; int n, mx = 1e9, cnt; int main(){ cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if (x \u0026lt; mx) mx = x, cnt = 0; if (x == mx) cnt++; } if (cnt \u0026gt; n/2) cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E5%8D%9A%E5%BC%88%E8%AE%BA/","summary":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确 类似有向无环图，由一个状态转移到下一个状态 对先手来说，存在两种状态，即必胜态和必败态 必胜态 当前状态的后续为必败态，当前状态即为必胜态 必败态 不存在后续，或是所有后续都必胜 DP 解决博弈 利用状态转移的关系，来解决简单的博弈问题 移棋子问题 n","title":"博弈论"},{"content":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把\nI 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;\u0026#34;DHY\\n\u0026#34;; } } A 国际旅行 I 认真读题可得知，恒为联通图，排序所有国家即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n,m,q,k; vector\u0026lt;int\u0026gt;a(N); map\u0026lt;int,int\u0026gt;vis; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; } sort(a.begin()+1,a.begin()+1+n); while(q--){ cin\u0026gt;\u0026gt;k; cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; } } J 这是签到 矩阵计算板\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,m; int a[6][6]; int cal(int n, int a[6][6]) { if (n == 1) return a[0][0]; int res = 0; int sub[6][6]; for (int x = 0; x \u0026lt; n; x++) { int subi = 0; for (int i = 1; i \u0026lt; n; i++) { int subj = 0; for (int j = 0; j \u0026lt; n; j++) { if (j == x) continue; sub[subi][subj] = a[i][j]; subj++; } subi++; } res += (x % 2 == 0 ? 1 : -1) * a[0][x] * cal(n - 1, sub); } return res; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) cin \u0026gt;\u0026gt; a[i][j]; int ans = INT_MAX; int u=min(n,m); for(int i=1;i\u0026lt;=u;i++){ ans=min(ans,cal(i,a)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H 狼狼的备忘录 STL 大法好\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, cnt, m; string s; map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; note; map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; vis; set\u0026lt;string\u0026gt; peo; void erase(string \u0026amp;a, string \u0026amp;b) { if (a == b) { b = \u0026#34;\u0026#34;; return; } if (a.size() \u0026gt; b.size() \u0026amp;\u0026amp; a.substr(a.size() - b.size()) == b) { b = \u0026#34;\u0026#34;; } } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; cnt; peo.insert(s); for (int j = 1; j \u0026lt;= cnt; j++) { string t; cin \u0026gt;\u0026gt; t; if (!vis[s][t]) note[s].push_back(t); vis[s][t]++; } } for (auto x : peo) { int m = note[x].size(); for (int i = 0; i \u0026lt; m; i++) { for (int j = i + 1; j \u0026lt; m; j++) { erase(note[x][i], note[x][j]); erase(note[x][j], note[x][i]); } } sort(note[x].begin(), note[x].end()); note[x].erase(remove(note[x].begin(), note[x].end(), \u0026#34;\u0026#34;), note[x].end()); } cout \u0026lt;\u0026lt; peo.size() \u0026lt;\u0026lt; endl; for (auto x : peo) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; note[x].size(); for (auto s : note[x]) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s; } cout \u0026lt;\u0026lt; endl; } return 0; } D A*BBBB 高精度 根据题意可知 是同一个结果往前移 b.size() 次相加 赛时笨比没调出来 python 引入 demical 库过的\n赛时代码\nfrom decimal import * import sys t=int(input()) for i in range(t): setcontext(Context(prec=2000000, Emax=2000000, Emin=0)) print((Decimal(sys.stdin.readline())*Decimal(sys.stdin.readline()))) 正解\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e7+10; typedef long long ll; int a[N],sum[N],ans[N\u0026lt;\u0026lt;1]; string A,B; void solve(){ cin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B; int la=A.length(),lb=B.length(),b=B[0]-\u0026#39;0\u0026#39;; ll last=0; a[la+1]=0; for(int i=1;i\u0026lt;=la;i++){ a[i]=(A[la-i]-\u0026#39;0\u0026#39;)*b+last; last=a[i]/10; a[i]*=10; sum[i]=sum[i-1]+a[i]; } sum[la+1]=sum[la]+last; last=0; for(int i=1;i\u0026lt;=la+lb;i++){ int l=min(i,la+1),r=max(0,i-lb); ans[i]=sum[l]-sum[r]+last; last=ans[i]/10; ans[i]%=10; } bool flag=0; for(int i=la+lb;i\u0026gt;=1;--i) { if(!ans[i]) { if(flag) printf(\u0026#34;%d\u0026#34;,ans[i]); } else { flag=1; printf(\u0026#34;%d\u0026#34;,ans[i]); } } if(!flag) printf(\u0026#34;0\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } E \u0026ldquo;好\u0026quot;字符 观察得到 a，b 同一字符所处位置相邻差值构成的一个循环同构如果相同，就符合题意\n那么就对 26 个字符各跑一次 找到位置 存入字符串 找到该串的最小表示 比较即可\n需要注意将原 a，b 再复制本身一遍 因为这样才能保证找的最小表示没有缺少\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp(int nxt[], string a) { int n = a.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; n; i++) { while (j \u0026amp;\u0026amp; a[i] != a[j]) j = nxt[j - 1]; if (a[i] == a[j]) j++; nxt[i] = j; } return n - nxt[n - 1]; } string getmin(string s, int n) { s = s + s; int i = 0, j = 1; while (j \u0026lt; n) { int k = 0; while (k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) ++k; if (s[i + k] \u0026gt; s[j + k]) i += k + 1; else j += k + 1; if (i == j) j++; if (i \u0026gt; j) swap(i, j); } string t = s.substr(i, n); return t; } int main() { int n; string a, b; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a = a + a; b = b + b; map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; va, vb; map\u0026lt;char, string\u0026gt; sa, sb; for (int i = 0; i \u0026lt; n * 2; i++) { va[a[i]].push_back(i); vb[b[i]].push_back(i); } int cnt = 0, nxt[2000010]; for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { if (va[x].size() != vb[x].size() || va[x].size() == 0 || vb[x].size() == 0) continue; for (int i = 1; i \u0026lt; va[x].size(); i++) { sa[x] += to_string(va[x][i] - va[x][i - 1]); } for (int i = 1; i \u0026lt; vb[x].size(); i++) { sb[x] += to_string(vb[x][i] - vb[x][i - 1]); } if (getmin(sa[x], kmp(nxt, sa[x])) == getmin(sb[x], kmp(nxt, sb[x]))) cnt++; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } C 小 w 和大 W 的对决 sg 暴力打表 发现 8 个为一个循环 最后两个交换位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int calc(int x){ if(x%8==0)return x-1; if(x%8==7)return x+1; else return x; } int ans; int main(){ int n,x; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; ans^=calc(x); } if(ans==0)cout\u0026lt;\u0026lt;\u0026#34;W win\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;w win\\n\u0026#34;; } G lxy 的通风报信 因为数据不大，直接 bfs 跑每个点对其他点的距离，再求最小生成树即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; struct Node{ int x,y,id; }b[N]; int n,m,ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},tot,dis[N][N],a[N][N]; bool vis[N]; deque\u0026lt;Node\u0026gt;q; void bfs(int id){ q.clear(); q.push_back(Node{b[id].x,b[id].y,0}); dis[b[id].x][b[id].y]=0; while(!q.empty()){ Node now=q.front(); q.pop_front(); for(int i=0;i\u0026lt;4;i++){ int x=now.x+dx[i],y=now.y+dy[i]; if(x\u0026lt;1||y\u0026lt;1||x\u0026gt;n||y\u0026gt;m||a[x][y]==-1)continue; if(dis[x][y]\u0026gt;now.id+1){ dis[x][y]=now.id+1; q.push_back(Node{x,y,dis[x][y]}); } } } } void solve(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ dis[i][j]=1e9; char x; cin\u0026gt;\u0026gt;x; if(x==\u0026#39;.\u0026#39;)a[i][j]=0; else if(x==\u0026#39;#\u0026#39;)a[i][j]=-1; else { a[i][j]=++tot; b[tot]=Node{i,j,tot}; } } } dis[b[1].x][b[1].y]=0; for(int i=1;i\u0026lt;=tot;i++){ int mi=1e9,id=0; for(int j=1;j\u0026lt;=tot;++j){ if(vis[j])continue; if(mi\u0026gt;dis[b[j].x][b[j].y])mi=dis[b[j].x][b[j].y],id=j; } if(!id){ puts(\u0026#34;No\u0026#34;); return; } vis[id]=1; ans+=mi; if(i!=tot)bfs(id); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main(){ int t=1; // cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B2/","summary":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把 I 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; string s; cin \u0026gt;\u0026gt; s; int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; while (pos != string::npos) { cnt++; pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可 #include \u0026lt;bits/stdc++.h\u0026gt; using","title":"2024萌新联赛2"},{"content":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n)\n用两个指针 i,j, 分别指想目前两个可能是答案的起始位置\n初始 i = 1, j = 2, 随着算法进行增大\n假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同\n如果 s[i+k]!=s[j+k]\n谁大谁往后移动 k+1 个位置\n如果 s[i+k]==s[j+k]\n随便移动一个\n最后小于 n 的那个指针就是所求答案\nvoid getmin(string s){ int n=s.size(); s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) ++k; if(s[i+k]\u0026gt;s[j+k]) i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; } 例题 循环同构判断 给定两个字符串 a, b,判断两个字符串是否循环同构\n只需判断两个字符串最小表示是否一样即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a,b; int getmin(string s){ int n=s.size(); int i=0,j=1; s=s+s; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)++j; if(i\u0026gt;j)swap(i,j); } return i; } int main(){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; for(int i=getmin(a),j=getmin(b),k=0;k\u0026lt;n;k++){ if(a[(i+k)%n]!=b[(j+k)%n]){ cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; return 0; } } cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; } 最小循环覆盖 给出字符串 a，求出这个字符串的字典序最小的最小循环覆盖\n先用 kmp 求出最小循环片段长度，再求这个长度的子串的最小表示\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string a; int nxt[100005]; int kmp(){ int n=a.size(); nxt[0]=0; int j=0; for(int i=1;i\u0026lt;n;i++){ while(j\u0026amp;\u0026amp;a[i]!=a[j]) j=nxt[j-1]; if(a[i]==a[j]) j++; nxt[i]=j; } return n-nxt[n-1]; } void getmin(string s,int n){ s=s+s; int i=0,j=1; while(j\u0026lt;n){ int k=0; while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; if(s[i+k]\u0026gt;s[j+k])i+=k+1; else j+=k+1; if(i==j)j++; if(i\u0026gt;j)swap(i,j); } for(int l=i;l\u0026lt;i+n;l++)cout\u0026lt;\u0026lt;s[l]; } int main(){ cin\u0026gt;\u0026gt;a; getmin(a,kmp()); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n) 用两个指针 i,j, 分别指想目前两个可能是答案的起始位置 初始 i = 1, j = 2, 随着算法进行增大 假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同 如果 s[i+k]!=s[j+k] 谁大谁往后移动 k+1 个位置 如果 s[i+k]==s[j+k] 随","title":"最小表示法"},{"content":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。\n签到，直接暴力\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分 输入: 1 s3://hdu-oj-bucket/problem=1/type=data/ 输出： s3 hdu-oj-bucket problem=1 type=data\n签到，按题意拆分字符串即可\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string s; cin\u0026gt;\u0026gt;s; int pos = s.find(\u0026#34;://\u0026#34;); cout\u0026lt;\u0026lt;s.substr(0,pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; pos+=3; int now = s.find(\u0026#34;/\u0026#34;,pos); cout\u0026lt;\u0026lt;s.substr(pos,now-pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; while(1){ pos=now+1; if(pos\u0026gt;=s.size())break; now = s.find(\u0026#34;/\u0026#34;,pos); string t = s.substr(pos,now-pos); int flag = t.find(\u0026#34;=\u0026#34;); if(flag!=-1)cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 鸡爪 给 n 条边，任意顶点，构造数量最多的鸡爪，同时保证输出每条边的两个顶点时，保证行优先遍历，字典序最小。\n鸡爪的定义：1 个顶点，和它所连的 3 条边，不包括其他顶点，不可重复利用。\n构造，易想出 n 条边，最多构造出 n/3 个鸡爪，多出的 1 或 2 个边，补到顶点1上即可。\n因为字典序最小，所以顶点 1 上连的边肯定最多，我们就让 1 连到所有的顶点上，这样其他所有构造鸡爪的顶点 n 都能用上 1-n 这条边。因此 1 自己用的边肯定是入度最小的几个顶点，即编号最大的顶点，类推到之后的顶点，都是先采用与其之前的顶点的边，再从最后面选。到顶点 4 开始，不再需要往后采用，因为前面有 3 个顶点提供边，不再需要额外的顶点来提供边。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ int n; cin\u0026gt;\u0026gt;n; if(n\u0026gt;=3){ int now=0,cnt=n/3+3; for(int i=1;i\u0026lt;=min(n/3,3);i++){ for(int j=i+1;j\u0026lt;=cnt-i+1;j++){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if(i==1\u0026amp;\u0026amp;j==cnt-i+1){ int now=j; while(n%3!=0){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;++now\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; n--; } } } } } else{ for(int i=2;i\u0026lt;=n+1;i++)cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 传奇勇士小凯 有⼀个 n 个结点的有根树，你需要从 1 号结点走到任意⼀个叶子节点，每天你有 p[i]/15 的可能性可以向任意⼀个儿子节点走⼀步（ i 为你当前所在的节点编号），询问你期望最多可以在这颗树上走多久\n期望计算，在某一节点停留的步数应该为 15/p[i] 。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e5+7; ll ans=0, LCM=360360; vector\u0026lt;int\u0026gt; nxt[N]; vector\u0026lt;int\u0026gt; p(N); ll gcd(int x,int y){ if(!x||!y)return x+y; return gcd(y,x%y); } void dfs(int u,int fa, ll sum) { sum += (LCM / p[u]); if(sum\u0026gt;ans)ans=sum; for (auto x : nxt[u]) { if(x==fa)continue; dfs(x, u, sum); } } void solve() { int n; cin \u0026gt;\u0026gt; n; ans=0; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; nxt[u].push_back(v); nxt[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; dfs(1, 0, 0); ll d=gcd(15*ans,LCM); printf(\u0026#34;%lld/%lld\\n\u0026#34;,15*ans/d,LCM/d); for (int i = 1; i \u0026lt;= n; i++) nxt[i].clear(); } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) solve(); return 0; } 绝对不模拟的简单魔方 1)暴力，从初始状态开始模拟，每次对比当前状态和给出状态，若相同或不同点仅两个，即得到答案\n2)将魔方视为 2 阶的，预处理得到 24 种可能状态，与给出状态对比，至多有一个角不同，即为答案。\n之后补... 在 A 里面找有 C 的 B AC自动机（还不会，之后补\u0026hellip;.\n","permalink":"https://KiritoXDone.github.io/posts/study/2024hdu2/","summary":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。 签到，直接暴力 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void solve(){ string t,s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,int\u0026gt;vis; for(int i=0;i\u0026lt;8;i++){ if(i%2!=1)t+=s[i]; vis[s[i]]++; } s=t; t=\u0026#34;\u0026#34;; for(int i=0;i\u0026lt;4;i++){ if(i%2!=1)t+=s[i]; } if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; else cout\u0026lt;\u0026lt;t[1]; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ int t=1; cin\u0026gt;\u0026gt;t; while(t--)solve(); return 0; } 1007 URL 划分 输入","title":"2024HDU2"},{"content":"Manacher 理念学习 解决最长回文子串问题\n给出一个任意字符串，求出这个字符串中最长的回文子串\n正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可\n对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文子串的长度，记做 p[i] (包括 i 本身，所以最小为 1)\n维护 p[i] 的值：\n维护一个到目前位置的R最大的区间 [L, R]，其中 L = M - p[M] + 1 (M \u0026lt; i) R = M + p[M] - 1\n[L, R] 是一个回文串 如果i \u0026lt;= R:\n找到 i 对于 M 的对称点 k，此时 i - M = M - k,k = 2 * M - i; 此时有两种情况：\n(1)如果 p[k] 对应的回文区间 [k - p[k] + 1, k + p[k] - 1]，不含左端点 L，说明这个回文区间在 [L, R] 之中，此时我们可以得到 p[i] = p[k]\n(2)如果包含了左端点L，此时 [L, 2k-L] 这一端为回文串。由于 [L, R] 是回文串，可得出 [2i-R, R] 也是回文串。往两端暴力拓展即可。 如果 i \u0026gt; R：\n暴力两端拓展即可 都要记得更新 M, L, R 的值。\nvoid manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } 洛谷例题 P3805\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; int n,p[2*N]; string s,t; void manacher(){ n=s.size(); t.resize(2*n+10); int m=0; t[0]=\u0026#39;$\u0026#39;; for(int i=0;i\u0026lt;n;i++){ t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; } int M=0,R=0; for(int i=0;i\u0026lt;m;i++){ if(i\u0026gt;R) p[i]=1; else p[i]=min(p[2*M-i],R-i+1); while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) ++p[i]; if(i+p[i]-1\u0026gt;R) M=i,R=i+p[i]-1; } int ans=0; for(int i=0;i\u0026lt;=m;i++){ ans=max(ans,p[i]); } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s; manacher(); return 0; } 坑点：字符串 t 要 resize，不然 re\n","permalink":"https://KiritoXDone.github.io/posts/study/manacher/","summary":"Manacher 理念学习 解决最长回文子串问题 给出一个任意字符串，求出这个字符串中最长的回文子串 正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可 对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文","title":"Manacher"},{"content":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点\nkmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1\n简化版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){ while(j==m||(j\u0026amp;\u0026amp;s[i]!=p[j])) j=nxt[j-1]; if(s[i]==p[j]) j++; f[i]=j; } for(int i=0;i\u0026lt;n;i++){ if(f[i]==m)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 寻找最小循环子串 字符串 s 是由某个子串重复连接而成的，寻找构成 s 的最小子串的长度\n答案其实就是 n - nxt[n]\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],n,m; void kmp(){y m=p.size(); int j=0; nxt[0]=0; p=p; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } cout\u0026lt;\u0026lt;m-nxt[m-1]\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;p; kmp(); return 0; } Secret word 给出字符串 s，寻找最长字符串 p，p 满足（是 s 的子串，翻转后是 s 的前缀）\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int nxt[200001],n; void kmp(){ n=s.size(); int j=0; nxt[0]=0; string t=s; reverse(t.begin(),t.end()); s=s+\u0026#34;#\u0026#34;+t; for(int i=1;i\u0026lt;n*2+1;i++){ while(j\u0026amp;\u0026amp;s[i]!=s[j]) j=nxt[j-1]; if(s[i]==s[j]) j++; nxt[i]=j; } int ans=-1; for(int i=n;i\u0026lt;2*n+1;i++){ ans=max(ans,nxt[i]); } for(int i=ans-1;i\u0026gt;=0;i--)cout\u0026lt;\u0026lt;s[i]; } int main(){ cin\u0026gt;\u0026gt;s; kmp(); return 0; } exkmp 洛谷 P5410\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 2e7+10; typedef long long ll; string s,p; ll z[N*2],n,m; void exkmp(string s,string p){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; ll L=0,R=-1; z[0]=m; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ ll k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } ll ans=0; for(int i=0;i\u0026lt;m;i++)ans^=(1LL*(i+1)*(z[i]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; ans=0; for(int i=0;i\u0026lt;n;i++)ans^=(1LL*(i+1)*(z[i+m+1]+1)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(s,p); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/0721/","summary":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点 kmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1 简化版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; p=p+\u0026#34;#\u0026#34;+s; for(int i=1;i\u0026lt;m+n+1;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } for(int i=m+1;i\u0026lt;n+m+1;i++){ if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; } } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; kmp(); return 0; } 常规版 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int nxt[100001],f[100001],n,m; void kmp(){ n=s.size(); m=p.size(); int j=0; nxt[0]=0; for(int i=1;i\u0026lt;m;i++){ while(j\u0026amp;\u0026amp;p[i]!=p[j]) j=nxt[j-1]; if(p[i]==p[j]) j++; nxt[i]=j; } j=0; for(int i=0;i\u0026lt;n;i++){","title":"0721"},{"content":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现\n暴力匹配 O(nm)\n哈希优化 O(n+m)\nKMP 线性复杂度解决 O(n+m)\nKMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同\nf[i] 对应j的位置，j对应p中的位置\n如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位\n否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k 最大的位\n如果 s[i + 1] 仍不等于 p[j + 1]，不停向前回退，直到相等或 j = 0\n快速求出 k\n易得到求 k 与 s 无关\n最大的 k 满足 k \u0026lt; j,使得 p[1]..p[k] 和 p[j - k + 1]\u0026hellip;p[j] 完全相同\n可以用 next 维护每个 j 对应的 k\nvoid kmp(){ n=s.size()+1,m=p.size()+1;//字符串下标从 1 开始 int j=0; nxt[1]=0; for(int i=2;i\u0026lt;=m;i++){ while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) j=nxt[j]; if(p[j+1]==p[i]) j++; nxt[i]=j; } j=0; for(int i=1;i\u0026lt;=n;i++){ while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) j=nxt[j]; if(p[j+1]==s[i]) j++; f[i]=j; } } 洛谷例题 P3375\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6+10; int n, m; string s, p; int nxt[N], f[N]; void kmp() { n = s.size(); m = p.size(); nxt[0] = 0; int j = 0; for (int i = 1; i \u0026lt; m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j]) j = nxt[j - 1]; if (p[i] == p[j]) j++; nxt[i] = j; } j = 0; for (int i = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j]) j = nxt[j - 1]; if (s[i] == p[j]) j++; f[i] = j; if (j == m) { cout \u0026lt;\u0026lt; i - m + 2 \u0026lt;\u0026lt; endl; j = nxt[j - 1]; } } for (int i = 0; i \u0026lt; m; i++) { cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; kmp(); return 0; } EXKMP(Z-algorithm) 理论学习 线性时间复杂度求出字符串s和他的任意后缀 s[i]\u0026hellip;s[n] 的最长公共前缀的长度 O(n)\n与 kmp 的区别：一个是到 s[i] 结束，一个是从 s[i] 开始\n定义 z[1] = 0，从 2 到 n 枚举 i，依次计算 z[i] 的值\n计算 z[i] 时，前面的 z 都已经计算好了\n对于 j，有 s[j]\u0026hellip;s[j + z[j] - 1] 和 s[1]\u0026hellip;s[z[j]] 完全相等\n为了计算 z[i]，在枚举i的过程中，需要维护R的最大区间 [L, R],其中 L = j，R =j + z[i] - 1\n初始时 L = 1,R = 0\n如果 i \u0026lt;= R:\n易知 s[L]\u0026hellip;s[R] = s[1]\u0026hellip;s[R - L + 1]\n令 k = i - L + 1,i 与 k 的位置对应，此时s[i]..s[R] = s[k]..s[R - L + 1]\n如果 z[k] \u0026lt; R - i + 1，说明从 k 开始匹配不到那么远，也就是从 i 开始匹配不到 R，此时 z[i] = z[k]\n反之，说明可以匹配到 R 那么远，从 R+1 开始往后暴力\n如果 i \u0026gt; R:\n暴力枚举匹配，记得更新 L 和 R\nvoid exkmp(){ int L=1,R=0; z[1]=0; for(int i=2;i\u0026lt;=2;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L+1; z[i]=min(z[k],R-i+1); } while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]=1; } } 例题 给出字符串 s, p,求 s 中 p 出现的次数和位置\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s,p; int z[200001],n,m; void exkmp(){ n=s.size(); m=p.size(); p=p+\u0026#34;#\u0026#34;+s; int L=0,R=-1; z[0]=0; for(int i=1;i\u0026lt;n+m+1;i++){ if(i\u0026gt;R) z[i]=0; else{ int k=i-L; z[i]=min(z[k],R-i); } while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) ++z[i]; if(i+z[i]-1\u0026gt;R) L=i,R=i+z[i]-1; } int ans=0; for(int i=m+1;i\u0026lt;m+n+1;i++) if(z[i]==m)ans++; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; for(int i=m+1;i\u0026lt;n+m+1;i++) if(z[i]==m)cout\u0026lt;\u0026lt;i-m\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; exkmp(); return 0; } ","permalink":"https://KiritoXDone.github.io/posts/study/kmp/","summary":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现 暴力匹配 O(nm) 哈希优化 O(n+m) KMP 线性复杂度解决 O(n+m) KMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同 f[i] 对应j的位置，j对应p中的位置 如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位 否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k","title":"KMP"},{"content":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取\n排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素\n将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放\n确定 x 的位置后，对两侧继续递归\nvoid quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand() % (r - l + 1)]); // 保证 x 随机取 int x = a[l]; int i = l, j = r; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt; x) // 不能写成 a[j] \u0026gt;= x j--; if (i \u0026lt; j) a[i++] = a[j]; while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt; x) // 不能写成 a[i] \u0026lt;= x i++; if (i \u0026lt; j) a[j--] = a[i]; } a[i] = x; quicksort(l, i - 1); // 不能递归 i quicksort(i + 1, r); } //另一种写法\nvoid Quicksort(int l, int r){ if(l\u0026gt;=r)return; int b[100001],c[100001]; int x=a[l+rand()\u0026amp;(r-l+1)]; int l1=0,l2=0,y=0; for(int i=l;i\u0026lt;=r;i++){ if(a[i]\u0026lt;x) b[++l1]=a[i]; else if(a[i]\u0026gt;x) c[++l2]=a[i]; else ++y; } for(int i=1;i\u0026lt;=l1;i++) a[l+i-1]=b[i]; for(int i=1;i\u0026lt;=y;i++) a[l+l1+i-1]=x; for(int i=1;i\u0026lt;=l2;i++) a[l+l1+y+i-1]=c[i]; Quicksort(l,l+l1-1); Quicksort(l+l1+y,r); } 归并排序 归并排序 分治 复杂度 nlogn 且稳定 要排序 [l, r]，长度为1直接退出，否则分为 [l, m],[m+1, r]; 递归两个子区间进行归并排序 将排序好的子区间合并\nvoid mergesort(int l,int r){ if(l==r)return; int m=(l+r)/2; mergesort(l,m); mergesort(m+1,r); int p1=l,p2=m+1,tot=0; while(p1\u0026lt;=m\u0026amp;\u0026amp;p2\u0026lt;=r){ if(a[p1]\u0026lt;=a[p2]) c[++tot]==a[p1++]; else c[++tot]=a[p2++]; } while(p1\u0026lt;=m) c[++tot]=a[p1++]; while(p2\u0026lt;=m) c[++tot]=a[p2++]; for(int i=1;i\u0026lt;=tot;i++) a[i+l-1]=c[i]; } 计数排序 计数排序 适合值域范围较小 复杂度 n+k 稳定 统计每个数字出现了几次 统计完出现次数，求前缀和，可知道每个数字在拍完序的位置的范围 保证稳定性，倒着确定原本每个位置上的数字最后排在低级位\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[a[i]]; for(int i=1;i\u0026lt;=m;i++) for(int j=1;j\u0026lt;=c[i];j++) printf(\u0026#34;%d\u0026#34;,i); printf(\u0026#34;\\n\u0026#34;); for(int i=2;i\u0026lt;=m;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[i]=c[a[i]]--; for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d\u0026#34;,r[i]); printf(\u0026#34;\\n\u0026#34;); } 基数排序 基数排序 复杂度 nk 拆分成 m 个关键字 从后往前 依次对 m 个关键字进行排序 每次排序会使用上一次排序的结果 一般使用计数排序来完成每次的排序 例如对三位数排序 先排个位 再排十位 再排百位 经常被用于字符串的排序 后缀数组的核心就是基数排序\nvoid countingsort(){ memset(c,0,sizeof(c)); for(int i=1;i\u0026lt;=n;i++) ++c[v[i]]; for(int i=1;i\u0026lt;=9;i++) c[i]+=c[i-1]; for(int i=n;i;i--) r[sa[i]]=c[v[sa[i]]]--; for(int i=1;i\u0026lt;=n;i++) sa[r[i]]=i; } void radixsort(){ for(int i=1;i\u0026lt;=n;i++) sa[i]=i; int x=1; for(int i=1;i\u0026lt;=m;i++,x*=10){ for(int j=1;j\u0026lt;=n;j++){ v[j]=a[j]/x%10; } countingsort(); } } ","permalink":"https://KiritoXDone.github.io/posts/study/easy-sort/","summary":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取 排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素 将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放 确定 x 的位置后，对两侧继续递归 void quicksort(int l, int r) { if (l \u0026gt;= r) return; // 长度小于 1，直接退出 swap(a[l], a[l + rand() % (r - l +","title":"简单的排序"}]