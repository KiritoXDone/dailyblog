[{"content":"Codeforces Round 962 还得练\nA Legs 先除 4 再除 2\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5\tint n; 6\tcin\u0026gt;\u0026gt;n; 7\tint cnt=n/4; 8\tif(n%4!=0)cnt++; 9\tcout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; 10} 11 12int main(){ 13\tint t; 14\tcin\u0026gt;\u0026gt;t; 15\twhile(t--)solve(); 16\treturn 0; 17} B Scale 按题意合理间隔输出即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N =1010; 4 5char mp[N][N]; 6 7void solve(){ 8\tint n,k; 9\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; 10\tfor(int i=1;i\u0026lt;=n;i++) 11\tfor(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; 12\tfor(int i=1;i\u0026lt;=n;i+=k){ 13\tfor(int j=1;j\u0026lt;=n;j+=k) 14\tcout\u0026lt;\u0026lt;mp[i][j]; 15\tcout\u0026lt;\u0026lt;endl; 16\t} 17} 18 19int main(){ 20\tint t; 21\tcin\u0026gt;\u0026gt;t; 22\twhile(t--)solve(); 23\treturn 0; 24} C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间他们不同的数量，更改差异数量除 2 (向上取整)，即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 1010; 4 5int n, q; 6string a, b; 7 8void solve() { 9 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; 10 cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 11 a = \u0026#34; \u0026#34; + a; 12 b = \u0026#34; \u0026#34; + b; 13 14 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; va(26, vector\u0026lt;int\u0026gt;(n + 1, 0)), vb(26, vector\u0026lt;int\u0026gt;(n + 1, 0)); 15 16 for (int i = 1; i \u0026lt;= n; i++) { 17 for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { 18 va[x - \u0026#39;a\u0026#39;][i] = va[x - \u0026#39;a\u0026#39;][i - 1]; 19 vb[x - \u0026#39;a\u0026#39;][i] = vb[x - \u0026#39;a\u0026#39;][i - 1]; 20 } 21 va[a[i] - \u0026#39;a\u0026#39;][i]++; 22 vb[b[i] - \u0026#39;a\u0026#39;][i]++; 23 } 24 25 while (q--) { 26 int l, r; 27 cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; 28 long long ans = 0; 29 for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { 30 ans += abs((va[x - \u0026#39;a\u0026#39;][r] - va[x - \u0026#39;a\u0026#39;][l - 1]) - (vb[x - \u0026#39;a\u0026#39;][r] - vb[x - \u0026#39;a\u0026#39;][l - 1])); 31 } 32\tif(ans\u0026amp;1)ans++; 33\tans/=2; 34 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; 35 } 36} 37 38int main() { 39 int t; 40 cin \u0026gt;\u0026gt; t; 41 while (t--) solve(); 42 return 0; 43} D Fun 给定两个整数 n 和 x ，求 ab + ac + bc ≤ n 和 a + b + c ≤ x 的个正整数的三元组 (a, b, c) 的个数。 注意顺序问题(例如 (1, 1, 2) 和 (1, 2, 1) 被视为不同)， a ， b ， c 必须严格大于 0 。\n赛时只顾着研究这两个式子能否融合化简为一个式子，还是见题少了\n看第一个式子可知，a * b \u0026lt;= n, 所以 b 有 nlogn 个选择，可以循环 ab 求解\n再通过两个式子推得 c \u0026lt;= (n - ab) / (a + b)和 c \u0026lt;= x - a - b ,将范围小的加入答案即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4 5void solve(){ 6 ll n,x,ans=0; 7 cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; 8 for(int i=1;i\u0026lt;=n;i++){ 9 for(int j=1;j*i\u0026lt;=n;j++){ 10 ll mn=min((n-i*j)/(i+j),(x-i-j)); 11 mn=max(mn,0); 12 ans+=mn; 13 } 14 } 15 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 16} 17 18int main() { 19 int t; 20 cin\u0026gt;\u0026gt;t; 21 while(t--)solve(); 22 return 0; 23} E Decode 赛时题都没弄太明白 每次找到符合区间会使答案加 l * (n - r + 1)\n用前缀和记录当前位置 1 0 出现次数，1 指代此处为 1，-1 指代此处为 0。然后逐位记录当前前缀和的大小，如果之前存过，那么就更新答案。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4const int MOD = 1e9 + 7; 5 6void solve(){ 7 string s; 8 cin\u0026gt;\u0026gt;s; 9 int n=s.size(); 10 s=\u0026#34; \u0026#34;+s; 11 vector\u0026lt;ll\u0026gt;pre(n+1,0); 12 for(int i=1;i\u0026lt;=n;i++){ 13 pre[i]=(s[i]==\u0026#39;1\u0026#39;?1:-1)+pre[i-1]; 14 } 15 map\u0026lt;int,ll\u0026gt;cnt; 16 cnt[0]=1; 17 ll ans=0; 18 for(int i=1;i\u0026lt;=n;i++){ 19 ans=(ans+cnt[pre[i]]*(n-i+1)*1LL%MOD)%MOD; 20 cnt[pre[i]]=(cnt[pre[i]]+i+1)%MOD; 21 } 22 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 23} 24 25int main() { 26 int t; 27 cin\u0026gt;\u0026gt;t; 28 while(t--)solve(); 29 return 0; 30} ","permalink":"https://KiritoXDone.github.io/posts/study/cf962/","summary":"Codeforces Round 962 还得练 A Legs 先除 4 再除 2 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5 int n; 6 cin\u0026gt;\u0026gt;n; 7 int cnt=n/4; 8 if(n%4!=0)cnt++; 9 cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; 10} 11 12int main(){ 13 int t; 14 cin\u0026gt;\u0026gt;t; 15 while(t--)solve(); 16 return 0; 17} B Scale 按题意合理间隔输出即可 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N =1010; 4 5char mp[N][N]; 6 7void solve(){ 8 int n,k; 9 cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; 10 for(int i=1;i\u0026lt;=n;i++) 11 for(int j=1;j\u0026lt;=n;j++)cin\u0026gt;\u0026gt;mp[i][j]; 12 for(int i=1;i\u0026lt;=n;i+=k){ 13 for(int j=1;j\u0026lt;=n;j+=k) 14 cout\u0026lt;\u0026lt;mp[i][j]; 15 cout\u0026lt;\u0026lt;endl; 16 } 17} 18 19int main(){ 20 int t; 21 cin\u0026gt;\u0026gt;t; 22 while(t--)solve(); 23 return 0; 24} C Sort 对 a 到 z 这 26 个字符分别开前缀和，统计 l 到 r 之间","title":"CF962"},{"content":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确\n类似有向无环图，由一个状态转移到下一个状态\n对先手来说，存在两种状态，即必胜态和必败态\n必胜态 当前状态的后续为必败态，当前状态即为必胜态\n必败态 不存在后续，或是所有后续都必胜\nDP 解决博弈 利用状态转移的关系，来解决简单的博弈问题\n移棋子问题 n * m 的棋盘，(1,1) 在左上角，(n,m) 在右下角，每格标明黑白两色\n上面有一个棋子，Alice 和 Bob 轮流移动这个棋子，Alice 先手移动，每次可以向上或向左移动一格，一旦移动到第一行或第一列游戏结束，执行最后一步移动的人，如果将棋子移动到黑格，就获胜，反之，则失败。\n现在给这个棋子的起始位置，问最后获胜的玩家是谁，对于所有的 (i,j) 满足 2\u0026lt;=i,j\u0026lt;=n 输出\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int MAXN = 10010; 4 5int dp[MAXN][MAXN],n,m; 6string a,b; 7 8int main(){ 9 cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; 10 for(int i=0;i\u0026lt;=m-2;i++){ 11 dp[1][i+2]=(a[i]==\u0026#39;W\u0026#39;); 12 } 13 for(int i=0;i\u0026lt;=n-2;i++){ 14 dp[i+2][1]=(b[i]==\u0026#39;W\u0026#39;); 15 } 16 for(int i=2;i\u0026lt;=n;i++){ 17 for(int j=2;j\u0026lt;=m;j++){ 18 dp[i][j]=!(dp[i-1][j]\u0026amp;\u0026amp;dp[i][j-1]); 19 if(dp[i][j])cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;; 20 else cout\u0026lt;\u0026lt;\u0026#34;B\u0026#34;; 21 } 22 puts(\u0026#34;\u0026#34;); 23 } 24} 取石子游戏 有一堆石子，大小为 x，Alice 和 Bob 轮流操作，Alice 先手，Alice 每次可以取 a[i] 个石子，Bob 可以取 b[i] 个，谁不能操作就输。\n问谁能获胜，对 x = 1 ~ m 都输出\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 10010; 4 5int n1, n2, m, a[N], b[N], A[N], B[N]; 6 7int main(){ 8 cin \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2 \u0026gt;\u0026gt; m; 9 for (int i = 1; i \u0026lt;= n1; i++){ 10 cin \u0026gt;\u0026gt; a[i]; 11 } 12 for (int i = 1; i \u0026lt;= n2; i++){ 13 cin \u0026gt;\u0026gt; b[i]; 14 } 15 for (int i = 1; i \u0026lt;= m; i++){ 16 for (int j = 1; j \u0026lt;= n1; j++){ 17 if(i \u0026gt;= a[j] \u0026amp;\u0026amp; B[i-a[j]] == 0){ 18 A[i] = 1; 19 break; 20 } 21 } 22 for (int j = 1; j \u0026lt;= n2; j++){ 23 if(i \u0026gt;= b[j] \u0026amp;\u0026amp; A[i-b[j]] == 0){ 24 B[i] = 1; 25 break; 26 } 27 } 28 puts(A[i] ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); 29 } 30 return 0; 31} 带和局的情况 存在先手必败，胜\n存在和，和\n败\n经典模型 巴什博弈 有 n 个石子，每次取 1~m 个，Alice 先取，谁取最后一颗谁胜\nn % (m + 1) = 0, 先手必败\nn % (m + 1) != 0, 先手必胜\n威佐夫博弈 有两堆石子，分别有 a, b 颗，每次可以选一堆取 x 个，也可以选两堆都取 x 个\n所以 (a, b)有三种转移，(a-x, b), (a, b-x), (a-x, b-x);\n打表找规律\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 10010; 4 5int dp[N][N]; 6 7int main(){ 8 for (int i = 0; i \u0026lt;= 100; i++){ 9 for (int j = 0; j \u0026lt;= 100; j++){ 10 for (int x = 1; x \u0026lt;= i; x++) 11 if (dp[i - x][j] == 0) dp[i][j] = 1; 12 for (int x = 1; x \u0026lt;= j; x++) 13 if (dp[i][j - x] == 0) dp[i][j] = 1; 14 for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) 15 if (dp[i - x][j - x] == 0) dp[i][j] = 1; 16 if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); 17 } 18 } 19 return 0; 20} 首先发现 (a, b) 和 (b, a), 状态相同，即同为必败态或必胜态\n再对 a \u0026lt; b 的情况分析，发现 a 是从 1 到 n 的，b - a 逐渐递增，依次为 1 2 3 4 5 \u0026hellip;\nNim 模型 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流取，Alice 先取，每次可以从选一堆任取 x 个石子， 可以拿光，但不能不拿，谁最后把所有的拿光谁获胜\n先打表\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 10010; 4 5int dp[N][N]; 6 7int main(){ 8 for (int i = 0; i \u0026lt;= 100; i++){ 9 for (int j = 0; j \u0026lt;= 100; j++){ 10 for (int x = 1; x \u0026lt;= i; x++) 11 if (dp[i - x][j] == 0) dp[i][j] = 1; 12 for (int x = 1; x \u0026lt;= j; x++) 13 if (dp[i][j - x] == 0) dp[i][j] = 1; 14 // for (int x = 1; x \u0026lt;= i \u0026amp;\u0026amp; x \u0026lt;= j; x++) 15 // if (dp[i - x][j - x] == 0) dp[i][j] = 1; 16 if (dp[i][j] == 0) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); 17 } 18 } 19 return 0; 20} 发现 i == j，经推广更多维，可以总结出必败态：A1^A2^A3^\u0026hellip;^An = 0\n要证明此结论，可从三个定理入手\n1：没有后续状态的状态是必败态\n2：对于 A1^A2^A3^\u0026hellip;^An != 0 的局面一定存在某种移动使 A1^A2^A3^\u0026hellip;^An = 0\n3：对于 A1^A2^A3^\u0026hellip;^An = 0，不存在一种移动使 A1^A2^A3^\u0026hellip;^An = 0\n例题练习 石子游戏 2 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，每次可以把一堆个数为奇数的石子分为两堆，两堆都不能为空，或把两堆为偶数的石子和为一堆\n可以注意到两种操作都是对堆数改变，那么堆数的奇偶性就是突破点，同时根据操作的实质，可以发现只有 1 个石子的堆是无法继续操作的，最后石堆将变成全是 1 或者 1 个偶数剩下的全是 1\n所以结论就是：如果石堆全是 1，则先手必败，如果不是全为 1 那么就检测结束时堆数的奇偶性是否改变\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 10010; 4 5int n, odd, one; 6int x; 7 8int main(){ 9 cin \u0026gt;\u0026gt; n; 10 for (int i = 1;i \u0026lt;= n; i++){ 11 cin \u0026gt;\u0026gt; x; 12 if (x % 2 == 1) odd++; 13 if (x == 1) one++; 14 } 15 if (one != n) odd++; 16 if ((odd + n) % 2 != 0)cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; 17 else cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#34;; 18 return 0; 19} 石子游戏 3 有 n 堆石子，每堆有 a[i] 个石子，Alice 和 Bob 轮流操作，选择 n/2 堆非空石子，每堆移除掉正数个(可以不同)的石子，从 Alice 开始。\n倒推：\n必败：超过 n/2 个堆已经为 0 必胜：有 1 ~ n/2 个堆为 0\n必败：有 \u0026gt; n/2 个堆石子数量为 1\n必胜：有 1 ~ n/2 个堆的数量为 1\n必败：有 \u0026gt; n/2 个堆的数量为 2\n\u0026hellip;\u0026hellip;\n有大于 n/2 个堆的数量 = min，必败\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 10010; 4 5int n, mx = 1e9, cnt; 6 7int main(){ 8 cin \u0026gt;\u0026gt; n; 9 for (int i = 1; i \u0026lt;= n; i++){ 10 int x; 11 cin \u0026gt;\u0026gt; x; 12 if (x \u0026lt; mx) mx = x, cnt = 0; 13 if (x == mx) cnt++; 14 } 15 if (cnt \u0026gt; n/2) cout \u0026lt;\u0026lt; \u0026#34;Alice\\n\u0026#34;; 16 else cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; 17 return 0; 18} ","permalink":"https://KiritoXDone.github.io/posts/study/%E5%8D%9A%E5%BC%88%E8%AE%BA/","summary":"博弈论 简介 两人在公平规则下进行有限的对决，胜负明确 类似有向无环图，由一个状态转移到下一个状态 对先手来说，存在两种状态，即必胜态和必败态 必胜态 当前状态的后续为必败态，当前状态即为必胜态 必败态 不存在后续，或是所有后续都必胜 DP 解决博弈 利用状态转移的关系，来解决简单的博弈问题 移棋子问题 n","title":"博弈论"},{"content":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把\nI 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n; 6 cin \u0026gt;\u0026gt; n; 7 string s; 8 cin \u0026gt;\u0026gt; s; 9 int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; 10 while (pos != string::npos) { 11 cnt++; 12 pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); 13 } 14 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; 15 return 0; 16} F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都一样，直接输出即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3int main(){ 4 int t; 5 cin\u0026gt;\u0026gt;t; 6 while(t--){ 7 int a,b; 8 cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; 9 cout\u0026lt;\u0026lt;\u0026#34;DHY\\n\u0026#34;; 10 } 11} A 国际旅行 I 认真读题可得知，恒为联通图，排序所有国家即可。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 1e6+10; 4 5int n,m,q,k; 6vector\u0026lt;int\u0026gt;a(N); 7map\u0026lt;int,int\u0026gt;vis; 8 9int main(){ 10 cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; 11 for(int i=1;i\u0026lt;=n;i++)cin\u0026gt;\u0026gt;a[i]; 12 for(int i=1;i\u0026lt;=m;i++){ 13 int u,v; 14 cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; 15 } 16 sort(a.begin()+1,a.begin()+1+n); 17 while(q--){ 18 cin\u0026gt;\u0026gt;k; 19 cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; 20 } 21} J 这是签到 矩阵计算板\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int n,m; 5int a[6][6]; 6 7int cal(int n, int a[6][6]) { 8 if (n == 1) 9 return a[0][0]; 10 int res = 0; 11 int sub[6][6]; 12 for (int x = 0; x \u0026lt; n; x++) { 13 int subi = 0; 14 for (int i = 1; i \u0026lt; n; i++) { 15 int subj = 0; 16 for (int j = 0; j \u0026lt; n; j++) { 17 if (j == x) continue; 18 sub[subi][subj] = a[i][j]; 19 subj++; 20 } 21 subi++; 22 } 23 res += (x % 2 == 0 ? 1 : -1) * a[0][x] * cal(n - 1, sub); 24 } 25 return res; 26} 27 28int main() { 29 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; 30 for (int i = 0; i \u0026lt; n; i++) 31 for (int j = 0; j \u0026lt; m; j++) 32 cin \u0026gt;\u0026gt; a[i][j]; 33 int ans = INT_MAX; 34\tint u=min(n,m); 35\tfor(int i=1;i\u0026lt;=u;i++){ 36\tans=min(ans,cal(i,a)); 37\t} 38 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; 39 return 0; 40} H 狼狼的备忘录 STL 大法好\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int n, cnt, m; 5string s; 6map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; note; 7map\u0026lt;string, map\u0026lt;string, int\u0026gt;\u0026gt; vis; 8set\u0026lt;string\u0026gt; peo; 9 10void erase(string \u0026amp;a, string \u0026amp;b) { 11 if (a == b) { 12 b = \u0026#34;\u0026#34;; 13 return; 14 } 15 if (a.size() \u0026gt; b.size() \u0026amp;\u0026amp; a.substr(a.size() - b.size()) == b) { 16 b = \u0026#34;\u0026#34;; 17 } 18} 19 20int main() { 21 cin \u0026gt;\u0026gt; n; 22 for (int i = 1; i \u0026lt;= n; i++) { 23 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; cnt; 24 peo.insert(s); 25 for (int j = 1; j \u0026lt;= cnt; j++) { 26 string t; 27 cin \u0026gt;\u0026gt; t; 28 if (!vis[s][t]) note[s].push_back(t); 29 vis[s][t]++; 30 } 31 } 32 for (auto x : peo) { 33 int m = note[x].size(); 34 for (int i = 0; i \u0026lt; m; i++) { 35 for (int j = i + 1; j \u0026lt; m; j++) { 36 erase(note[x][i], note[x][j]); 37 erase(note[x][j], note[x][i]); 38 } 39 } 40 sort(note[x].begin(), note[x].end()); 41 note[x].erase(remove(note[x].begin(), note[x].end(), \u0026#34;\u0026#34;), note[x].end()); 42 } 43 cout \u0026lt;\u0026lt; peo.size() \u0026lt;\u0026lt; endl; 44 for (auto x : peo) { 45 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; note[x].size(); 46 for (auto s : note[x]) { 47 cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s; 48 } 49 cout \u0026lt;\u0026lt; endl; 50 } 51 52 return 0; 53} D A*BBBB 高精度 根据题意可知 是同一个结果往前移 b.size() 次相加 赛时笨比没调出来 python 引入 demical 库过的\n赛时代码\n1from decimal import * 2import sys 3t=int(input()) 4for i in range(t): 5 setcontext(Context(prec=2000000, Emax=2000000, Emin=0)) 6 print((Decimal(sys.stdin.readline())*Decimal(sys.stdin.readline()))) 正解\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 1e7+10; 4typedef long long ll; 5 6int a[N],sum[N],ans[N\u0026lt;\u0026lt;1]; 7string A,B; 8 9void solve(){ 10\tcin\u0026gt;\u0026gt;A\u0026gt;\u0026gt;B; 11\tint la=A.length(),lb=B.length(),b=B[0]-\u0026#39;0\u0026#39;; 12\tll last=0; 13\ta[la+1]=0; 14\tfor(int i=1;i\u0026lt;=la;i++){ 15\ta[i]=(A[la-i]-\u0026#39;0\u0026#39;)*b+last; 16\tlast=a[i]/10; 17\ta[i]*=10; 18\tsum[i]=sum[i-1]+a[i]; 19\t} 20\tsum[la+1]=sum[la]+last; 21\tlast=0; 22\tfor(int i=1;i\u0026lt;=la+lb;i++){ 23\tint l=min(i,la+1),r=max(0,i-lb); 24\tans[i]=sum[l]-sum[r]+last; 25\tlast=ans[i]/10; 26\tans[i]%=10; 27\t} 28 bool flag=0; 29 for(int i=la+lb;i\u0026gt;=1;--i) { 30 if(!ans[i]) { 31 if(flag) printf(\u0026#34;%d\u0026#34;,ans[i]); 32 } else { 33 flag=1; 34 printf(\u0026#34;%d\u0026#34;,ans[i]); 35 } 36 } 37 if(!flag) printf(\u0026#34;0\u0026#34;); 38 printf(\u0026#34;\\n\u0026#34;); 39} 40 41int main(){ 42\tint t; 43\tcin\u0026gt;\u0026gt;t; 44\twhile(t--)solve(); 45\treturn 0; 46} E \u0026ldquo;好\u0026quot;字符 观察得到 a，b 同一字符所处位置相邻差值构成的一个循环同构如果相同，就符合题意\n那么就对 26 个字符各跑一次 找到位置 存入字符串 找到该串的最小表示 比较即可\n需要注意将原 a，b 再复制本身一遍 因为这样才能保证找的最小表示没有缺少\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int kmp(int nxt[], string a) { 5 int n = a.size(); 6 nxt[0] = 0; 7 int j = 0; 8 for (int i = 1; i \u0026lt; n; i++) { 9 while (j \u0026amp;\u0026amp; a[i] != a[j]) 10 j = nxt[j - 1]; 11 if (a[i] == a[j]) 12 j++; 13 nxt[i] = j; 14 } 15 return n - nxt[n - 1]; 16} 17 18string getmin(string s, int n) { 19 s = s + s; 20 int i = 0, j = 1; 21 while (j \u0026lt; n) { 22 int k = 0; 23 while (k \u0026lt; n \u0026amp;\u0026amp; s[i + k] == s[j + k]) ++k; 24 if (s[i + k] \u0026gt; s[j + k]) i += k + 1; 25 else j += k + 1; 26 if (i == j) j++; 27 if (i \u0026gt; j) swap(i, j); 28 } 29 string t = s.substr(i, n); 30 return t; 31} 32 33int main() { 34 int n; 35 string a, b; 36 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 37 a = a + a; 38 b = b + b; 39 map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; va, vb; 40 map\u0026lt;char, string\u0026gt; sa, sb; 41 for (int i = 0; i \u0026lt; n * 2; i++) { 42 va[a[i]].push_back(i); 43 vb[b[i]].push_back(i); 44 } 45 int cnt = 0, nxt[2000010]; 46 for (char x = \u0026#39;a\u0026#39;; x \u0026lt;= \u0026#39;z\u0026#39;; x++) { 47 if (va[x].size() != vb[x].size() || va[x].size() == 0 || vb[x].size() == 0) continue; 48 for (int i = 1; i \u0026lt; va[x].size(); i++) { 49 sa[x] += to_string(va[x][i] - va[x][i - 1]); 50 } 51 for (int i = 1; i \u0026lt; vb[x].size(); i++) { 52 sb[x] += to_string(vb[x][i] - vb[x][i - 1]); 53 } 54 if (getmin(sa[x], kmp(nxt, sa[x])) == getmin(sb[x], kmp(nxt, sb[x]))) cnt++; 55 } 56 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; 57 return 0; 58} C 小 w 和大 W 的对决 sg 暴力打表 发现 8 个为一个循环 最后两个交换位置\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int calc(int x){ 5 if(x%8==0)return x-1; 6 if(x%8==7)return x+1; 7 else return x; 8} 9 10int ans; 11 12int main(){ 13 int n,x; 14 cin\u0026gt;\u0026gt;n; 15 for(int i=1;i\u0026lt;=n;i++){ 16 cin\u0026gt;\u0026gt;x; 17 ans^=calc(x); 18 } 19 if(ans==0)cout\u0026lt;\u0026lt;\u0026#34;W win\\n\u0026#34;; 20 else cout\u0026lt;\u0026lt;\u0026#34;w win\\n\u0026#34;; 21} G lxy 的通风报信 因为数据不大，直接 bfs 跑每个点对其他点的距离，再求最小生成树即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 1010; 4 5struct Node{ 6 int x,y,id; 7}b[N]; 8 9int n,m,ans,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},tot,dis[N][N],a[N][N]; 10bool vis[N]; 11deque\u0026lt;Node\u0026gt;q; 12 13void bfs(int id){ 14 q.clear(); 15 q.push_back(Node{b[id].x,b[id].y,0}); 16 dis[b[id].x][b[id].y]=0; 17 while(!q.empty()){ 18 Node now=q.front(); 19 q.pop_front(); 20 for(int i=0;i\u0026lt;4;i++){ 21 int x=now.x+dx[i],y=now.y+dy[i]; 22 if(x\u0026lt;1||y\u0026lt;1||x\u0026gt;n||y\u0026gt;m||a[x][y]==-1)continue; 23 if(dis[x][y]\u0026gt;now.id+1){ 24 dis[x][y]=now.id+1; 25 q.push_back(Node{x,y,dis[x][y]}); 26 } 27 } 28 } 29} 30 31void solve(){ 32 cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; 33 for(int i=1;i\u0026lt;=n;i++){ 34 for(int j=1;j\u0026lt;=m;j++){ 35 dis[i][j]=1e9; 36 char x; 37 cin\u0026gt;\u0026gt;x; 38 if(x==\u0026#39;.\u0026#39;)a[i][j]=0; 39 else if(x==\u0026#39;#\u0026#39;)a[i][j]=-1; 40 else { 41 a[i][j]=++tot; 42 b[tot]=Node{i,j,tot}; 43 } 44 } 45 } 46 dis[b[1].x][b[1].y]=0; 47 for(int i=1;i\u0026lt;=tot;i++){ 48 int mi=1e9,id=0; 49 for(int j=1;j\u0026lt;=tot;++j){ 50 if(vis[j])continue; 51 if(mi\u0026gt;dis[b[j].x][b[j].y])mi=dis[b[j].x][b[j].y],id=j; 52 } 53 if(!id){ 54 puts(\u0026#34;No\u0026#34;); 55 return; 56 } 57 vis[id]=1; 58 ans+=mi; 59 if(i!=tot)bfs(id); 60 } 61 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 62} 63 64int main(){ 65 int t=1; 66// cin\u0026gt;\u0026gt;t; 67 while(t--)solve(); 68 return 0; 69} ","permalink":"https://KiritoXDone.github.io/posts/study/2024%E8%90%8C%E6%96%B0%E8%81%94%E8%B5%9B2/","summary":"2024 河南萌新联赛 2 状态 + 狗运+ py 大法，目前最好的一把 I 重生之zbk要拿回属于他的一切 签到，暴力找 chuan 的数量即可 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4int main() { 5 int n; 6 cin \u0026gt;\u0026gt; n; 7 string s; 8 cin \u0026gt;\u0026gt; s; 9 int pos = s.find(\u0026#34;chuan\u0026#34;), cnt = 0; 10 while (pos != string::npos) { 11 cnt++; 12 pos = s.find(\u0026#34;chuan\u0026#34;, pos + 1); 13 } 14 cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; 15 return 0; 16} F 水灵灵的小学弟 观察题目，发现博弈双方名称相同，不管谁赢都","title":"2024萌新联赛2"},{"content":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n)\n用两个指针 i,j, 分别指想目前两个可能是答案的起始位置\n初始 i = 1, j = 2, 随着算法进行增大\n假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同\n如果 s[i+k]!=s[j+k]\n谁大谁往后移动 k+1 个位置\n如果 s[i+k]==s[j+k]\n随便移动一个\n最后小于 n 的那个指针就是所求答案\n1void getmin(string s){ 2 int n=s.size(); 3 s=s+s; 4 int i=0,j=1; 5 while(j\u0026lt;n){ 6 int k=0; 7 while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k]) 8 ++k; 9 if(s[i+k]\u0026gt;s[j+k]) 10 i+=k+1; 11 else 12 j+=k+1; 13 if(i==j)j++; 14 if(i\u0026gt;j)swap(i,j); 15 } 16 for(int k=i;k\u0026lt;=i+n;k++)cout\u0026lt;\u0026lt;s[k]; 17} 例题 循环同构判断 给定两个字符串 a, b,判断两个字符串是否循环同构\n只需判断两个字符串最小表示是否一样即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string a,b; 5 6int getmin(string s){ 7 int n=s.size(); 8 int i=0,j=1; 9 s=s+s; 10 while(j\u0026lt;n){ 11 int k=0; 12 while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; 13 if(s[i+k]\u0026gt;s[j+k])i+=k+1; 14 else j+=k+1; 15 if(i==j)++j; 16 if(i\u0026gt;j)swap(i,j); 17 } 18 return i; 19} 20 21int main(){ 22 cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; 23 for(int i=getmin(a),j=getmin(b),k=0;k\u0026lt;n;k++){ 24 if(a[(i+k)%n]!=b[(j+k)%n]){ 25 cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; 26 return 0; 27 } 28 } 29 cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; 30} 最小循环覆盖 给出字符串 a，求出这个字符串的字典序最小的最小循环覆盖\n先用 kmp 求出最小循环片段长度，再求这个长度的子串的最小表示\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string a; 5int nxt[100005]; 6 7int kmp(){ 8 int n=a.size(); 9 nxt[0]=0; 10 int j=0; 11 for(int i=1;i\u0026lt;n;i++){ 12 while(j\u0026amp;\u0026amp;a[i]!=a[j]) 13 j=nxt[j-1]; 14 if(a[i]==a[j]) 15 j++; 16 nxt[i]=j; 17 } 18 return n-nxt[n-1]; 19} 20 21void getmin(string s,int n){ 22 s=s+s; 23 int i=0,j=1; 24 while(j\u0026lt;n){ 25 int k=0; 26 while(k\u0026lt;n\u0026amp;\u0026amp;s[i+k]==s[j+k])++k; 27 if(s[i+k]\u0026gt;s[j+k])i+=k+1; 28 else j+=k+1; 29 if(i==j)j++; 30 if(i\u0026gt;j)swap(i,j); 31 } 32 for(int l=i;l\u0026lt;i+n;l++)cout\u0026lt;\u0026lt;s[l]; 33} 34 35int main(){ 36 cin\u0026gt;\u0026gt;a; 37 getmin(a,kmp()); 38 return 0; 39} ","permalink":"https://KiritoXDone.github.io/posts/study/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"最小表示法 理论学习 给定一个字符串 s，首尾相接（循环同构），找到其字典序最小的情况 O(n) 用两个指针 i,j, 分别指想目前两个可能是答案的起始位置 初始 i = 1, j = 2, 随着算法进行增大 假设现在 i \u0026lt; j, 且从 i 开始的 k 位字符和从 j 开始的 k 位字符是一样的，此时这两段子串相同 如果 s[i+k]!=s[j+k] 谁大谁往后移动 k+1 个位置 如果 s[i+k]==s[j+k] 随","title":"最小表示法"},{"content":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。\n签到，直接暴力\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5 string t,s; 6 cin\u0026gt;\u0026gt;s; 7 map\u0026lt;char,int\u0026gt;vis; 8 for(int i=0;i\u0026lt;8;i++){ 9 if(i%2!=1)t+=s[i]; 10 vis[s[i]]++; 11 } 12 s=t; 13 t=\u0026#34;\u0026#34;; 14 for(int i=0;i\u0026lt;4;i++){ 15 if(i%2!=1)t+=s[i]; 16 } 17 if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; 18 else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; 19 else cout\u0026lt;\u0026lt;t[1]; 20 cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 21} 22 23int main(){ 24 int t=1; 25 cin\u0026gt;\u0026gt;t; 26 while(t--)solve(); 27 return 0; 28} 1007 URL 划分 输入: 1 s3://hdu-oj-bucket/problem=1/type=data/ 输出： s3 hdu-oj-bucket problem=1 type=data\n签到，按题意拆分字符串即可\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5 string s; 6 cin\u0026gt;\u0026gt;s; 7 int pos = s.find(\u0026#34;://\u0026#34;); 8 cout\u0026lt;\u0026lt;s.substr(0,pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 9 pos+=3; 10 int now = s.find(\u0026#34;/\u0026#34;,pos); 11 cout\u0026lt;\u0026lt;s.substr(pos,now-pos)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 12 while(1){ 13 pos=now+1; 14 if(pos\u0026gt;=s.size())break; 15 now = s.find(\u0026#34;/\u0026#34;,pos); 16 string t = s.substr(pos,now-pos); 17 int flag = t.find(\u0026#34;=\u0026#34;); 18 if(flag!=-1)cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 19 } 20} 21 22int main(){ 23 int t=1; 24 cin\u0026gt;\u0026gt;t; 25 while(t--)solve(); 26 return 0; 27} 鸡爪 给 n 条边，任意顶点，构造数量最多的鸡爪，同时保证输出每条边的两个顶点时，保证行优先遍历，字典序最小。\n鸡爪的定义：1 个顶点，和它所连的 3 条边，不包括其他顶点，不可重复利用。\n构造，易想出 n 条边，最多构造出 n/3 个鸡爪，多出的 1 或 2 个边，补到顶点1上即可。\n因为字典序最小，所以顶点 1 上连的边肯定最多，我们就让 1 连到所有的顶点上，这样其他所有构造鸡爪的顶点 n 都能用上 1-n 这条边。因此 1 自己用的边肯定是入度最小的几个顶点，即编号最大的顶点，类推到之后的顶点，都是先采用与其之前的顶点的边，再从最后面选。到顶点 4 开始，不再需要往后采用，因为前面有 3 个顶点提供边，不再需要额外的顶点来提供边。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5 int n; 6 cin\u0026gt;\u0026gt;n; 7 if(n\u0026gt;=3){ 8 int now=0,cnt=n/3+3; 9 for(int i=1;i\u0026lt;=min(n/3,3);i++){ 10 for(int j=i+1;j\u0026lt;=cnt-i+1;j++){ 11 cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 12 if(i==1\u0026amp;\u0026amp;j==cnt-i+1){ 13 int now=j; 14 while(n%3!=0){ 15 cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;++now\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 16 n--; 17 18 } 19 } 20 } 21 } 22 } 23 else{ 24 for(int i=2;i\u0026lt;=n+1;i++)cout\u0026lt;\u0026lt;\u0026#34;1 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 25 } 26} 27 28int main() { 29 int t; 30 cin \u0026gt;\u0026gt; t; 31 while (t--) solve(); 32 return 0; 33} 传奇勇士小凯 有⼀个 n 个结点的有根树，你需要从 1 号结点走到任意⼀个叶子节点，每天你有 p[i]/15 的可能性可以向任意⼀个儿子节点走⼀步（ i 为你当前所在的节点编号），询问你期望最多可以在这颗树上走多久\n期望计算，在某一节点停留的步数应该为 15/p[i] 。\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3typedef long long ll; 4const int N = 1e5+7; 5 6ll ans=0, LCM=360360; 7vector\u0026lt;int\u0026gt; nxt[N]; 8vector\u0026lt;int\u0026gt; p(N); 9 10ll gcd(int x,int y){ 11 if(!x||!y)return x+y; 12 return gcd(y,x%y); 13} 14 15void dfs(int u,int fa, ll sum) { 16 sum += (LCM / p[u]); 17 if(sum\u0026gt;ans)ans=sum; 18 for (auto x : nxt[u]) { 19 if(x==fa)continue; 20 dfs(x, u, sum); 21 } 22} 23 24void solve() { 25 int n; 26 cin \u0026gt;\u0026gt; n; 27 ans=0; 28 for (int i = 1; i \u0026lt; n; i++) { 29 int u, v; 30 cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; 31 nxt[u].push_back(v); 32 nxt[v].push_back(u); 33 } 34 for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i]; 35 dfs(1, 0, 0); 36 ll d=gcd(15*ans,LCM); 37 printf(\u0026#34;%lld/%lld\\n\u0026#34;,15*ans/d,LCM/d); 38 for (int i = 1; i \u0026lt;= n; i++) nxt[i].clear(); 39} 40 41int main() { 42 int t; 43 cin \u0026gt;\u0026gt; t; 44 while (t--) solve(); 45 return 0; 46} 绝对不模拟的简单魔方 1)暴力，从初始状态开始模拟，每次对比当前状态和给出状态，若相同或不同点仅两个，即得到答案\n2)将魔方视为 2 阶的，预处理得到 24 种可能状态，与给出状态对比，至多有一个角不同，即为答案。\n1之后补... 在 A 里面找有 C 的 B AC自动机（还不会，之后补\u0026hellip;.\n","permalink":"https://KiritoXDone.github.io/posts/study/2024hdu2/","summary":"杭电多校 2 补题 1010 女神的睿智 按顺序合并 8 块碎片，如果两片相同，合成后仍相同，如不同，取左侧的，最后合成大碎片时，如果两片相同，不变，如果不同，取出现次数最多的，如果不确定，输出N。 签到，直接暴力 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void solve(){ 5 string t,s; 6 cin\u0026gt;\u0026gt;s; 7 map\u0026lt;char,int\u0026gt;vis; 8 for(int i=0;i\u0026lt;8;i++){ 9 if(i%2!=1)t+=s[i]; 10 vis[s[i]]++; 11 } 12 s=t; 13 t=\u0026#34;\u0026#34;; 14 for(int i=0;i\u0026lt;4;i++){ 15 if(i%2!=1)t+=s[i]; 16 } 17 if(vis[t[0]]==vis[t[1]])cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; 18 else if(vis[t[0]]\u0026gt;vit[t[1]])cout\u0026lt;\u0026lt;t[0]; 19 else cout\u0026lt;\u0026lt;t[1]; 20","title":"2024HDU2"},{"content":"Manacher 理念学习 解决最长回文子串问题\n给出一个任意字符串，求出这个字符串中最长的回文子串\n正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可\n对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文子串的长度，记做 p[i] (包括 i 本身，所以最小为 1)\n维护 p[i] 的值：\n维护一个到目前位置的R最大的区间 [L, R]，其中 L = M - p[M] + 1 (M \u0026lt; i) R = M + p[M] - 1\n[L, R] 是一个回文串 如果i \u0026lt;= R:\n找到 i 对于 M 的对称点 k，此时 i - M = M - k,k = 2 * M - i; 此时有两种情况：\n(1)如果 p[k] 对应的回文区间 [k - p[k] + 1, k + p[k] - 1]，不含左端点 L，说明这个回文区间在 [L, R] 之中，此时我们可以得到 p[i] = p[k]\n(2)如果包含了左端点L，此时 [L, 2k-L] 这一端为回文串。由于 [L, R] 是回文串，可得出 [2i-R, R] 也是回文串。往两端暴力拓展即可。 如果 i \u0026gt; R：\n暴力两端拓展即可 都要记得更新 M, L, R 的值。\n1void manacher(){ 2 n=s.size(); 3 t.resize(2*n+10); 4 int m=0; 5 t[0]=\u0026#39;$\u0026#39;; 6 for(int i=0;i\u0026lt;n;i++){ 7 t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; 8 } 9 int M=0,R=0; 10 for(int i=0;i\u0026lt;m;i++){ 11 if(i\u0026gt;R) 12 p[i]=1; 13 else 14 p[i]=min(p[2*M-i],R-i+1); 15 while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) 16 ++p[i]; 17 if(i+p[i]-1\u0026gt;R) 18 M=i,R=i+p[i]-1; 19 } 20 int ans=0; 21 for(int i=0;i\u0026lt;=m;i++){ 22 ans=max(ans,p[i]); 23 } 24 cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; 25} 洛谷例题 P3805\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 2e7+10; 4 5int n,p[2*N]; 6string s,t; 7 8void manacher(){ 9 n=s.size(); 10 t.resize(2*n+10); 11 int m=0; 12 t[0]=\u0026#39;$\u0026#39;; 13 for(int i=0;i\u0026lt;n;i++){ 14 t[++m]=s[i],t[++m]=\u0026#39;$\u0026#39;; 15 } 16 int M=0,R=0; 17 for(int i=0;i\u0026lt;m;i++){ 18 if(i\u0026gt;R) 19 p[i]=1; 20 else 21 p[i]=min(p[2*M-i],R-i+1); 22 while(i-p[i]\u0026gt;=0\u0026amp;\u0026amp;i+p[i]\u0026lt;=m\u0026amp;\u0026amp;t[i-p[i]]==t[i+p[i]]) 23 ++p[i]; 24 if(i+p[i]-1\u0026gt;R) 25 M=i,R=i+p[i]-1; 26 } 27 int ans=0; 28 for(int i=0;i\u0026lt;=m;i++){ 29 ans=max(ans,p[i]); 30 } 31 cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; 32} 33 34int main(){ 35 cin\u0026gt;\u0026gt;s; 36 manacher(); 37 return 0; 38} 坑点：字符串 t 要 resize，不然 re\n","permalink":"https://KiritoXDone.github.io/posts/study/manacher/","summary":"Manacher 理念学习 解决最长回文子串问题 给出一个任意字符串，求出这个字符串中最长的回文子串 正常情况下，需要对长度奇偶不同的分类讨论。但可以用一个 s 中不存在的字符，把 s 中每一位隔开，再求新串中奇数长度的最长回文子串即可 对于新串 s ，我们的目的是求出从它的任意位置 i 出发，往两边最远能拓展出的回文","title":"Manacher"},{"content":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点\nkmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1\n简化版\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s,p; 5int nxt[100001],f[100001],n,m; 6 7void kmp(){ 8 n=s.size(); 9 m=p.size(); 10 int j=0; 11 nxt[0]=0; 12 p=p+\u0026#34;#\u0026#34;+s; 13 for(int i=1;i\u0026lt;m+n+1;i++){ 14 while(j\u0026amp;\u0026amp;p[i]!=p[j]) 15 j=nxt[j-1]; 16 if(p[i]==p[j]) 17 j++; 18 nxt[i]=j; 19 } 20 for(int i=m+1;i\u0026lt;n+m+1;i++){ 21 if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; 22 } 23} 24 25int main(){ 26 cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; 27 kmp(); 28 return 0; 29} 常规版\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s,p; 5int nxt[100001],f[100001],n,m; 6 7void kmp(){ 8 n=s.size(); 9 m=p.size(); 10 int j=0; 11 nxt[0]=0; 12 for(int i=1;i\u0026lt;m;i++){ 13 while(j\u0026amp;\u0026amp;p[i]!=p[j]) 14 j=nxt[j-1]; 15 if(p[i]==p[j]) 16 j++; 17 nxt[i]=j; 18 } 19 j=0; 20 for(int i=0;i\u0026lt;n;i++){ 21 while(j==m||(j\u0026amp;\u0026amp;s[i]!=p[j])) 22 j=nxt[j-1]; 23 if(s[i]==p[j]) 24 j++; 25 f[i]=j; 26 } 27 for(int i=0;i\u0026lt;n;i++){ 28 if(f[i]==m)cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; 29 } 30} 31 32int main(){ 33 cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; 34 kmp(); 35 return 0; 36} 寻找最小循环子串 字符串 s 是由某个子串重复连接而成的，寻找构成 s 的最小子串的长度\n答案其实就是 n - nxt[n]\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s,p; 5int nxt[100001],n,m; 6 7void kmp(){y 8 m=p.size(); 9 int j=0; 10 nxt[0]=0; 11 p=p; 12 for(int i=1;i\u0026lt;m;i++){ 13 while(j\u0026amp;\u0026amp;p[i]!=p[j]) 14 j=nxt[j-1]; 15 if(p[i]==p[j]) 16 j++; 17 nxt[i]=j; 18 } 19 cout\u0026lt;\u0026lt;m-nxt[m-1]\u0026lt;\u0026lt;endl; 20} 21 22int main(){ 23 cin\u0026gt;\u0026gt;p; 24 kmp(); 25 return 0; 26} Secret word 给出字符串 s，寻找最长字符串 p，p 满足（是 s 的子串，翻转后是 s 的前缀）\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s; 5int nxt[200001],n; 6 7void kmp(){ 8 n=s.size(); 9 int j=0; 10 nxt[0]=0; 11 string t=s; 12 reverse(t.begin(),t.end()); 13 s=s+\u0026#34;#\u0026#34;+t; 14 for(int i=1;i\u0026lt;n*2+1;i++){ 15 while(j\u0026amp;\u0026amp;s[i]!=s[j]) 16 j=nxt[j-1]; 17 if(s[i]==s[j]) 18 j++; 19 nxt[i]=j; 20 } 21 int ans=-1; 22 for(int i=n;i\u0026lt;2*n+1;i++){ 23 ans=max(ans,nxt[i]); 24 } 25 for(int i=ans-1;i\u0026gt;=0;i--)cout\u0026lt;\u0026lt;s[i]; 26} 27 28int main(){ 29 cin\u0026gt;\u0026gt;s; 30 kmp(); 31 return 0; 32} exkmp 洛谷 P5410\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 2e7+10; 4typedef long long ll; 5 6string s,p; 7ll z[N*2],n,m; 8 9void exkmp(string s,string p){ 10 n=s.size(); 11 m=p.size(); 12 p=p+\u0026#34;#\u0026#34;+s; 13 ll L=0,R=-1; 14 z[0]=m; 15 for(int i=1;i\u0026lt;n+m+1;i++){ 16 if(i\u0026gt;R) 17 z[i]=0; 18 else{ 19 ll k=i-L; 20 z[i]=min(z[k],R-i); 21 } 22 while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) 23 ++z[i]; 24 if(i+z[i]-1\u0026gt;R) 25 L=i,R=i+z[i]-1; 26 } 27 ll ans=0; 28 for(int i=0;i\u0026lt;m;i++)ans^=(1LL*(i+1)*(z[i]+1)); 29 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 30 ans=0; 31 for(int i=0;i\u0026lt;n;i++)ans^=(1LL*(i+1)*(z[i+m+1]+1)); 32 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; 33} 34 35int main(){ 36 cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; 37 exkmp(s,p); 38 return 0; 39} ","permalink":"https://KiritoXDone.github.io/posts/study/0721/","summary":"0721 学习记录 今天集训休息，自己看了看代码源的视频补知识点 kmp 相关 子串查询 输入两个字符串 s, p,查询 p 是否在 s 中出现,若出现输出出现位置,否则输出 -1 简化版 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s,p; 5int nxt[100001],f[100001],n,m; 6 7void kmp(){ 8 n=s.size(); 9 m=p.size(); 10 int j=0; 11 nxt[0]=0; 12 p=p+\u0026#34;#\u0026#34;+s; 13 for(int i=1;i\u0026lt;m+n+1;i++){ 14 while(j\u0026amp;\u0026amp;p[i]!=p[j]) 15 j=nxt[j-1]; 16 if(p[i]==p[j]) 17 j++; 18 nxt[i]=j; 19 } 20 for(int i=m+1;i\u0026lt;n+m+1;i++){ 21 if(nxt[i]==m)cout\u0026lt;\u0026lt;i-2*m+1\u0026lt;\u0026lt;endl; 22 } 23} 24 25int main(){ 26 cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; 27 kmp(); 28 return 0; 29} 常规版 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3","title":"0721"},{"content":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现\n暴力匹配 O(nm)\n哈希优化 O(n+m)\nKMP 线性复杂度解决 O(n+m)\nKMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同\nf[i] 对应j的位置，j对应p中的位置\n如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位\n否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k 最大的位\n如果 s[i + 1] 仍不等于 p[j + 1]，不停向前回退，直到相等或 j = 0\n快速求出 k\n易得到求 k 与 s 无关\n最大的 k 满足 k \u0026lt; j,使得 p[1]..p[k] 和 p[j - k + 1]\u0026hellip;p[j] 完全相同\n可以用 next 维护每个 j 对应的 k\n1void kmp(){ 2 n=s.size()+1,m=p.size()+1;//字符串下标从 1 开始 3 int j=0; 4 nxt[1]=0; 5 for(int i=2;i\u0026lt;=m;i++){ 6 while(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=p[i]) 7 j=nxt[j]; 8 if(p[j+1]==p[i]) 9 j++; 10 nxt[i]=j; 11 } 12 j=0; 13 for(int i=1;i\u0026lt;=n;i++){ 14 while((j==m)||(j\u0026gt;0\u0026amp;\u0026amp;p[j+1]!=s[i])) 15 j=nxt[j]; 16 if(p[j+1]==s[i]) 17 j++; 18 f[i]=j; 19 } 20} 洛谷例题 P3375\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3const int N = 1e6+10; 4 5int n, m; 6string s, p; 7int nxt[N], f[N]; 8 9void kmp() { 10 n = s.size(); 11 m = p.size(); 12 nxt[0] = 0; 13 int j = 0; 14 for (int i = 1; i \u0026lt; m; i++) { 15 while (j \u0026gt; 0 \u0026amp;\u0026amp; p[i] != p[j]) 16 j = nxt[j - 1]; 17 if (p[i] == p[j]) 18 j++; 19 nxt[i] = j; 20 } 21 j = 0; 22 for (int i = 0; i \u0026lt; n; i++) { 23 while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != p[j]) 24 j = nxt[j - 1]; 25 if (s[i] == p[j]) 26 j++; 27 f[i] = j; 28 if (j == m) { 29 cout \u0026lt;\u0026lt; i - m + 2 \u0026lt;\u0026lt; endl; 30 j = nxt[j - 1]; 31 } 32 } 33 for (int i = 0; i \u0026lt; m; i++) { 34 cout \u0026lt;\u0026lt; nxt[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 35 } 36 cout \u0026lt;\u0026lt; endl; 37} 38 39int main() { 40 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; 41 kmp(); 42 return 0; 43} EXKMP(Z-algorithm) 理论学习 线性时间复杂度求出字符串s和他的任意后缀 s[i]\u0026hellip;s[n] 的最长公共前缀的长度 O(n)\n与 kmp 的区别：一个是到 s[i] 结束，一个是从 s[i] 开始\n定义 z[1] = 0，从 2 到 n 枚举 i，依次计算 z[i] 的值\n计算 z[i] 时，前面的 z 都已经计算好了\n对于 j，有 s[j]\u0026hellip;s[j + z[j] - 1] 和 s[1]\u0026hellip;s[z[j]] 完全相等\n为了计算 z[i]，在枚举i的过程中，需要维护R的最大区间 [L, R],其中 L = j，R =j + z[i] - 1\n初始时 L = 1,R = 0\n如果 i \u0026lt;= R:\n易知 s[L]\u0026hellip;s[R] = s[1]\u0026hellip;s[R - L + 1]\n令 k = i - L + 1,i 与 k 的位置对应，此时s[i]..s[R] = s[k]..s[R - L + 1]\n如果 z[k] \u0026lt; R - i + 1，说明从 k 开始匹配不到那么远，也就是从 i 开始匹配不到 R，此时 z[i] = z[k]\n反之，说明可以匹配到 R 那么远，从 R+1 开始往后暴力\n如果 i \u0026gt; R:\n暴力枚举匹配，记得更新 L 和 R\n1void exkmp(){ 2 int L=1,R=0; 3 z[1]=0; 4 for(int i=2;i\u0026lt;=2;i++){ 5 if(i\u0026gt;R) 6 z[i]=0; 7 else{ 8 int k=i-L+1; 9 z[i]=min(z[k],R-i+1); 10 } 11 while(i+z[i]\u0026lt;=n\u0026amp;\u0026amp;s[z[i]+1]==s[i+z[i]]) 12 ++z[i]; 13 if(i+z[i]-1\u0026gt;R) 14 L=i,R=i+z[i]=1; 15 } 16} 例题 给出字符串 s, p,求 s 中 p 出现的次数和位置\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4string s,p; 5int z[200001],n,m; 6 7void exkmp(){ 8 n=s.size(); 9 m=p.size(); 10 p=p+\u0026#34;#\u0026#34;+s; 11 int L=0,R=-1; 12 z[0]=0; 13 for(int i=1;i\u0026lt;n+m+1;i++){ 14 if(i\u0026gt;R) 15 z[i]=0; 16 else{ 17 int k=i-L; 18 z[i]=min(z[k],R-i); 19 } 20 while(i+z[i]\u0026lt;n+m+1\u0026amp;\u0026amp;p[z[i]]==p[i+z[i]]) 21 ++z[i]; 22 if(i+z[i]-1\u0026gt;R) 23 L=i,R=i+z[i]-1; 24 } 25 int ans=0; 26 for(int i=m+1;i\u0026lt;m+n+1;i++) 27 if(z[i]==m)ans++; 28 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; 29 for(int i=m+1;i\u0026lt;n+m+1;i++) 30 if(z[i]==m)cout\u0026lt;\u0026lt;i-m\u0026lt;\u0026lt;endl; 31} 32 33int main(){ 34 cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;p; 35 exkmp(); 36 return 0; 37} ","permalink":"https://KiritoXDone.github.io/posts/study/kmp/","summary":"KMP学习记录 理念学习 字符串匹配问题 查找s中p是否出现 暴力匹配 O(nm) 哈希优化 O(n+m) KMP 线性复杂度解决 O(n+m) KMP 中对于 s 中每个位置 i，我们要找到最大的 j 满足s[i - j +1]\u0026hellip;s[i] 和 p[1]\u0026hellip;[j] 相同 f[i] 对应j的位置，j对应p中的位置 如果 j 不等于 m，并且 s[i + 1] == p[j + 1]，j 右移一位 否则，j 向前回退，到满足 s[i - k + 1]\u0026hellip;s[i] == p[1]\u0026hellip;[j] 且 k","title":"KMP"},{"content":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取\n排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素\n将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放\n确定 x 的位置后，对两侧继续递归\n1void quicksort(int l, int r) { 2 if (l \u0026gt;= r) return; // 长度小于 1，直接退出 3 swap(a[l], a[l + rand() % (r - l + 1)]); // 保证 x 随机取 4 int x = a[l]; 5 int i = l, j = r; 6 while (i \u0026lt; j) { 7 while (i \u0026lt; j \u0026amp;\u0026amp; a[j] \u0026gt; x) // 不能写成 a[j] \u0026gt;= x 8 j--; 9 if (i \u0026lt; j) 10 a[i++] = a[j]; 11 while (i \u0026lt; j \u0026amp;\u0026amp; a[i] \u0026lt; x) // 不能写成 a[i] \u0026lt;= x 12 i++; 13 if (i \u0026lt; j) 14 a[j--] = a[i]; 15 } 16 a[i] = x; 17 quicksort(l, i - 1); // 不能递归 i 18 quicksort(i + 1, r); 19} //另一种写法\n1void Quicksort(int l, int r){ 2 if(l\u0026gt;=r)return; 3 int b[100001],c[100001]; 4 int x=a[l+rand()\u0026amp;(r-l+1)]; 5 int l1=0,l2=0,y=0; 6 for(int i=l;i\u0026lt;=r;i++){ 7 if(a[i]\u0026lt;x) 8 b[++l1]=a[i]; 9 else 10 if(a[i]\u0026gt;x) 11 c[++l2]=a[i]; 12 else ++y; 13 } 14 for(int i=1;i\u0026lt;=l1;i++) 15 a[l+i-1]=b[i]; 16 for(int i=1;i\u0026lt;=y;i++) 17 a[l+l1+i-1]=x; 18 for(int i=1;i\u0026lt;=l2;i++) 19 a[l+l1+y+i-1]=c[i]; 20 Quicksort(l,l+l1-1); 21 Quicksort(l+l1+y,r); 22} 归并排序 归并排序 分治 复杂度 nlogn 且稳定 要排序 [l, r]，长度为1直接退出，否则分为 [l, m],[m+1, r]; 递归两个子区间进行归并排序 将排序好的子区间合并\n1void mergesort(int l,int r){ 2 if(l==r)return; 3 int m=(l+r)/2; 4 mergesort(l,m); 5 mergesort(m+1,r); 6 int p1=l,p2=m+1,tot=0; 7 while(p1\u0026lt;=m\u0026amp;\u0026amp;p2\u0026lt;=r){ 8 if(a[p1]\u0026lt;=a[p2]) 9 c[++tot]==a[p1++]; 10 else 11 c[++tot]=a[p2++]; 12 } 13 while(p1\u0026lt;=m) 14 c[++tot]=a[p1++]; 15 while(p2\u0026lt;=m) 16 c[++tot]=a[p2++]; 17 for(int i=1;i\u0026lt;=tot;i++) 18 a[i+l-1]=c[i]; 19} 计数排序 计数排序 适合值域范围较小 复杂度 n+k 稳定 统计每个数字出现了几次 统计完出现次数，求前缀和，可知道每个数字在拍完序的位置的范围 保证稳定性，倒着确定原本每个位置上的数字最后排在低级位\n1void countingsort(){ 2 memset(c,0,sizeof(c)); 3 for(int i=1;i\u0026lt;=n;i++) 4 ++c[a[i]]; 5 for(int i=1;i\u0026lt;=m;i++) 6 for(int j=1;j\u0026lt;=c[i];j++) 7 printf(\u0026#34;%d\u0026#34;,i); 8 printf(\u0026#34;\\n\u0026#34;); 9 10 for(int i=2;i\u0026lt;=m;i++) 11 c[i]+=c[i-1]; 12 for(int i=n;i;i--) 13 r[i]=c[a[i]]--; 14 for(int i=1;i\u0026lt;=n;i++) 15 printf(\u0026#34;%d\u0026#34;,r[i]); 16 printf(\u0026#34;\\n\u0026#34;); 17} 基数排序 基数排序 复杂度 nk 拆分成 m 个关键字 从后往前 依次对 m 个关键字进行排序 每次排序会使用上一次排序的结果 一般使用计数排序来完成每次的排序 例如对三位数排序 先排个位 再排十位 再排百位 经常被用于字符串的排序 后缀数组的核心就是基数排序\n1void countingsort(){ 2 memset(c,0,sizeof(c)); 3 for(int i=1;i\u0026lt;=n;i++) 4 ++c[v[i]]; 5 for(int i=1;i\u0026lt;=9;i++) 6 c[i]+=c[i-1]; 7 for(int i=n;i;i--) 8 r[sa[i]]=c[v[sa[i]]]--; 9 for(int i=1;i\u0026lt;=n;i++) 10 sa[r[i]]=i; 11} 12 13void radixsort(){ 14 for(int i=1;i\u0026lt;=n;i++) 15 sa[i]=i; 16 int x=1; 17 for(int i=1;i\u0026lt;=m;i++,x*=10){ 18 for(int j=1;j\u0026lt;=n;j++){ 19 v[j]=a[j]/x%10; 20 } 21 countingsort(); 22 } 23} ","permalink":"https://KiritoXDone.github.io/posts/study/easy-sort/","summary":"简单的排序实现 快速排序 快排 分治思想 复杂度 [nlogn, n^2] 不稳定 \u0026ndash;x随机取 排序区间为 [l, r] 时，长度小于 1，直接退出，否则选一个数字 x 作为比较元素 将大于 x 的放右边，小于 x 的放左边，等于 x 的随意放 确定 x 的位置后，对两侧继续递归 1void quicksort(int l, int r) { 2 if (l \u0026gt;= r) return; // 长度小于 1，直接退出 3 swap(a[l], a[l + rand() % (r -","title":"简单的排序"}]